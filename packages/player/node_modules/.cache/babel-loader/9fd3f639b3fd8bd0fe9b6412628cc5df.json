{"ast":null,"code":"import join from \"./join\"; // Given an extracted (pre-)topology, cuts (or rotates) arcs so that all shared\n// point sequences are identified. The topology can then be subsequently deduped\n// to remove exact duplicate arcs.\n\nexport default function (topology) {\n  var junctions = join(topology),\n      coordinates = topology.coordinates,\n      lines = topology.lines,\n      rings = topology.rings,\n      next,\n      i,\n      n;\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    var line = lines[i],\n        lineMid = line[0],\n        lineEnd = line[1];\n\n    while (++lineMid < lineEnd) {\n      if (junctions.has(coordinates[lineMid])) {\n        next = {\n          0: lineMid,\n          1: line[1]\n        };\n        line[1] = lineMid;\n        line = line.next = next;\n      }\n    }\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    var ring = rings[i],\n        ringStart = ring[0],\n        ringMid = ringStart,\n        ringEnd = ring[1],\n        ringFixed = junctions.has(coordinates[ringStart]);\n\n    while (++ringMid < ringEnd) {\n      if (junctions.has(coordinates[ringMid])) {\n        if (ringFixed) {\n          next = {\n            0: ringMid,\n            1: ring[1]\n          };\n          ring[1] = ringMid;\n          ring = ring.next = next;\n        } else {\n          // For the first junction, we can rotate rather than cut.\n          rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);\n          coordinates[ringEnd] = coordinates[ringStart];\n          ringFixed = true;\n          ringMid = ringStart; // restart; we may have skipped junctions\n        }\n      }\n    }\n  }\n\n  return topology;\n}\n\nfunction rotateArray(array, start, end, offset) {\n  reverse(array, start, end);\n  reverse(array, start, start + offset);\n  reverse(array, start + offset, end);\n}\n\nfunction reverse(array, start, end) {\n  for (var mid = start + (end-- - start >> 1), t; start < mid; ++start, --end) {\n    t = array[start], array[start] = array[end], array[end] = t;\n  }\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/topojson/node_modules/topojson-server/src/cut.js"],"names":["join","topology","junctions","coordinates","lines","rings","next","i","n","length","line","lineMid","lineEnd","has","ring","ringStart","ringMid","ringEnd","ringFixed","rotateArray","array","start","end","offset","reverse","mid","t"],"mappings":"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","sourcesContent":["import join from \"./join\";\n\n// Given an extracted (pre-)topology, cuts (or rotates) arcs so that all shared\n// point sequences are identified. The topology can then be subsequently deduped\n// to remove exact duplicate arcs.\nexport default function(topology) {\n  var junctions = join(topology),\n      coordinates = topology.coordinates,\n      lines = topology.lines,\n      rings = topology.rings,\n      next,\n      i, n;\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    var line = lines[i],\n        lineMid = line[0],\n        lineEnd = line[1];\n    while (++lineMid < lineEnd) {\n      if (junctions.has(coordinates[lineMid])) {\n        next = {0: lineMid, 1: line[1]};\n        line[1] = lineMid;\n        line = line.next = next;\n      }\n    }\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    var ring = rings[i],\n        ringStart = ring[0],\n        ringMid = ringStart,\n        ringEnd = ring[1],\n        ringFixed = junctions.has(coordinates[ringStart]);\n    while (++ringMid < ringEnd) {\n      if (junctions.has(coordinates[ringMid])) {\n        if (ringFixed) {\n          next = {0: ringMid, 1: ring[1]};\n          ring[1] = ringMid;\n          ring = ring.next = next;\n        } else { // For the first junction, we can rotate rather than cut.\n          rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);\n          coordinates[ringEnd] = coordinates[ringStart];\n          ringFixed = true;\n          ringMid = ringStart; // restart; we may have skipped junctions\n        }\n      }\n    }\n  }\n\n  return topology;\n}\n\nfunction rotateArray(array, start, end, offset) {\n  reverse(array, start, end);\n  reverse(array, start, start + offset);\n  reverse(array, start + offset, end);\n}\n\nfunction reverse(array, start, end) {\n  for (var mid = start + ((end-- - start) >> 1), t; start < mid; ++start, --end) {\n    t = array[start], array[start] = array[end], array[end] = t;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}