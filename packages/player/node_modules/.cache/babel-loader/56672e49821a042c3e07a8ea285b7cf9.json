{"ast":null,"code":"import debug from \"debug\";\nimport getSupportedAudioCodecs from \"../../test-audio-codecs\";\nimport { decodeAudioBuffer } from \"./decodeAudioBuffer\";\nconst log = debug(\"atpls:resources\"); // TODO: abstract the loader mechanism: { stage, payload }\n\nexport class ResourceLoader {\n  constructor(audioset, listener) {\n    this.audioset = audioset;\n    this.listener = listener;\n    this.status = void 0;\n    this.total = void 0;\n    this.completed = void 0;\n    this.buffers = {};\n    this.preloaded = void 0;\n    this.format = void 0;\n    log(\"create ResourceLoader %s\", audioset.id);\n    const codecs = getSupportedAudioCodecs();\n    this.format = codecs.ogg ? \"ogg\" : codecs.mp3 ? \"mp3\" : \"wav\";\n    log(\"Preferred audio format %s\", this.format);\n    this.status = {\n      stage: \"pending\"\n    };\n    this.preloaded = false;\n    this.total = this.audioset.clips.length;\n    this.completed = 0;\n    setTimeout(() => {\n      this.preload();\n    }, 2000);\n  }\n\n  getStatus() {\n    return this.status;\n  }\n\n  getBuffer(clipId) {\n    return this.buffers[clipId];\n  }\n\n  load(context) {\n    this.preload();\n    const total = this.total,\n          completed = this.completed;\n\n    if (total === completed) {\n      return Promise.resolve();\n    }\n\n    log(\"Start clip audio loading [%s]\", this.audioset.meta.title);\n    this.setStatus({\n      stage: \"loading\",\n      total,\n      completed: 0\n    });\n    const clips = this.audioset.clips;\n\n    if (clips[0]) {\n      log(\"Audio format %s\", clips[0].resources.audio.ogg ? \"ogg\" : \"mp3\");\n    }\n\n    const promises = clips.map(clip => this.loadClipAudio(clip, context).catch(err => {\n      this.handleResourceCompleted();\n      log(\"Error %o\", err);\n    }));\n    return Promise.all(promises);\n  }\n\n  preload() {\n    if (this.preloaded) {\n      return Promise.resolve();\n    }\n\n    log(\"Preload\");\n    this.preloaded = true;\n    const _this$audioset = this.audioset,\n          visuals = _this$audioset.visuals,\n          clips = _this$audioset.clips;\n    const promises = [];\n\n    if (visuals.mode === \"map\" && visuals.geomap.url) {\n      promises.push(fetch(visuals.geomap.url));\n    }\n\n    clips.forEach(clip => {\n      preloadImage(clip.resources.cover.small);\n    });\n\n    const loadAll = () => {\n      log(\"Preload images\");\n      return Promise.all(promises);\n    };\n\n    return preloadImage(this.audioset.meta.logo_url).then(loadAll).catch(loadAll);\n  } //// PRIVATE ////\n\n\n  setStatus(status) {\n    if (status.stage !== \"loading\") {\n      log(\"stage %s\", status.stage);\n    }\n\n    this.status = status;\n    this.listener(status);\n  }\n\n  async loadClipAudio(clip, context) {\n    const audio = clip.resources.audio;\n    const codecs = getSupportedAudioCodecs();\n    const url = codecs.ogg ? audio.ogg : codecs.mp3 ? audio.mp3 : audio.wav;\n\n    if (!url) {\n      log(\"Valid audio format not found\", clip, codecs);\n      return null;\n    }\n\n    const response = await fetch(url);\n    const buffer = await decodeAudioBuffer(response, context);\n    this.buffers[clip.id] = buffer;\n    this.handleResourceCompleted(url);\n    return buffer;\n  }\n\n  handleResourceCompleted(url) {\n    this.completed += 1;\n    const status = this.completed >= this.total ? {\n      stage: \"ready\",\n      total: this.total\n    } : {\n      stage: \"loading\",\n      total: this.total,\n      completed: this.completed\n    };\n    this.setStatus(status);\n  }\n\n}\n\nfunction preloadImage(url) {\n  if (!url || !url.length) {\n    return Promise.resolve();\n  }\n\n  return new Promise(resolve => {\n    const image = new Image();\n    image.addEventListener(\"load\", () => {\n      resolve(image);\n    });\n    image.src = url;\n  });\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/src/player/Loader/ResourceLoader.ts"],"names":["debug","getSupportedAudioCodecs","decodeAudioBuffer","log","ResourceLoader","constructor","audioset","listener","status","total","completed","buffers","preloaded","format","id","codecs","ogg","mp3","stage","clips","length","setTimeout","preload","getStatus","getBuffer","clipId","load","context","Promise","resolve","meta","title","setStatus","resources","audio","promises","map","clip","loadClipAudio","catch","err","handleResourceCompleted","all","visuals","mode","geomap","url","push","fetch","forEach","preloadImage","cover","small","loadAll","logo_url","then","wav","response","buffer","image","Image","addEventListener","src"],"mappings":"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","sourcesContent":["import debug from \"debug\";\nimport { IAudioContext } from \"standardized-audio-context\";\nimport { Audioset, Clip } from \"../../audioset\";\nimport getSupportedAudioCodecs from \"../../test-audio-codecs\";\nimport { decodeAudioBuffer } from \"./decodeAudioBuffer\";\n\nconst log = debug(\"atpls:resources\");\n\n// TODO: abstract the loader mechanism: { stage, payload }\nexport interface LoadPending {\n  stage: \"pending\";\n}\nexport interface LoadingResources {\n  stage: \"loading\";\n  total: number;\n  completed: number;\n}\nexport interface ResourcesLoaded {\n  stage: \"ready\";\n  total: number;\n}\nexport interface ResourceLoadError {\n  stage: \"error\";\n  error: any;\n}\n\nexport type ResourceLoadStatus =\n  | LoadPending\n  | LoadingResources\n  | ResourcesLoaded\n  | ResourceLoadError;\n\nexport interface Resources {\n  getStatus(): ResourceLoadStatus;\n  getBuffer(clipId: string): any;\n  load(ctx: IAudioContext): Promise<any>;\n}\n\nexport class ResourceLoader implements Resources {\n  public status: ResourceLoadStatus;\n  private total: number;\n  private completed: number;\n  private buffers: Record<string, any> = {};\n  private preloaded: boolean;\n  private readonly format: string;\n\n  constructor(\n    private audioset: Audioset,\n    private listener: (status: ResourceLoadStatus) => void,\n  ) {\n    log(\"create ResourceLoader %s\", audioset.id);\n    const codecs = getSupportedAudioCodecs();\n    this.format = codecs.ogg ? \"ogg\" : codecs.mp3 ? \"mp3\" : \"wav\";\n    log(\"Preferred audio format %s\", this.format);\n    this.status = { stage: \"pending\" };\n    this.preloaded = false;\n    this.total = this.audioset.clips.length;\n    this.completed = 0;\n    setTimeout(() => {\n      this.preload();\n    }, 2000);\n  }\n\n  public getStatus() {\n    return this.status;\n  }\n\n  public getBuffer(clipId: string): any {\n    return this.buffers[clipId];\n  }\n\n  public load(context: IAudioContext) {\n    this.preload();\n    const { total, completed } = this;\n    if (total === completed) {\n      return Promise.resolve();\n    }\n\n    log(\"Start clip audio loading [%s]\", this.audioset.meta.title);\n    this.setStatus({ stage: \"loading\", total, completed: 0 });\n    const clips = this.audioset.clips;\n    if (clips[0]) {\n      log(\"Audio format %s\", clips[0].resources.audio.ogg ? \"ogg\" : \"mp3\");\n    }\n    const promises = clips.map(clip =>\n      this.loadClipAudio(clip, context).catch(err => {\n        this.handleResourceCompleted();\n        log(\"Error %o\", err);\n      }),\n    );\n    return Promise.all(promises);\n  }\n\n  private preload() {\n    if (this.preloaded) {\n      return Promise.resolve();\n    }\n\n    log(\"Preload\");\n    this.preloaded = true;\n    const { visuals, clips } = this.audioset;\n    const promises: Array<Promise<any>> = [];\n    if (visuals.mode === \"map\" && visuals.geomap.url) {\n      promises.push(fetch(visuals.geomap.url));\n    }\n    clips.forEach(clip => {\n      preloadImage(clip.resources.cover.small);\n    });\n    const loadAll = () => {\n      log(\"Preload images\");\n      return Promise.all(promises);\n    };\n\n    return preloadImage(this.audioset.meta.logo_url)\n      .then(loadAll)\n      .catch(loadAll);\n  }\n\n  //// PRIVATE ////\n  private setStatus(status: ResourceLoadStatus) {\n    if (status.stage !== \"loading\") {\n      log(\"stage %s\", status.stage);\n    }\n    this.status = status;\n    this.listener(status);\n  }\n\n  private async loadClipAudio(clip: Clip, context: IAudioContext) {\n    const { audio } = clip.resources;\n    const codecs = getSupportedAudioCodecs();\n    const url = codecs.ogg ? audio.ogg : codecs.mp3 ? audio.mp3 : audio.wav;\n    if (!url) {\n      log(\"Valid audio format not found\", clip, codecs);\n      return null;\n    }\n    const response = await fetch(url);\n    const buffer = await decodeAudioBuffer(response, context);\n    this.buffers[clip.id] = buffer;\n    this.handleResourceCompleted(url);\n\n    return buffer;\n  }\n\n  private handleResourceCompleted(url?: string) {\n    this.completed += 1;\n    const status: ResourceLoadStatus =\n      this.completed >= this.total\n        ? { stage: \"ready\", total: this.total }\n        : { stage: \"loading\", total: this.total, completed: this.completed };\n    this.setStatus(status);\n  }\n}\n\nfunction preloadImage(url: string): Promise<any> {\n  if (!url || !url.length) {\n    return Promise.resolve();\n  }\n  return new Promise(resolve => {\n    const image = new Image();\n    image.addEventListener(\"load\", () => {\n      resolve(image);\n    });\n    image.src = url;\n  });\n}\n"]},"metadata":{},"sourceType":"module"}