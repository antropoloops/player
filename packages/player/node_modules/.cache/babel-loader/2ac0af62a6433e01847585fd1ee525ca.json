{"ast":null,"code":"import debug from \"debug\";\nimport { decodeAudioBuffer } from \"./decodeAudioBuffer\";\nconst log = debug(\"atpls:resources\"); // TODO: abstract the loader mechanism: { stage, payload }\n\nexport class ResourceLoader {\n  constructor(audioset, listener) {\n    this.audioset = audioset;\n    this.listener = listener;\n    this.status = void 0;\n    this.preloadImage = void 0;\n    this.total = void 0;\n    this.completed = void 0;\n    this.buffers = {};\n    log(\"create ResourceLoader %s\", audioset.id);\n    this.status = {\n      stage: \"pending\"\n    };\n    this.total = this.audioset.clips.length;\n    this.completed = 0;\n    this.preloadImage = preloadImage;\n  }\n\n  getBuffer(clipId) {\n    return this.buffers[clipId];\n  }\n\n  preload() {\n    log(\"Preload\");\n    const _this$audioset = this.audioset,\n          visuals = _this$audioset.visuals,\n          clips = _this$audioset.clips;\n\n    if (visuals.mode === \"map\" && visuals.geomap.url) {\n      fetch(visuals.geomap.url);\n    }\n\n    clips.forEach(clip => {\n      this.preloadImage(clip.resources.cover.small);\n    });\n  }\n\n  load() {\n    const total = this.total,\n          completed = this.completed;\n\n    if (total === completed) {\n      return;\n    }\n\n    this.setStatus({\n      status: \"loading\",\n      total,\n      completed: 0\n    });\n    const clips = this.audioset.clips;\n    const promises = clips.map(clip => this.loadAudio(clip).catch(err => {\n      this.handleResourceCompleted();\n      log(\"Error %o\", err);\n    }));\n    return Promise.all(promises);\n  } //// PRIVATE ////\n\n\n  setStatus(status) {\n    this.status = status;\n    this.listener(status);\n  }\n\n  async loadAudio(clip) {\n    // TODO: check other formats\n    const url = clip.resources.audio.mp3;\n    const response = await fetch(url);\n    const buffer = await decodeAudioBuffer(response);\n    this.buffers[clip.id] = buffer;\n    this.handleResourceCompleted(url);\n    return buffer;\n  }\n\n  handleResourceCompleted(url) {\n    this.completed += 1;\n    const status = this.completed >= this.total ? {\n      status: \"ready\",\n      total: this.total\n    } : {\n      status: \"loading\",\n      total: this.total,\n      completed: this.completed\n    };\n    this.setStatus(status);\n  }\n\n}\n\nfunction preloadImage(url) {\n  if (url && url.length) {\n    return new Promise(resolve => {\n      const image = new Image();\n      image.addEventListener(\"load\", () => {\n        resolve(image);\n      });\n      image.src = url;\n    });\n  }\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/src/player/ResourceLoader.ts"],"names":["debug","decodeAudioBuffer","log","ResourceLoader","constructor","audioset","listener","status","preloadImage","total","completed","buffers","id","stage","clips","length","getBuffer","clipId","preload","visuals","mode","geomap","url","fetch","forEach","clip","resources","cover","small","load","setStatus","promises","map","loadAudio","catch","err","handleResourceCompleted","Promise","all","audio","mp3","response","buffer","resolve","image","Image","addEventListener","src"],"mappings":"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","sourcesContent":["import debug from \"debug\";\nimport { Audioset, Clip } from \"../audioset\";\nimport { decodeAudioBuffer } from \"./decodeAudioBuffer\";\n\nconst log = debug(\"atpls:resources\");\n\n// TODO: abstract the loader mechanism: { stage, payload }\nexport interface LoadPending {\n  stage: \"pending\";\n}\nexport interface LoadingResources {\n  stage: \"loading\";\n  total: number;\n  completed: number;\n}\nexport interface ResourcesLoaded {\n  stage: \"ready\";\n  total: number;\n}\nexport interface ResourceLoadError {\n  stage: \"error\";\n  error: any;\n}\n\nexport type ResourceLoadStatus =\n  | LoadPending\n  | LoadingResources\n  | ResourcesLoaded\n  | ResourceLoadError;\n\nexport class ResourceLoader {\n  public status: ResourceLoadStatus;\n  private preloadImage: (url: string) => void;\n  private total: number;\n  private completed: number;\n  private buffers: Record<string, any> = {};\n\n  constructor(\n    private audioset: Audioset,\n    private listener: (status: ResourceLoadStatus) => void,\n  ) {\n    log(\"create ResourceLoader %s\", audioset.id);\n    this.status = { stage: \"pending\" };\n    this.total = this.audioset.clips.length;\n    this.completed = 0;\n    this.preloadImage = preloadImage;\n  }\n\n  public getBuffer(clipId: string): any {\n    return this.buffers[clipId];\n  }\n\n  public preload() {\n    log(\"Preload\");\n    const { visuals, clips } = this.audioset;\n    if (visuals.mode === \"map\" && visuals.geomap.url) {\n      fetch(visuals.geomap.url);\n    }\n    clips.forEach(clip => {\n      this.preloadImage(clip.resources.cover.small);\n    });\n  }\n\n  public load() {\n    const { total, completed } = this;\n    if (total === completed) {\n      return;\n    }\n\n    this.setStatus({ status: \"loading\", total, completed: 0 });\n    const clips = this.audioset.clips;\n    const promises = clips.map(clip =>\n      this.loadAudio(clip).catch(err => {\n        this.handleResourceCompleted();\n        log(\"Error %o\", err);\n      }),\n    );\n    return Promise.all(promises);\n  }\n\n  //// PRIVATE ////\n  private setStatus(status: ResourceLoadStatus) {\n    this.status = status;\n    this.listener(status);\n  }\n\n  private async loadAudio(clip: Clip) {\n    // TODO: check other formats\n    const url = clip.resources.audio.mp3;\n    const response = await fetch(url);\n    const buffer = await decodeAudioBuffer(response);\n    this.buffers[clip.id] = buffer;\n    this.handleResourceCompleted(url);\n\n    return buffer;\n  }\n\n  private handleResourceCompleted(url?: string) {\n    this.completed += 1;\n    const status: ResourceLoadStatus =\n      this.completed >= this.total\n        ? { status: \"ready\", total: this.total }\n        : { status: \"loading\", total: this.total, completed: this.completed };\n    this.setStatus(status);\n  }\n}\n\nfunction preloadImage(url: string) {\n  if (url && url.length) {\n    return new Promise(resolve => {\n      const image = new Image();\n      image.addEventListener(\"load\", () => {\n        resolve(image);\n      });\n      image.src = url;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}