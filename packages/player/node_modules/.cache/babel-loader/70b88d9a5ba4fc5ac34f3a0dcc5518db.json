{"ast":null,"code":"import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n  channelCount: 2,\n  // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n  channelCountMode: 'explicit',\n  channelInterpretation: 'speakers',\n  numberOfInputs: 1,\n  numberOfOutputs: 1,\n  outputChannelCount: undefined,\n  parameterData: {},\n  processorOptions: {}\n};\n\nconst createChannelCount = length => {\n  const channelCount = [];\n\n  for (let i = 0; i < length; i += 1) {\n    channelCount.push(1);\n  }\n\n  return channelCount;\n};\n\nconst sanitizedOptions = options => {\n  return { ...options,\n    outputChannelCount: options.outputChannelCount !== undefined ? options.outputChannelCount : options.numberOfInputs === 1 && options.numberOfOutputs === 1 ?\n    /*\n     * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n     * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n     * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n     */\n    [options.channelCount] : createChannelCount(options.numberOfOutputs)\n  };\n};\n\nexport const createAudioWorkletNodeConstructor = (audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, gainNodeConstructor, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, wrapEventListener) => {\n  return class AudioWorkletNode extends audioNodeConstructor {\n    constructor(context, name, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS,\n        ...options\n      });\n      const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n      const processorConstructor = nodeNameToProcessorConstructorMap === undefined ? undefined : nodeNameToProcessorConstructorMap.get(name);\n      const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n      const audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null;\n      /*\n       * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n       * returns false.\n       */\n\n      super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n      const parameters = [];\n      nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n        const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n        parameters.push([nm, audioParam]);\n      });\n      this._nativeAudioWorkletNode = nativeAudioWorkletNode; // Bug #86 & #87: Every browser but Firefox needs to get an unused output which should not be exposed.\n\n      this._numberOfOutputs = options.numberOfOutputs === 0 ? 0 : this._nativeAudioWorkletNode.numberOfOutputs;\n      this._onprocessorerror = null;\n      this._parameters = new ReadOnlyMap(parameters);\n      /*\n       * Bug #86 & #87: Every browser but Firefox needs an output to be connected.\n       *\n       * Bug #50: Only Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore this is currently faked by\n       * using another AudioContext. And that is the reason why this will fail in case of a closed AudioContext.\n       */\n\n      if (context.state !== 'closed') {\n        const gainNode = new gainNodeConstructor(context, {\n          gain: 0\n        });\n\n        try {\n          this.connect(gainNode).connect(context.destination);\n        } catch (err) {\n          if (err.name !== 'IndexSizeError') {\n            throw err; // tslint:disable-line:rxjs-throw-error\n          }\n        }\n      }\n    }\n\n    get numberOfOutputs() {\n      return this._numberOfOutputs;\n    }\n\n    get onprocessorerror() {\n      return this._onprocessorerror;\n    }\n\n    set onprocessorerror(value) {\n      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n      this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n      const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n      this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;\n    }\n\n    get parameters() {\n      if (this._parameters === null) {\n        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n        return this._nativeAudioWorkletNode.parameters;\n      }\n\n      return this._parameters;\n    }\n\n    get port() {\n      return this._nativeAudioWorkletNode.port;\n    }\n\n  };\n};","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/standardized-audio-context/build/es2018/factories/audio-worklet-node-constructor.js"],"names":["NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS","ReadOnlyMap","DEFAULT_OPTIONS","channelCount","channelCountMode","channelInterpretation","numberOfInputs","numberOfOutputs","outputChannelCount","undefined","parameterData","processorOptions","createChannelCount","length","i","push","sanitizedOptions","options","createAudioWorkletNodeConstructor","audioNodeConstructor","createAudioParam","createAudioWorkletNodeRenderer","createNativeAudioWorkletNode","gainNodeConstructor","getNativeContext","isNativeOfflineAudioContext","nativeAudioWorkletNodeConstructor","wrapEventListener","AudioWorkletNode","constructor","context","name","nativeContext","isOffline","mergedOptions","nodeNameToProcessorConstructorMap","get","processorConstructor","nativeAudioWorkletNode","baseLatency","audioWorkletNodeRenderer","parameters","forEach","nativeAudioParam","nm","audioParam","_nativeAudioWorkletNode","_numberOfOutputs","_onprocessorerror","_parameters","state","gainNode","gain","connect","destination","err","onprocessorerror","value","wrappedListener","nativeOnProcessorError","port"],"mappings":"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","sourcesContent":["import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    outputChannelCount: undefined,\n    parameterData: {},\n    processorOptions: {}\n};\nconst createChannelCount = (length) => {\n    const channelCount = [];\n    for (let i = 0; i < length; i += 1) {\n        channelCount.push(1);\n    }\n    return channelCount;\n};\nconst sanitizedOptions = (options) => {\n    return {\n        ...options,\n        outputChannelCount: (options.outputChannelCount !== undefined) ?\n            options.outputChannelCount :\n            (options.numberOfInputs === 1 && options.numberOfOutputs === 1) ?\n                /*\n                 * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n                 * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n                 * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n                 */\n                [options.channelCount] :\n                createChannelCount(options.numberOfOutputs)\n    };\n};\nexport const createAudioWorkletNodeConstructor = (audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, gainNodeConstructor, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, wrapEventListener) => {\n    return class AudioWorkletNode extends audioNodeConstructor {\n        constructor(context, name, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = (nodeNameToProcessorConstructorMap === undefined) ?\n                undefined :\n                nodeNameToProcessorConstructorMap.get(name);\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n            const audioWorkletNodeRenderer = ((isOffline)\n                ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor)\n                : null);\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n            const parameters = [];\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n                parameters.push([nm, audioParam]);\n            });\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            // Bug #86 & #87: Every browser but Firefox needs to get an unused output which should not be exposed.\n            this._numberOfOutputs = (options.numberOfOutputs === 0) ? 0 : this._nativeAudioWorkletNode.numberOfOutputs;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n            /*\n             * Bug #86 & #87: Every browser but Firefox needs an output to be connected.\n             *\n             * Bug #50: Only Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore this is currently faked by\n             * using another AudioContext. And that is the reason why this will fail in case of a closed AudioContext.\n             */\n            if (context.state !== 'closed') {\n                const gainNode = new gainNodeConstructor(context, { gain: 0 });\n                try {\n                    this\n                        .connect(gainNode)\n                        .connect(context.destination);\n                }\n                catch (err) {\n                    if (err.name !== 'IndexSizeError') {\n                        throw err; // tslint:disable-line:rxjs-throw-error\n                    }\n                }\n            }\n        }\n        get numberOfOutputs() {\n            return this._numberOfOutputs;\n        }\n        get onprocessorerror() {\n            return this._onprocessorerror;\n        }\n        set onprocessorerror(value) {\n            const wrappedListener = (typeof value === 'function')\n                ? wrapEventListener(this, value)\n                : null;\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n            this._onprocessorerror = (nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener)\n                ? value\n                : nativeOnProcessorError;\n        }\n        get parameters() {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return this._nativeAudioWorkletNode.parameters;\n            }\n            return this._parameters;\n        }\n        get port() {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-worklet-node-constructor.js.map"]},"metadata":{},"sourceType":"module"}