{"ast":null,"code":"import { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n  numberOfChannels: 1\n};\nexport const createOfflineAudioContextConstructor = (baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering) => {\n  return class OfflineAudioContext extends baseAudioContextConstructor {\n    constructor(a, b, c) {\n      let options;\n\n      if (typeof a === 'number' && b !== undefined && c !== undefined) {\n        options = {\n          length: b,\n          numberOfChannels: a,\n          sampleRate: c\n        };\n      } else if (typeof a === 'object') {\n        options = a;\n      } else {\n        throw new Error('The given parameters are not valid.');\n      }\n\n      const {\n        length,\n        numberOfChannels,\n        sampleRate\n      } = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate); // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n\n      if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n        nativeOfflineAudioContext.addEventListener('statechange', (() => {\n          let i = 0;\n\n          const delayStateChangeEvent = event => {\n            if (this._state === 'running') {\n              if (i > 0) {\n                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                event.stopImmediatePropagation();\n\n                this._waitForThePromiseToSettle(event);\n              } else {\n                i += 1;\n              }\n            }\n          };\n\n          return delayStateChangeEvent;\n        })());\n      }\n\n      super(nativeOfflineAudioContext, numberOfChannels);\n      this._length = length;\n      this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n      this._state = null;\n    }\n\n    get length() {\n      // Bug #17: Safari does not yet expose the length.\n      if (this._nativeOfflineAudioContext.length === undefined) {\n        return this._length;\n      }\n\n      return this._nativeOfflineAudioContext.length;\n    }\n\n    get state() {\n      return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n    }\n\n    startRendering() {\n      /*\n       * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n       * the state of the nativeOfflineAudioContext might no transition to running immediately.\n       */\n      if (this._state === 'running') {\n        return Promise.reject(createInvalidStateError());\n      }\n\n      this._state = 'running';\n      return startRendering(this.destination, this._nativeOfflineAudioContext).then(audioBuffer => {\n        this._state = null;\n        /*\n         * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n         * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n         */\n\n        return audioBuffer;\n      }) // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n      .catch(err => {\n        this._state = null;\n        /*\n         * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n         * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n         */\n\n        throw err; // tslint:disable-line:rxjs-throw-error\n      });\n    }\n\n    _waitForThePromiseToSettle(event) {\n      if (this._state === null) {\n        this._nativeOfflineAudioContext.dispatchEvent(event);\n      } else {\n        setTimeout(() => this._waitForThePromiseToSettle(event));\n      }\n    }\n\n  };\n};","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/standardized-audio-context/build/es2018/factories/offline-audio-context-constructor.js"],"names":["testPromiseSupport","DEFAULT_OPTIONS","numberOfChannels","createOfflineAudioContextConstructor","baseAudioContextConstructor","cacheTestResult","createInvalidStateError","createNativeOfflineAudioContext","startRendering","OfflineAudioContext","constructor","a","b","c","options","undefined","length","sampleRate","Error","nativeOfflineAudioContext","addEventListener","i","delayStateChangeEvent","event","_state","removeEventListener","stopImmediatePropagation","_waitForThePromiseToSettle","_length","_nativeOfflineAudioContext","state","Promise","reject","destination","then","audioBuffer","catch","err","dispatchEvent","setTimeout"],"mappings":"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","sourcesContent":["import { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createOfflineAudioContextConstructor = (baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering) => {\n    return class OfflineAudioContext extends baseAudioContextConstructor {\n        constructor(a, b, c) {\n            let options;\n            if (typeof a === 'number' && b !== undefined && c !== undefined) {\n                options = { length: b, numberOfChannels: a, sampleRate: c };\n            }\n            else if (typeof a === 'object') {\n                options = a;\n            }\n            else {\n                throw new Error('The given parameters are not valid.');\n            }\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener('statechange', (() => {\n                    let i = 0;\n                    const delayStateChangeEvent = (event) => {\n                        if (this._state === 'running') {\n                            if (i > 0) {\n                                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                event.stopImmediatePropagation();\n                                this._waitForThePromiseToSettle(event);\n                            }\n                            else {\n                                i += 1;\n                            }\n                        }\n                    };\n                    return delayStateChangeEvent;\n                })());\n            }\n            super(nativeOfflineAudioContext, numberOfChannels);\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n        get length() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n        }\n        get state() {\n            return (this._state === null) ? this._nativeOfflineAudioContext.state : this._state;\n        }\n        startRendering() {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return startRendering(this.destination, this._nativeOfflineAudioContext)\n                .then((audioBuffer) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                return audioBuffer;\n            })\n                // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n                .catch((err) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n        _waitForThePromiseToSettle(event) {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            }\n            else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/offline-audio-context-constructor.js.map"]},"metadata":{},"sourceType":"module"}