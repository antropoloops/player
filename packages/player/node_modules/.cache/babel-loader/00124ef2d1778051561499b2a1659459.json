{"ast":null,"code":"import { geoProjectionMutator as projectionMutator } from \"d3-geo\";\nimport { abs, asin, pi, pow, sign, sin } from \"./math.js\";\nimport { integrate } from \"./integrate.js\";\nexport function hyperellipticalRaw(alpha, k, gamma) {\n  function elliptic(f) {\n    return alpha + (1 - alpha) * pow(1 - pow(f, k), 1 / k);\n  }\n\n  function z(f) {\n    return integrate(elliptic, 0, f, 1e-4);\n  }\n\n  var G = 1 / z(1),\n      n = 1000,\n      m = (1 + 1e-8) * G,\n      approx = [];\n\n  for (var i = 0; i <= n; i++) {\n    approx.push(z(i / n) * m);\n  }\n\n  function Y(sinphi) {\n    var rmin = 0,\n        rmax = n,\n        r = n >> 1;\n\n    do {\n      if (approx[r] > sinphi) rmax = r;else rmin = r;\n      r = rmin + rmax >> 1;\n    } while (r > rmin);\n\n    var u = approx[r + 1] - approx[r];\n    if (u) u = (sinphi - approx[r + 1]) / u;\n    return (r + 1 + u) / n;\n  }\n\n  var ratio = 2 * Y(1) / pi * G / gamma;\n\n  var forward = function forward(lambda, phi) {\n    var y = Y(abs(sin(phi))),\n        x = elliptic(y) * lambda;\n    y /= ratio;\n    return [x, phi >= 0 ? y : -y];\n  };\n\n  forward.invert = function (x, y) {\n    var phi;\n    y *= ratio;\n    if (abs(y) < 1) phi = sign(y) * asin(z(abs(y)) * G);\n    return [x / elliptic(abs(y)), phi];\n  };\n\n  return forward;\n}\nexport default function () {\n  var alpha = 0,\n      k = 2.5,\n      gamma = 1.183136,\n      // affine = sqrt(2 * gamma / pi) = 0.8679\n  m = projectionMutator(hyperellipticalRaw),\n      p = m(alpha, k, gamma);\n\n  p.alpha = function (_) {\n    return arguments.length ? m(alpha = +_, k, gamma) : alpha;\n  };\n\n  p.k = function (_) {\n    return arguments.length ? m(alpha, k = +_, gamma) : k;\n  };\n\n  p.gamma = function (_) {\n    return arguments.length ? m(alpha, k, gamma = +_) : gamma;\n  };\n\n  return p.scale(152.63);\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/d3-geo-projection/src/hyperelliptical.js"],"names":["geoProjectionMutator","projectionMutator","abs","asin","pi","pow","sign","sin","integrate","hyperellipticalRaw","alpha","k","gamma","elliptic","f","z","G","n","m","approx","i","push","Y","sinphi","rmin","rmax","r","u","ratio","forward","lambda","phi","y","x","invert","p","_","arguments","length","scale"],"mappings":"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","sourcesContent":["import {geoProjectionMutator as projectionMutator} from \"d3-geo\";\nimport {abs, asin, pi, pow, sign, sin} from \"./math.js\";\nimport {integrate} from \"./integrate.js\";\n\nexport function hyperellipticalRaw(alpha, k, gamma) {\n\n  function elliptic (f) {\n    return alpha + (1 - alpha) * pow(1 - pow(f, k), 1 / k);\n  }\n\n  function z(f) {\n    return integrate(elliptic, 0, f, 1e-4);\n  }\n\n  var G = 1 / z(1),\n      n = 1000,\n      m = (1 + 1e-8) * G,\n      approx = [];\n  for (var i = 0; i <= n; i++)\n      approx.push(z(i / n) * m);\n\n  function Y(sinphi) {\n    var rmin = 0, rmax = n, r = n >> 1;\n    do {\n      if (approx[r] > sinphi) rmax = r; else rmin = r;\n      r = (rmin + rmax) >> 1;\n    } while (r > rmin);\n    var u = approx[r + 1] - approx[r];\n    if (u) u = (sinphi - approx[r + 1]) / u;\n    return (r + 1 + u) / n;\n  }\n\n  var ratio = 2 * Y(1) / pi * G / gamma;\n\n  var forward = function(lambda, phi) {\n    var y = Y(abs(sin(phi))),\n        x = elliptic(y) * lambda;\n    y /= ratio;\n    return [ x, (phi >= 0) ? y : -y ];\n  };\n\n  forward.invert = function(x, y) {\n    var phi;\n    y *= ratio;\n    if (abs(y) < 1) phi = sign(y) * asin(z(abs(y)) * G);\n    return [ x / elliptic(abs(y)), phi ];\n  };\n\n  return forward;\n}\n\nexport default function() {\n  var alpha = 0,\n      k = 2.5,\n      gamma = 1.183136, // affine = sqrt(2 * gamma / pi) = 0.8679\n      m = projectionMutator(hyperellipticalRaw),\n      p = m(alpha, k, gamma);\n\n  p.alpha = function(_) {\n    return arguments.length ? m(alpha = +_, k, gamma) : alpha;\n  };\n\n  p.k = function(_) {\n    return arguments.length ? m(alpha, k = +_, gamma) : k;\n  };\n\n  p.gamma = function(_) {\n    return arguments.length ? m(alpha, k, gamma = +_) : gamma;\n  };\n\n  return p\n      .scale(152.63);\n}\n"]},"metadata":{},"sourceType":"module"}