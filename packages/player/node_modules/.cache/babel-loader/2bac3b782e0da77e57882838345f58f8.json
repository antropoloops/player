{"ast":null,"code":"import _slicedToArray from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _defineProperty from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\n\nvar processBuffer = function processBuffer(proxy, renderedBuffer, nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime) {\n  var length, numberOfInputChannels, numberOfOutputChannels, processedBuffer, audioNodeConnections, audioWorkletProcessor, inputs, outputs, parameters, _loop, i, _ret;\n\n  return _regeneratorRuntime.async(function processBuffer$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          // Ceil the length to the next full render quantum.\n          // Bug #17: Safari does not yet expose the length.\n          length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n          numberOfInputChannels = options.channelCount * options.numberOfInputs;\n          numberOfOutputChannels = options.outputChannelCount.reduce(function (sum, value) {\n            return sum + value;\n          }, 0);\n          processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n\n          if (!(processorConstructor === undefined)) {\n            _context.next = 6;\n            break;\n          }\n\n          throw new Error('Missing the processor constructor.');\n\n        case 6:\n          audioNodeConnections = getAudioNodeConnections(proxy);\n          _context.next = 9;\n          return _regeneratorRuntime.awrap(getAudioWorkletProcessor(nativeOfflineAudioContext, proxy));\n\n        case 9:\n          audioWorkletProcessor = _context.sent;\n          inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n          outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n          parameters = Array.from(proxy.parameters.keys()).reduce(function (prmtrs, name) {\n            return _objectSpread({}, prmtrs, _defineProperty({}, name, new Float32Array(128)));\n          }, {});\n\n          _loop = function _loop(i) {\n            if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n              for (var j = 0; j < options.numberOfInputs; j += 1) {\n                for (var k = 0; k < options.channelCount; k += 1) {\n                  copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n              }\n            }\n\n            if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n              processorConstructor.parameterDescriptors.forEach(function (_ref, index) {\n                var name = _ref.name;\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n              });\n            }\n\n            for (var _j = 0; _j < options.numberOfInputs; _j += 1) {\n              for (var _k = 0; _k < options.outputChannelCount[_j]; _k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[_j][_k].byteLength === 0) {\n                  outputs[_j][_k] = new Float32Array(128);\n                }\n              }\n            }\n\n            try {\n              var potentiallyEmptyInputs = inputs.map(function (input, index) {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                  return [new Float32Array(0)];\n                }\n\n                return input;\n              });\n              var activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, function () {\n                return audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters);\n              });\n\n              if (processedBuffer !== null) {\n                for (var _j2 = 0, outputChannelSplitterNodeOutput = 0; _j2 < options.numberOfOutputs; _j2 += 1) {\n                  for (var _k2 = 0; _k2 < options.outputChannelCount[_j2]; _k2 += 1) {\n                    copyToChannel(processedBuffer, outputs[_j2], _k2, outputChannelSplitterNodeOutput + _k2, i);\n                  }\n\n                  outputChannelSplitterNodeOutput += options.outputChannelCount[_j2];\n                }\n              }\n\n              if (!activeSourceFlag) {\n                return \"break\";\n              }\n            } catch (error) {\n              proxy.dispatchEvent(new ErrorEvent('processorerror', {\n                error: error\n              }));\n              return \"break\";\n            }\n          };\n\n          i = 0;\n\n        case 15:\n          if (!(i < length)) {\n            _context.next = 22;\n            break;\n          }\n\n          _ret = _loop(i);\n\n          if (!(_ret === \"break\")) {\n            _context.next = 19;\n            break;\n          }\n\n          return _context.abrupt(\"break\", 22);\n\n        case 19:\n          i += 128;\n          _context.next = 15;\n          break;\n\n        case 22:\n          return _context.abrupt(\"return\", processedBuffer);\n\n        case 23:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  });\n};\n\nexport var createAudioWorkletNodeRendererFactory = function createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) {\n  return function (name, options, processorConstructor) {\n    var renderedNativeAudioNodes = new WeakMap();\n    var processedBufferPromise = null;\n\n    var createAudioNode = function createAudioNode(proxy, nativeOfflineAudioContext, trace) {\n      var nativeAudioWorkletNode, nativeOutputNodes, nativeAudioWorkletNodeIsOwnedByContext, numberOfOutputChannels, outputChannelSplitterNode, outputChannelMergerNodes, i, outputAudioNodes, outputGainNode, _numberOfInputChannels, numberOfParameters, numberOfChannels, renderBuffer, _processedBuffer, audioBufferSourceNode, _nativeOutputNodes, _nativeOutputNodes2, _outputChannelSplitterNode, _outputChannelMergerNodes, _outputGainNode, _i3, outputChannelSplitterNodeOutput, outputChannelMergerNode, j, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _ref7, _ref6, nm, audioParam, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _ref10, _ref9, _nm, _audioParam;\n\n      return _regeneratorRuntime.async(function createAudioNode$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              nativeAudioWorkletNode = getNativeAudioNode(proxy);\n              nativeOutputNodes = null;\n              nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext); // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n\n              if (nativeAudioWorkletNodeConstructor === null) {\n                numberOfOutputChannels = options.outputChannelCount.reduce(function (sum, value) {\n                  return sum + value;\n                }, 0);\n                outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                  channelCount: Math.max(1, numberOfOutputChannels),\n                  channelCountMode: 'explicit',\n                  channelInterpretation: 'discrete',\n                  numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                outputChannelMergerNodes = [];\n\n                for (i = 0; i < proxy.numberOfOutputs; i += 1) {\n                  outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'speakers',\n                    numberOfInputs: options.outputChannelCount[i]\n                  }));\n                } // Bug #87: Expose at least one output to make this node connectable.\n\n\n                outputAudioNodes = options.numberOfOutputs === 0 ? [outputChannelSplitterNode] : outputChannelMergerNodes;\n                outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                  channelCount: options.channelCount,\n                  channelCountMode: options.channelCountMode,\n                  channelInterpretation: options.channelInterpretation,\n                  gain: 1\n                });\n                outputGainNode.connect = connectMultipleOutputs.bind(null, outputAudioNodes);\n                outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputAudioNodes);\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n              } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n              }\n\n              renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n\n              if (!(nativeOutputNodes !== null)) {\n                _context4.next = 39;\n                break;\n              }\n\n              if (!(processedBufferPromise === null)) {\n                _context4.next = 30;\n                break;\n              }\n\n              if (!(processorConstructor === undefined)) {\n                _context4.next = 9;\n                break;\n              }\n\n              throw new Error('Missing the processor constructor.');\n\n            case 9:\n              if (!(nativeOfflineAudioContextConstructor === null)) {\n                _context4.next = 11;\n                break;\n              }\n\n              throw new Error('Missing the native OfflineAudioContext constructor.');\n\n            case 11:\n              // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n              _numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n              numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n              numberOfChannels = _numberOfInputChannels + numberOfParameters;\n\n              renderBuffer = function renderBuffer() {\n                var partialOfflineAudioContext, gainNodes, inputChannelSplitterNodes, _i, constantSourceNodes, inputChannelMergerNode, _i2, j, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _ref4, _ref3, index, constantSourceNode;\n\n                return _regeneratorRuntime.async(function renderBuffer$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, // Ceil the length to the next full render quantum.\n                        // Bug #17: Safari does not yet expose the length.\n                        Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                        gainNodes = [];\n                        inputChannelSplitterNodes = [];\n\n                        for (_i = 0; _i < options.numberOfInputs; _i += 1) {\n                          gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                            channelCount: options.channelCount,\n                            channelCountMode: options.channelCountMode,\n                            channelInterpretation: options.channelInterpretation,\n                            gain: 1\n                          }));\n                          inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                            channelCount: options.channelCount,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'discrete',\n                            numberOfOutputs: options.channelCount\n                          }));\n                        }\n\n                        _context3.next = 6;\n                        return _regeneratorRuntime.awrap(Promise.all(Array.from(proxy.parameters.values()).map(function _callee(audioParam) {\n                          var constantSourceNode;\n                          return _regeneratorRuntime.async(function _callee$(_context2) {\n                            while (1) {\n                              switch (_context2.prev = _context2.next) {\n                                case 0:\n                                  constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                    channelCount: 1,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    offset: audioParam.value\n                                  });\n                                  _context2.next = 3;\n                                  return _regeneratorRuntime.awrap(renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace));\n\n                                case 3:\n                                  return _context2.abrupt(\"return\", constantSourceNode);\n\n                                case 4:\n                                case \"end\":\n                                  return _context2.stop();\n                              }\n                            }\n                          });\n                        })));\n\n                      case 6:\n                        constantSourceNodes = _context3.sent;\n                        inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                          channelCount: 1,\n                          channelCountMode: 'explicit',\n                          channelInterpretation: 'speakers',\n                          numberOfInputs: Math.max(1, _numberOfInputChannels + numberOfParameters)\n                        });\n\n                        for (_i2 = 0; _i2 < options.numberOfInputs; _i2 += 1) {\n                          gainNodes[_i2].connect(inputChannelSplitterNodes[_i2]);\n\n                          for (j = 0; j < options.channelCount; j += 1) {\n                            inputChannelSplitterNodes[_i2].connect(inputChannelMergerNode, j, _i2 * options.channelCount + j);\n                          }\n                        }\n\n                        _iteratorNormalCompletion = true;\n                        _didIteratorError = false;\n                        _iteratorError = undefined;\n                        _context3.prev = 12;\n\n                        for (_iterator = constantSourceNodes.entries()[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                          _ref4 = _step.value;\n                          _ref3 = _slicedToArray(_ref4, 2);\n                          index = _ref3[0];\n                          constantSourceNode = _ref3[1];\n                          constantSourceNode.connect(inputChannelMergerNode, 0, _numberOfInputChannels + index);\n                          constantSourceNode.start(0);\n                        }\n\n                        _context3.next = 20;\n                        break;\n\n                      case 16:\n                        _context3.prev = 16;\n                        _context3.t0 = _context3[\"catch\"](12);\n                        _didIteratorError = true;\n                        _iteratorError = _context3.t0;\n\n                      case 20:\n                        _context3.prev = 20;\n                        _context3.prev = 21;\n\n                        if (!_iteratorNormalCompletion && _iterator.return != null) {\n                          _iterator.return();\n                        }\n\n                      case 23:\n                        _context3.prev = 23;\n\n                        if (!_didIteratorError) {\n                          _context3.next = 26;\n                          break;\n                        }\n\n                        throw _iteratorError;\n\n                      case 26:\n                        return _context3.finish(23);\n\n                      case 27:\n                        return _context3.finish(20);\n\n                      case 28:\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                        _context3.next = 31;\n                        return _regeneratorRuntime.awrap(Promise.all(gainNodes.map(function (gainNode) {\n                          return renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace);\n                        })));\n\n                      case 31:\n                        return _context3.abrupt(\"return\", renderNativeOfflineAudioContext(partialOfflineAudioContext));\n\n                      case 32:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }\n                }, null, null, [[12, 16, 20, 28], [21,, 23, 27]]);\n              };\n\n              _context4.t0 = processBuffer;\n              _context4.t1 = proxy;\n\n              if (!(numberOfChannels === 0)) {\n                _context4.next = 21;\n                break;\n              }\n\n              _context4.t2 = null;\n              _context4.next = 24;\n              break;\n\n            case 21:\n              _context4.next = 23;\n              return _regeneratorRuntime.awrap(renderBuffer());\n\n            case 23:\n              _context4.t2 = _context4.sent;\n\n            case 24:\n              _context4.t3 = _context4.t2;\n              _context4.t4 = nativeOfflineAudioContext;\n              _context4.t5 = options;\n              _context4.t6 = processorConstructor;\n              _context4.t7 = exposeCurrentFrameAndCurrentTime;\n              processedBufferPromise = (0, _context4.t0)(_context4.t1, _context4.t3, _context4.t4, _context4.t5, _context4.t6, _context4.t7);\n\n            case 30:\n              _context4.next = 32;\n              return _regeneratorRuntime.awrap(processedBufferPromise);\n\n            case 32:\n              _processedBuffer = _context4.sent;\n              audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);\n              _nativeOutputNodes = nativeOutputNodes, _nativeOutputNodes2 = _slicedToArray(_nativeOutputNodes, 3), _outputChannelSplitterNode = _nativeOutputNodes2[0], _outputChannelMergerNodes = _nativeOutputNodes2[1], _outputGainNode = _nativeOutputNodes2[2];\n\n              if (_processedBuffer !== null) {\n                audioBufferSourceNode.buffer = _processedBuffer;\n                audioBufferSourceNode.start(0);\n              }\n\n              audioBufferSourceNode.connect(_outputChannelSplitterNode);\n\n              for (_i3 = 0, outputChannelSplitterNodeOutput = 0; _i3 < proxy.numberOfOutputs; _i3 += 1) {\n                outputChannelMergerNode = _outputChannelMergerNodes[_i3];\n\n                for (j = 0; j < options.outputChannelCount[_i3]; j += 1) {\n                  _outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                }\n\n                outputChannelSplitterNodeOutput += options.outputChannelCount[_i3];\n              }\n\n              return _context4.abrupt(\"return\", _outputGainNode);\n\n            case 39:\n              if (nativeAudioWorkletNodeIsOwnedByContext) {\n                _context4.next = 71;\n                break;\n              }\n\n              _iteratorNormalCompletion2 = true;\n              _didIteratorError2 = false;\n              _iteratorError2 = undefined;\n              _context4.prev = 43;\n              _iterator2 = proxy.parameters.entries()[Symbol.iterator]();\n\n            case 45:\n              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n                _context4.next = 55;\n                break;\n              }\n\n              _ref7 = _step2.value;\n              _ref6 = _slicedToArray(_ref7, 2);\n              nm = _ref6[0];\n              audioParam = _ref6[1];\n              _context4.next = 52;\n              return _regeneratorRuntime.awrap(renderAutomation(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n              nativeAudioWorkletNode.parameters.get(nm), trace));\n\n            case 52:\n              _iteratorNormalCompletion2 = true;\n              _context4.next = 45;\n              break;\n\n            case 55:\n              _context4.next = 61;\n              break;\n\n            case 57:\n              _context4.prev = 57;\n              _context4.t8 = _context4[\"catch\"](43);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context4.t8;\n\n            case 61:\n              _context4.prev = 61;\n              _context4.prev = 62;\n\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n\n            case 64:\n              _context4.prev = 64;\n\n              if (!_didIteratorError2) {\n                _context4.next = 67;\n                break;\n              }\n\n              throw _iteratorError2;\n\n            case 67:\n              return _context4.finish(64);\n\n            case 68:\n              return _context4.finish(61);\n\n            case 69:\n              _context4.next = 100;\n              break;\n\n            case 71:\n              _iteratorNormalCompletion3 = true;\n              _didIteratorError3 = false;\n              _iteratorError3 = undefined;\n              _context4.prev = 74;\n              _iterator3 = proxy.parameters.entries()[Symbol.iterator]();\n\n            case 76:\n              if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {\n                _context4.next = 86;\n                break;\n              }\n\n              _ref10 = _step3.value;\n              _ref9 = _slicedToArray(_ref10, 2);\n              _nm = _ref9[0];\n              _audioParam = _ref9[1];\n              _context4.next = 83;\n              return _regeneratorRuntime.awrap(connectAudioParam(nativeOfflineAudioContext, _audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n              nativeAudioWorkletNode.parameters.get(_nm), trace));\n\n            case 83:\n              _iteratorNormalCompletion3 = true;\n              _context4.next = 76;\n              break;\n\n            case 86:\n              _context4.next = 92;\n              break;\n\n            case 88:\n              _context4.prev = 88;\n              _context4.t9 = _context4[\"catch\"](74);\n              _didIteratorError3 = true;\n              _iteratorError3 = _context4.t9;\n\n            case 92:\n              _context4.prev = 92;\n              _context4.prev = 93;\n\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n\n            case 95:\n              _context4.prev = 95;\n\n              if (!_didIteratorError3) {\n                _context4.next = 98;\n                break;\n              }\n\n              throw _iteratorError3;\n\n            case 98:\n              return _context4.finish(95);\n\n            case 99:\n              return _context4.finish(92);\n\n            case 100:\n              _context4.next = 102;\n              return _regeneratorRuntime.awrap(renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace));\n\n            case 102:\n              return _context4.abrupt(\"return\", nativeAudioWorkletNode);\n\n            case 103:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, null, [[43, 57, 61, 69], [62,, 64, 68], [74, 88, 92, 100], [93,, 95, 99]]);\n    };\n\n    return {\n      render: function render(proxy, nativeOfflineAudioContext, trace) {\n        var renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n    };\n  };\n};","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/standardized-audio-context/build/es2018/factories/audio-worklet-node-renderer-factory.js"],"names":["copyFromChannel","copyToChannel","createNestedArrays","getAudioNodeConnections","getAudioWorkletProcessor","isOwnedByContext","processBuffer","proxy","renderedBuffer","nativeOfflineAudioContext","options","processorConstructor","exposeCurrentFrameAndCurrentTime","length","Math","ceil","context","numberOfInputChannels","channelCount","numberOfInputs","numberOfOutputChannels","outputChannelCount","reduce","sum","value","processedBuffer","createBuffer","sampleRate","undefined","Error","audioNodeConnections","audioWorkletProcessor","inputs","outputs","numberOfOutputs","parameters","Array","from","keys","prmtrs","name","Float32Array","i","j","k","parameterDescriptors","forEach","index","byteLength","potentiallyEmptyInputs","map","input","activeInputs","size","activeSourceFlag","process","outputChannelSplitterNodeOutput","error","dispatchEvent","ErrorEvent","createAudioWorkletNodeRendererFactory","connectAudioParam","connectMultipleOutputs","createNativeAudioBufferSourceNode","createNativeChannelMergerNode","createNativeChannelSplitterNode","createNativeConstantSourceNode","createNativeGainNode","disconnectMultipleOutputs","getNativeAudioNode","nativeAudioWorkletNodeConstructor","nativeOfflineAudioContextConstructor","renderAutomation","renderInputsOfAudioNode","renderNativeOfflineAudioContext","renderedNativeAudioNodes","WeakMap","processedBufferPromise","createAudioNode","trace","nativeAudioWorkletNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","outputChannelSplitterNode","max","channelCountMode","channelInterpretation","outputChannelMergerNodes","push","outputAudioNodes","outputGainNode","gain","connect","bind","disconnect","set","numberOfParameters","numberOfChannels","renderBuffer","partialOfflineAudioContext","gainNodes","inputChannelSplitterNodes","Promise","all","values","audioParam","constantSourceNode","offset","constantSourceNodes","inputChannelMergerNode","entries","start","destination","gainNode","audioBufferSourceNode","buffer","outputChannelMergerNode","nm","get","render","renderedNativeAudioWorkletNodeOrGainNode","resolve"],"mappings":"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","sourcesContent":["import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = (renderedBuffer === null) ? (Math.ceil(proxy.context.length / 128) * 128) : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer = (numberOfOutputChannels === 0) ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n    const parameters = Array\n        .from(proxy.parameters.keys())\n        .reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n        try {\n            const potentiallyEmptyInputs = inputs\n                .map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [new Float32Array(0)];\n                }\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n                }\n            }\n            if (!activeSourceFlag) {\n                break;\n            }\n        }\n        catch (error) {\n            proxy.dispatchEvent(new ErrorEvent('processorerror', { error }));\n            break;\n        }\n    }\n    return processedBuffer;\n};\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (name, options, processorConstructor) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let processedBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n            let nativeOutputNodes = null;\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes = [];\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: options.outputChannelCount[i]\n                    }));\n                }\n                // Bug #87: Expose at least one output to make this node connectable.\n                const outputAudioNodes = (options.numberOfOutputs === 0) ?\n                    [outputChannelSplitterNode] :\n                    outputChannelMergerNodes;\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n                outputGainNode.connect = connectMultipleOutputs.bind(null, outputAudioNodes);\n                outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputAudioNodes);\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            }\n            else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, (nativeOutputNodes === null) ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters = (processorConstructor.parameterDescriptors === undefined)\n                        ? 0\n                        : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, \n                        // Ceil the length to the next full render quantum.\n                        // Bug #17: Safari does not yet expose the length.\n                        Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                        const gainNodes = [];\n                        const inputChannelSplitterNodes = [];\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: options.channelCountMode,\n                                channelInterpretation: options.channelInterpretation,\n                                gain: 1\n                            }));\n                            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                numberOfOutputs: options.channelCount\n                            }));\n                        }\n                        const constantSourceNodes = await Promise\n                            .all(Array\n                            .from(proxy.parameters.values())\n                            .map(async (audioParam) => {\n                            const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                channelCount: 1,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                offset: audioParam.value\n                            });\n                            await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace);\n                            return constantSourceNode;\n                        }));\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, (i * options.channelCount) + j);\n                            }\n                        }\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                        await Promise\n                            .all(gainNodes\n                            .map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace)));\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n                    processedBufferPromise = processBuffer(proxy, (numberOfChannels === 0) ? null : await renderBuffer(), nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime);\n                }\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n                }\n                return outputGainNode;\n            }\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace);\n            return nativeAudioWorkletNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-worklet-node-renderer-factory.js.map"]},"metadata":{},"sourceType":"module"}