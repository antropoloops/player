{"ast":null,"code":"/**\n * SOURCE: https://github.com/swevans/unmute\n * SEE: https://stackoverflow.com/questions/21122418/ios-webaudio-only-works-on-headphones\n */\n\n/**\n * @file unmute.ts\n * @author Spencer Evans evans.spencer@gmail.com\n * unmute is a disgusting hack that helps..\n * \t1) automatically resume web audio contexts on user interaction\n * \t2) ios only: web audio play on the media channel rather than the ringer channel\n * \t3) ios only: disable the media playback widget and airplay.\n * \t4) automatically pause and resume web audio when the page is hidden.\n * Auto resuming works by checking context state and calling resume during any resumable event.\n * Media channel playback and media widget disabling work by playing an airplay-disabled silent html audio track in the background.\n * Automatic pausing when the page is hidden is supported by both the page visibility api AND blur events because ios has a poor implementation of the page visibility api.\n * This is all really gross and apple should really fix their janky browser.\n * This code isn't optimized in any fashion, it is just whipped up to help someone out on stack overflow, its just meant as an example.\n */\n\n/**\n * Enables unmute.\n * @param context A reference to the web audio context to \"unmute\".\n */\nexport default function unmute(context) {\n  var pageVisibilityAPI;\n  if (document.hidden !== undefined) pageVisibilityAPI = {\n    hidden: \"hidden\",\n    visibilitychange: \"visibilitychange\"\n  };else if (document.webkitHidden !== undefined) pageVisibilityAPI = {\n    hidden: \"webkitHidden\",\n    visibilitychange: \"webkitvisibilitychange\"\n  };else if (document.mozHidden !== undefined) pageVisibilityAPI = {\n    hidden: \"mozHidden\",\n    visibilitychange: \"mozvisibilitychange\"\n  };else if (document.msHidden !== undefined) pageVisibilityAPI = {\n    hidden: \"msHidden\",\n    visibilitychange: \"msvisibilitychange\"\n  }; // Determine if ios\n\n  var ua = navigator.userAgent.toLowerCase();\n  var isIOS = ua.indexOf(\"iphone\") >= 0 && ua.indexOf(\"like iphone\") < 0 || ua.indexOf(\"ipad\") >= 0 && ua.indexOf(\"like ipad\") < 0 || ua.indexOf(\"ipod\") >= 0 && ua.indexOf(\"like ipod\") < 0; // Track page state\n\n  var isPageActive = true;\n  var isPageVisible = true;\n  var iosIsPageFocused = true; // iOS has a buggy page visibility API, luckily it dispatches blur and focus events on the window when vis change events should fire.\n  // Track desired audio state\n\n  var suspendAudio = false;\n  var audioUnlockingEvents = [\"click\", \"contextmenu\", \"auxclick\", \"dblclick\", \"mousedown\", \"mouseup\", \"touchend\", \"keydown\", \"keyup\"]; // Track web audio state\n\n  var contextUnlockingEnabled = false; // Track html audio state\n\n  var tag;\n  var tagUnlockingEnabled = false;\n  var tagPendingChange = false;\n\n  function contextStateCheck(tryResuming) {\n    if (context.state === \"running\") {\n      // No need to watch for unlocking events while running\n      toggleContextUnlocking(false); // Check if our state matches\n\n      if (suspendAudio) {\n        // We want to be suspended, we can suspend at any time\n        context.suspend().then(context_promiseHandler, context_promiseHandler);\n      }\n    } else if (context.state !== \"closed\") {\n      // Interrupted or suspended, check if our state matches\n      if (!suspendAudio) {\n        // We want to be running\n        toggleContextUnlocking(true);\n        if (tryResuming) context.resume().then(context_promiseHandler, context_promiseHandler);\n      } else {\n        // We don't want to be running, so no need to watch for unlocking events\n        toggleContextUnlocking(false);\n      }\n    }\n  }\n\n  function toggleContextUnlocking(enable) {\n    if (contextUnlockingEnabled === enable) return;\n    contextUnlockingEnabled = enable;\n\n    for (var _i = 0, audioUnlockingEvents_1 = audioUnlockingEvents; _i < audioUnlockingEvents_1.length; _i++) {\n      var evt = audioUnlockingEvents_1[_i];\n      if (enable) window.addEventListener(evt, context_unlockingEvent, {\n        capture: true,\n        passive: true\n      });else window.removeEventListener(evt, context_unlockingEvent, {\n        capture: true,\n        passive: true\n      });\n    }\n  }\n\n  function context_statechange() {\n    contextStateCheck(true);\n  }\n\n  function context_promiseHandler() {\n    contextStateCheck(false);\n  }\n\n  function context_unlockingEvent() {\n    contextStateCheck(true);\n  }\n\n  function tagStateCheck(tryChange) {\n    // We have a pending state change, let that resolve first\n    if (tagPendingChange) return;\n\n    if (!tag.paused) {\n      // No need to watch for unlocking events while running\n      toggleTagUnlocking(false); // Check if our state matches\n\n      if (suspendAudio) {\n        // We want to be suspended, we can suspend at any time\n        tag.pause(); // instant action, so no need to set as pending\n      }\n    } else {\n      // Tag isn't playing, check if our state matches\n      if (!suspendAudio) {\n        // We want to be running\n        if (tryChange) {\n          // Try forcing a change, so stop watching for unlocking events while attempt is in progress\n          toggleTagUnlocking(false); // Attempt to play\n\n          tagPendingChange = true;\n          var p = void 0;\n\n          try {\n            p = tag.play();\n            if (p) p.then(tag_promiseHandler, tag_promiseHandler);else {\n              tag.addEventListener(\"playing\", tag_promiseHandler);\n              tag.addEventListener(\"abort\", tag_promiseHandler);\n              tag.addEventListener(\"error\", tag_promiseHandler);\n            }\n          } catch (err) {\n            tag_promiseHandler();\n          }\n        } else {\n          // We're not going to try resuming this time, but make sure unlocking events are enabled\n          toggleTagUnlocking(true);\n        }\n      } else {\n        // We don't want to be running, so no need to watch for unlocking events\n        toggleTagUnlocking(false);\n      }\n    }\n  }\n\n  function toggleTagUnlocking(enable) {\n    if (tagUnlockingEnabled === enable) return;\n    tagUnlockingEnabled = enable;\n\n    for (var _i = 0, audioUnlockingEvents_2 = audioUnlockingEvents; _i < audioUnlockingEvents_2.length; _i++) {\n      var evt = audioUnlockingEvents_2[_i];\n      if (enable) window.addEventListener(evt, tag_unlockingEvent, {\n        capture: true,\n        passive: true\n      });else window.removeEventListener(evt, tag_unlockingEvent, {\n        capture: true,\n        passive: true\n      });\n    }\n  }\n\n  function tag_promiseHandler() {\n    tag.removeEventListener(\"playing\", tag_promiseHandler);\n    tag.removeEventListener(\"abort\", tag_promiseHandler);\n    tag.removeEventListener(\"error\", tag_promiseHandler); // Tag started playing, so we're not suspended\n\n    tagPendingChange = false;\n    tagStateCheck(false);\n  }\n\n  function tag_unlockingEvent() {\n    tagStateCheck(true);\n  }\n  /**\n   * Called when the page becomes active.\n   */\n\n\n  function pageActivated() {\n    suspendAudio = false;\n    if (tag) tagStateCheck(true); // tag first to ensure media channel start first\n\n    contextStateCheck(true);\n  }\n  /**\n   * Called when the page becomes inactive.\n   */\n\n\n  function pageDeactivated() {\n    suspendAudio = true;\n    contextStateCheck(true); // context first to be sure it stops before the tag\n\n    if (tag) tagStateCheck(true);\n  }\n  /**\n   * Updates page active state.\n   */\n\n\n  function pageStateCheck() {\n    if (isPageVisible && iosIsPageFocused) {\n      if (!isPageActive) {\n        isPageActive = true;\n        pageActivated();\n      }\n    } else {\n      if (isPageActive) {\n        isPageActive = false;\n        pageDeactivated();\n      }\n    }\n  }\n  /**\n   * Handle visibility api events.\n   */\n\n\n  function doc_visChange() {\n    if (pageVisibilityAPI) {\n      if (document[pageVisibilityAPI.hidden] === isPageActive) {\n        isPageVisible = !document[pageVisibilityAPI.hidden];\n        pageStateCheck();\n      }\n    }\n  }\n  /**\n   * Handles blur events (ios only).\n   */\n\n\n  function win_focusChange(evt) {\n    if (evt && evt.target !== window) return;\n\n    if (document.hasFocus()) {\n      if (iosIsPageFocused) return;\n      iosIsPageFocused = true;\n      pageStateCheck();\n    } else {\n      if (!iosIsPageFocused) return;\n      iosIsPageFocused = false;\n      pageStateCheck();\n    }\n  }\n  /**\n   * A utility function for decompressing the base64 silence string.\n   * @param c The number of times the string is repeated in the string segment.\n   * @param a The string to repeat.\n   */\n\n\n  function poorManHuffman(c, a) {\n    var e;\n\n    for (e = a; c > 1; c--) e += a;\n\n    return e;\n  } // Watch for tag state changes and check initial state\n\n\n  if (isIOS) {\n    // Is ios, we need to play an html track in the background and disable the widget\n    // NOTE: media widget / airplay MUST be disabled with this super gross hack to create the audio tag, setting the attribute in js doesn't work\n    var tmp = document.createElement(\"div\");\n    tmp.innerHTML = \"<audio x-webkit-airplay='deny'></audio>\";\n    tag = tmp.children.item(0);\n    tag.controls = false;\n    tag.disableRemotePlayback = true; // Airplay like controls on other devices, prevents casting of the tag\n\n    tag.preload = \"auto\"; // Set the src to a short bit of url encoded as a silent mp3\n    // NOTE The silence MP3 must be high quality, when web audio sounds are played in parallel the web audio sound is mixed to match the bitrate of the html sound\n    // 0.01 seconds of silence VBR220-260 Joint Stereo 859B\n    //tag.src = \"data:audio/mpeg;base64,//uQxAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA//////////////////////////////////////////////////////////////////8AAABhTEFNRTMuMTAwA8MAAAAAAAAAABQgJAUHQQAB9AAAAnGMHkkIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//sQxAADgnABGiAAQBCqgCRMAAgEAH///////////////7+n/9FTuQsQH//////2NG0jWUGlio5gLQTOtIoeR2WX////X4s9Atb/JRVCbBUpeRUq//////////////////9RUi0f2jn/+xDECgPCjAEQAABN4AAANIAAAAQVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ==\";\n    // The str below is a \"compressed\" version using poor mans huffman encoding, saves about 0.5kb\n\n    tag.src = \"data:audio/mpeg;base64,//uQx\" + poorManHuffman(23, \"A\") + \"WGluZwAAAA8AAAACAAACcQCA\" + poorManHuffman(16, \"gICA\") + poorManHuffman(66, \"/\") + \"8AAABhTEFNRTMuMTAwA8MAAAAAAAAAABQgJAUHQQAB9AAAAnGMHkkI\" + poorManHuffman(320, \"A\") + \"//sQxAADgnABGiAAQBCqgCRMAAgEAH\" + poorManHuffman(15, \"/\") + \"7+n/9FTuQsQH//////2NG0jWUGlio5gLQTOtIoeR2WX////X4s9Atb/JRVCbBUpeRUq\" + poorManHuffman(18, \"/\") + \"9RUi0f2jn/+xDECgPCjAEQAABN4AAANIAAAAQVTEFNRTMuMTAw\" + poorManHuffman(97, \"V\") + \"Q==\";\n    tag.loop = true;\n    tag.load(); // Try to play right off the bat\n\n    tagStateCheck(true);\n  } // Watch for context state changes and check initial state\n\n\n  context.onstatechange = context_statechange; // NOTE: the onstatechange callback property is more widely supported than the statechange event\tcontext.addEventListener(\"statechange\", context_statechange);\n\n  contextStateCheck(false); // Watch for page state changes and check initial page state\n\n  if (pageVisibilityAPI) document.addEventListener(pageVisibilityAPI.visibilitychange, doc_visChange, true);\n\n  if (isIOS) {\n    // Watch for blur / focus events on ios because it doesn't dispatch vis change events properly\n    window.addEventListener(\"focus\", win_focusChange, true);\n    window.addEventListener(\"blur\", win_focusChange, true);\n  }\n\n  doc_visChange();\n  win_focusChange();\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/packages/player/src/active-audio-context/unmute.js"],"names":["unmute","context","pageVisibilityAPI","document","hidden","undefined","visibilitychange","webkitHidden","mozHidden","msHidden","ua","navigator","userAgent","toLowerCase","isIOS","indexOf","isPageActive","isPageVisible","iosIsPageFocused","suspendAudio","audioUnlockingEvents","contextUnlockingEnabled","tag","tagUnlockingEnabled","tagPendingChange","contextStateCheck","tryResuming","state","toggleContextUnlocking","suspend","then","context_promiseHandler","resume","enable","_i","audioUnlockingEvents_1","length","evt","window","addEventListener","context_unlockingEvent","capture","passive","removeEventListener","context_statechange","tagStateCheck","tryChange","paused","toggleTagUnlocking","pause","p","play","tag_promiseHandler","err","audioUnlockingEvents_2","tag_unlockingEvent","pageActivated","pageDeactivated","pageStateCheck","doc_visChange","win_focusChange","target","hasFocus","poorManHuffman","c","a","e","tmp","createElement","innerHTML","children","item","controls","disableRemotePlayback","preload","src","loop","load","onstatechange"],"mappings":"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","sourcesContent":["/**\n * SOURCE: https://github.com/swevans/unmute\n * SEE: https://stackoverflow.com/questions/21122418/ios-webaudio-only-works-on-headphones\n */\n\n/**\n * @file unmute.ts\n * @author Spencer Evans evans.spencer@gmail.com\n * unmute is a disgusting hack that helps..\n * \t1) automatically resume web audio contexts on user interaction\n * \t2) ios only: web audio play on the media channel rather than the ringer channel\n * \t3) ios only: disable the media playback widget and airplay.\n * \t4) automatically pause and resume web audio when the page is hidden.\n * Auto resuming works by checking context state and calling resume during any resumable event.\n * Media channel playback and media widget disabling work by playing an airplay-disabled silent html audio track in the background.\n * Automatic pausing when the page is hidden is supported by both the page visibility api AND blur events because ios has a poor implementation of the page visibility api.\n * This is all really gross and apple should really fix their janky browser.\n * This code isn't optimized in any fashion, it is just whipped up to help someone out on stack overflow, its just meant as an example.\n */\n/**\n * Enables unmute.\n * @param context A reference to the web audio context to \"unmute\".\n */\nexport default function unmute(context) {\n  var pageVisibilityAPI;\n  if (document.hidden !== undefined)\n    pageVisibilityAPI = {\n      hidden: \"hidden\",\n      visibilitychange: \"visibilitychange\",\n    };\n  else if (document.webkitHidden !== undefined)\n    pageVisibilityAPI = {\n      hidden: \"webkitHidden\",\n      visibilitychange: \"webkitvisibilitychange\",\n    };\n  else if (document.mozHidden !== undefined)\n    pageVisibilityAPI = {\n      hidden: \"mozHidden\",\n      visibilitychange: \"mozvisibilitychange\",\n    };\n  else if (document.msHidden !== undefined)\n    pageVisibilityAPI = {\n      hidden: \"msHidden\",\n      visibilitychange: \"msvisibilitychange\",\n    };\n  // Determine if ios\n  var ua = navigator.userAgent.toLowerCase();\n  var isIOS =\n    (ua.indexOf(\"iphone\") >= 0 && ua.indexOf(\"like iphone\") < 0) ||\n    (ua.indexOf(\"ipad\") >= 0 && ua.indexOf(\"like ipad\") < 0) ||\n    (ua.indexOf(\"ipod\") >= 0 && ua.indexOf(\"like ipod\") < 0);\n  // Track page state\n  var isPageActive = true;\n  var isPageVisible = true;\n  var iosIsPageFocused = true; // iOS has a buggy page visibility API, luckily it dispatches blur and focus events on the window when vis change events should fire.\n  // Track desired audio state\n  var suspendAudio = false;\n  var audioUnlockingEvents = [\n    \"click\",\n    \"contextmenu\",\n    \"auxclick\",\n    \"dblclick\",\n    \"mousedown\",\n    \"mouseup\",\n    \"touchend\",\n    \"keydown\",\n    \"keyup\",\n  ];\n  // Track web audio state\n  var contextUnlockingEnabled = false;\n  // Track html audio state\n  var tag;\n  var tagUnlockingEnabled = false;\n  var tagPendingChange = false;\n  function contextStateCheck(tryResuming) {\n    if (context.state === \"running\") {\n      // No need to watch for unlocking events while running\n      toggleContextUnlocking(false);\n      // Check if our state matches\n      if (suspendAudio) {\n        // We want to be suspended, we can suspend at any time\n        context.suspend().then(context_promiseHandler, context_promiseHandler);\n      }\n    } else if (context.state !== \"closed\") {\n      // Interrupted or suspended, check if our state matches\n      if (!suspendAudio) {\n        // We want to be running\n        toggleContextUnlocking(true);\n        if (tryResuming)\n          context.resume().then(context_promiseHandler, context_promiseHandler);\n      } else {\n        // We don't want to be running, so no need to watch for unlocking events\n        toggleContextUnlocking(false);\n      }\n    }\n  }\n  function toggleContextUnlocking(enable) {\n    if (contextUnlockingEnabled === enable) return;\n    contextUnlockingEnabled = enable;\n    for (\n      var _i = 0, audioUnlockingEvents_1 = audioUnlockingEvents;\n      _i < audioUnlockingEvents_1.length;\n      _i++\n    ) {\n      var evt = audioUnlockingEvents_1[_i];\n      if (enable)\n        window.addEventListener(evt, context_unlockingEvent, {\n          capture: true,\n          passive: true,\n        });\n      else\n        window.removeEventListener(evt, context_unlockingEvent, {\n          capture: true,\n          passive: true,\n        });\n    }\n  }\n  function context_statechange() {\n    contextStateCheck(true);\n  }\n  function context_promiseHandler() {\n    contextStateCheck(false);\n  }\n  function context_unlockingEvent() {\n    contextStateCheck(true);\n  }\n  function tagStateCheck(tryChange) {\n    // We have a pending state change, let that resolve first\n    if (tagPendingChange) return;\n    if (!tag.paused) {\n      // No need to watch for unlocking events while running\n      toggleTagUnlocking(false);\n      // Check if our state matches\n      if (suspendAudio) {\n        // We want to be suspended, we can suspend at any time\n        tag.pause(); // instant action, so no need to set as pending\n      }\n    } else {\n      // Tag isn't playing, check if our state matches\n      if (!suspendAudio) {\n        // We want to be running\n        if (tryChange) {\n          // Try forcing a change, so stop watching for unlocking events while attempt is in progress\n          toggleTagUnlocking(false);\n          // Attempt to play\n          tagPendingChange = true;\n          var p = void 0;\n          try {\n            p = tag.play();\n            if (p) p.then(tag_promiseHandler, tag_promiseHandler);\n            else {\n              tag.addEventListener(\"playing\", tag_promiseHandler);\n              tag.addEventListener(\"abort\", tag_promiseHandler);\n              tag.addEventListener(\"error\", tag_promiseHandler);\n            }\n          } catch (err) {\n            tag_promiseHandler();\n          }\n        } else {\n          // We're not going to try resuming this time, but make sure unlocking events are enabled\n          toggleTagUnlocking(true);\n        }\n      } else {\n        // We don't want to be running, so no need to watch for unlocking events\n        toggleTagUnlocking(false);\n      }\n    }\n  }\n  function toggleTagUnlocking(enable) {\n    if (tagUnlockingEnabled === enable) return;\n    tagUnlockingEnabled = enable;\n    for (\n      var _i = 0, audioUnlockingEvents_2 = audioUnlockingEvents;\n      _i < audioUnlockingEvents_2.length;\n      _i++\n    ) {\n      var evt = audioUnlockingEvents_2[_i];\n      if (enable)\n        window.addEventListener(evt, tag_unlockingEvent, {\n          capture: true,\n          passive: true,\n        });\n      else\n        window.removeEventListener(evt, tag_unlockingEvent, {\n          capture: true,\n          passive: true,\n        });\n    }\n  }\n  function tag_promiseHandler() {\n    tag.removeEventListener(\"playing\", tag_promiseHandler);\n    tag.removeEventListener(\"abort\", tag_promiseHandler);\n    tag.removeEventListener(\"error\", tag_promiseHandler);\n    // Tag started playing, so we're not suspended\n    tagPendingChange = false;\n    tagStateCheck(false);\n  }\n  function tag_unlockingEvent() {\n    tagStateCheck(true);\n  }\n  /**\n   * Called when the page becomes active.\n   */\n  function pageActivated() {\n    suspendAudio = false;\n    if (tag) tagStateCheck(true); // tag first to ensure media channel start first\n    contextStateCheck(true);\n  }\n  /**\n   * Called when the page becomes inactive.\n   */\n  function pageDeactivated() {\n    suspendAudio = true;\n    contextStateCheck(true); // context first to be sure it stops before the tag\n    if (tag) tagStateCheck(true);\n  }\n  /**\n   * Updates page active state.\n   */\n  function pageStateCheck() {\n    if (isPageVisible && iosIsPageFocused) {\n      if (!isPageActive) {\n        isPageActive = true;\n        pageActivated();\n      }\n    } else {\n      if (isPageActive) {\n        isPageActive = false;\n        pageDeactivated();\n      }\n    }\n  }\n  /**\n   * Handle visibility api events.\n   */\n  function doc_visChange() {\n    if (pageVisibilityAPI) {\n      if (document[pageVisibilityAPI.hidden] === isPageActive) {\n        isPageVisible = !document[pageVisibilityAPI.hidden];\n        pageStateCheck();\n      }\n    }\n  }\n  /**\n   * Handles blur events (ios only).\n   */\n  function win_focusChange(evt) {\n    if (evt && evt.target !== window) return;\n    if (document.hasFocus()) {\n      if (iosIsPageFocused) return;\n      iosIsPageFocused = true;\n      pageStateCheck();\n    } else {\n      if (!iosIsPageFocused) return;\n      iosIsPageFocused = false;\n      pageStateCheck();\n    }\n  }\n  /**\n   * A utility function for decompressing the base64 silence string.\n   * @param c The number of times the string is repeated in the string segment.\n   * @param a The string to repeat.\n   */\n  function poorManHuffman(c, a) {\n    var e;\n    for (e = a; c > 1; c--) e += a;\n    return e;\n  }\n  // Watch for tag state changes and check initial state\n  if (isIOS) {\n    // Is ios, we need to play an html track in the background and disable the widget\n    // NOTE: media widget / airplay MUST be disabled with this super gross hack to create the audio tag, setting the attribute in js doesn't work\n    var tmp = document.createElement(\"div\");\n    tmp.innerHTML = \"<audio x-webkit-airplay='deny'></audio>\";\n    tag = tmp.children.item(0);\n    tag.controls = false;\n    tag.disableRemotePlayback = true; // Airplay like controls on other devices, prevents casting of the tag\n    tag.preload = \"auto\";\n    // Set the src to a short bit of url encoded as a silent mp3\n    // NOTE The silence MP3 must be high quality, when web audio sounds are played in parallel the web audio sound is mixed to match the bitrate of the html sound\n    // 0.01 seconds of silence VBR220-260 Joint Stereo 859B\n    //tag.src = \"data:audio/mpeg;base64,//uQxAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA//////////////////////////////////////////////////////////////////8AAABhTEFNRTMuMTAwA8MAAAAAAAAAABQgJAUHQQAB9AAAAnGMHkkIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//sQxAADgnABGiAAQBCqgCRMAAgEAH///////////////7+n/9FTuQsQH//////2NG0jWUGlio5gLQTOtIoeR2WX////X4s9Atb/JRVCbBUpeRUq//////////////////9RUi0f2jn/+xDECgPCjAEQAABN4AAANIAAAAQVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ==\";\n    // The str below is a \"compressed\" version using poor mans huffman encoding, saves about 0.5kb\n    tag.src =\n      \"data:audio/mpeg;base64,//uQx\" +\n      poorManHuffman(23, \"A\") +\n      \"WGluZwAAAA8AAAACAAACcQCA\" +\n      poorManHuffman(16, \"gICA\") +\n      poorManHuffman(66, \"/\") +\n      \"8AAABhTEFNRTMuMTAwA8MAAAAAAAAAABQgJAUHQQAB9AAAAnGMHkkI\" +\n      poorManHuffman(320, \"A\") +\n      \"//sQxAADgnABGiAAQBCqgCRMAAgEAH\" +\n      poorManHuffman(15, \"/\") +\n      \"7+n/9FTuQsQH//////2NG0jWUGlio5gLQTOtIoeR2WX////X4s9Atb/JRVCbBUpeRUq\" +\n      poorManHuffman(18, \"/\") +\n      \"9RUi0f2jn/+xDECgPCjAEQAABN4AAANIAAAAQVTEFNRTMuMTAw\" +\n      poorManHuffman(97, \"V\") +\n      \"Q==\";\n    tag.loop = true;\n    tag.load();\n    // Try to play right off the bat\n    tagStateCheck(true);\n  }\n  // Watch for context state changes and check initial state\n  context.onstatechange = context_statechange; // NOTE: the onstatechange callback property is more widely supported than the statechange event\tcontext.addEventListener(\"statechange\", context_statechange);\n  contextStateCheck(false);\n  // Watch for page state changes and check initial page state\n  if (pageVisibilityAPI)\n    document.addEventListener(\n      pageVisibilityAPI.visibilitychange,\n      doc_visChange,\n      true\n    );\n  if (isIOS) {\n    // Watch for blur / focus events on ios because it doesn't dispatch vis change events properly\n    window.addEventListener(\"focus\", win_focusChange, true);\n    window.addEventListener(\"blur\", win_focusChange, true);\n  }\n  doc_visChange();\n  win_focusChange();\n}\n"]},"metadata":{},"sourceType":"module"}