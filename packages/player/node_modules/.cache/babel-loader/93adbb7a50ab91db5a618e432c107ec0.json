{"ast":null,"code":"import _slicedToArray from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _defineProperty from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _asyncToGenerator from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\n\nvar processBuffer = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, renderedBuffer, nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime) {\n    var length, numberOfInputChannels, numberOfOutputChannels, processedBuffer, audioNodeConnections, audioWorkletProcessor, inputs, outputs, parameters, _loop, i, _ret;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            // Ceil the length to the next full render quantum.\n            // Bug #17: Safari does not yet expose the length.\n            length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n            numberOfInputChannels = options.channelCount * options.numberOfInputs;\n            numberOfOutputChannels = options.outputChannelCount.reduce(function (sum, value) {\n              return sum + value;\n            }, 0);\n            processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n\n            if (!(processorConstructor === undefined)) {\n              _context.next = 6;\n              break;\n            }\n\n            throw new Error('Missing the processor constructor.');\n\n          case 6:\n            audioNodeConnections = getAudioNodeConnections(proxy);\n            _context.next = 9;\n            return getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n\n          case 9:\n            audioWorkletProcessor = _context.sent;\n            inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n            outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n            parameters = Array.from(proxy.parameters.keys()).reduce(function (prmtrs, name) {\n              return _objectSpread(_objectSpread({}, prmtrs), {}, _defineProperty({}, name, new Float32Array(128)));\n            }, {});\n\n            _loop = function _loop(i) {\n              if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n                for (var j = 0; j < options.numberOfInputs; j += 1) {\n                  for (var k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                  }\n                }\n              }\n\n              if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n                processorConstructor.parameterDescriptors.forEach(function (_ref2, index) {\n                  var name = _ref2.name;\n                  copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n                });\n              }\n\n              for (var _j = 0; _j < options.numberOfInputs; _j += 1) {\n                for (var _k = 0; _k < options.outputChannelCount[_j]; _k += 1) {\n                  // The byteLength will be 0 when the ArrayBuffer was transferred.\n                  if (outputs[_j][_k].byteLength === 0) {\n                    outputs[_j][_k] = new Float32Array(128);\n                  }\n                }\n              }\n\n              try {\n                var potentiallyEmptyInputs = inputs.map(function (input, index) {\n                  if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [new Float32Array(0)];\n                  }\n\n                  return input;\n                });\n                var activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, function () {\n                  return audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters);\n                });\n\n                if (processedBuffer !== null) {\n                  for (var _j2 = 0, outputChannelSplitterNodeOutput = 0; _j2 < options.numberOfOutputs; _j2 += 1) {\n                    for (var _k2 = 0; _k2 < options.outputChannelCount[_j2]; _k2 += 1) {\n                      copyToChannel(processedBuffer, outputs[_j2], _k2, outputChannelSplitterNodeOutput + _k2, i);\n                    }\n\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[_j2];\n                  }\n                }\n\n                if (!activeSourceFlag) {\n                  return \"break\";\n                }\n              } catch (error) {\n                proxy.dispatchEvent(new ErrorEvent('processorerror', {\n                  error: error\n                }));\n                return \"break\";\n              }\n            };\n\n            i = 0;\n\n          case 15:\n            if (!(i < length)) {\n              _context.next = 22;\n              break;\n            }\n\n            _ret = _loop(i);\n\n            if (!(_ret === \"break\")) {\n              _context.next = 19;\n              break;\n            }\n\n            return _context.abrupt(\"break\", 22);\n\n          case 19:\n            i += 128;\n            _context.next = 15;\n            break;\n\n          case 22:\n            return _context.abrupt(\"return\", processedBuffer);\n\n          case 23:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function processBuffer(_x, _x2, _x3, _x4, _x5, _x6) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexport var createAudioWorkletNodeRendererFactory = function createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) {\n  return function (name, options, processorConstructor) {\n    var renderedNativeAudioNodes = new WeakMap();\n    var processedBufferPromise = null;\n\n    var createAudioNode = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(proxy, nativeOfflineAudioContext, trace) {\n        var nativeAudioWorkletNode, nativeOutputNodes, nativeAudioWorkletNodeIsOwnedByContext, numberOfOutputChannels, outputChannelSplitterNode, outputChannelMergerNodes, i, outputAudioNodes, outputGainNode, _numberOfInputChannels, numberOfParameters, numberOfChannels, renderBuffer, _processedBuffer, audioBufferSourceNode, _nativeOutputNodes, _nativeOutputNodes2, _outputChannelSplitterNode, _outputChannelMergerNodes, _outputGainNode, _i3, outputChannelSplitterNodeOutput, outputChannelMergerNode, j, _iterator2, _step2, _step2$value, nm, audioParam, _iterator3, _step3, _step3$value, _nm, _audioParam;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                nativeAudioWorkletNode = getNativeAudioNode(proxy);\n                nativeOutputNodes = null;\n                nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext); // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n\n                if (nativeAudioWorkletNodeConstructor === null) {\n                  numberOfOutputChannels = options.outputChannelCount.reduce(function (sum, value) {\n                    return sum + value;\n                  }, 0);\n                  outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                  });\n                  outputChannelMergerNodes = [];\n\n                  for (i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                      channelCount: 1,\n                      channelCountMode: 'explicit',\n                      channelInterpretation: 'speakers',\n                      numberOfInputs: options.outputChannelCount[i]\n                    }));\n                  } // Bug #87: Expose at least one output to make this node connectable.\n\n\n                  outputAudioNodes = options.numberOfOutputs === 0 ? [outputChannelSplitterNode] : outputChannelMergerNodes;\n                  outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                  });\n                  outputGainNode.connect = connectMultipleOutputs.bind(null, outputAudioNodes);\n                  outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputAudioNodes);\n                  nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n                } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                  nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n                }\n\n                renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n\n                if (!(nativeOutputNodes !== null)) {\n                  _context4.next = 39;\n                  break;\n                }\n\n                if (!(processedBufferPromise === null)) {\n                  _context4.next = 30;\n                  break;\n                }\n\n                if (!(processorConstructor === undefined)) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                throw new Error('Missing the processor constructor.');\n\n              case 9:\n                if (!(nativeOfflineAudioContextConstructor === null)) {\n                  _context4.next = 11;\n                  break;\n                }\n\n                throw new Error('Missing the native OfflineAudioContext constructor.');\n\n              case 11:\n                // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n                _numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                numberOfChannels = _numberOfInputChannels + numberOfParameters;\n\n                renderBuffer = /*#__PURE__*/function () {\n                  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n                    var partialOfflineAudioContext, gainNodes, inputChannelSplitterNodes, _i, constantSourceNodes, inputChannelMergerNode, _i2, j, _iterator, _step, _step$value, index, constantSourceNode;\n\n                    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, // Ceil the length to the next full render quantum.\n                            // Bug #17: Safari does not yet expose the length.\n                            Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                            gainNodes = [];\n                            inputChannelSplitterNodes = [];\n\n                            for (_i = 0; _i < options.numberOfInputs; _i += 1) {\n                              gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: options.channelCountMode,\n                                channelInterpretation: options.channelInterpretation,\n                                gain: 1\n                              }));\n                              inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                numberOfOutputs: options.channelCount\n                              }));\n                            }\n\n                            _context3.next = 6;\n                            return Promise.all(Array.from(proxy.parameters.values()).map( /*#__PURE__*/function () {\n                              var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(audioParam) {\n                                var constantSourceNode;\n                                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                                  while (1) {\n                                    switch (_context2.prev = _context2.next) {\n                                      case 0:\n                                        constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                          channelCount: 1,\n                                          channelCountMode: 'explicit',\n                                          channelInterpretation: 'discrete',\n                                          offset: audioParam.value\n                                        });\n                                        _context2.next = 3;\n                                        return renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace);\n\n                                      case 3:\n                                        return _context2.abrupt(\"return\", constantSourceNode);\n\n                                      case 4:\n                                      case \"end\":\n                                        return _context2.stop();\n                                    }\n                                  }\n                                }, _callee2);\n                              }));\n\n                              return function (_x10) {\n                                return _ref5.apply(this, arguments);\n                              };\n                            }()));\n\n                          case 6:\n                            constantSourceNodes = _context3.sent;\n                            inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                              channelCount: 1,\n                              channelCountMode: 'explicit',\n                              channelInterpretation: 'speakers',\n                              numberOfInputs: Math.max(1, _numberOfInputChannels + numberOfParameters)\n                            });\n\n                            for (_i2 = 0; _i2 < options.numberOfInputs; _i2 += 1) {\n                              gainNodes[_i2].connect(inputChannelSplitterNodes[_i2]);\n\n                              for (j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[_i2].connect(inputChannelMergerNode, j, _i2 * options.channelCount + j);\n                              }\n                            }\n\n                            _iterator = _createForOfIteratorHelper(constantSourceNodes.entries());\n\n                            try {\n                              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                                _step$value = _slicedToArray(_step.value, 2), index = _step$value[0], constantSourceNode = _step$value[1];\n                                constantSourceNode.connect(inputChannelMergerNode, 0, _numberOfInputChannels + index);\n                                constantSourceNode.start(0);\n                              }\n                            } catch (err) {\n                              _iterator.e(err);\n                            } finally {\n                              _iterator.f();\n                            }\n\n                            inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                            _context3.next = 14;\n                            return Promise.all(gainNodes.map(function (gainNode) {\n                              return renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace);\n                            }));\n\n                          case 14:\n                            return _context3.abrupt(\"return\", renderNativeOfflineAudioContext(partialOfflineAudioContext));\n\n                          case 15:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3);\n                  }));\n\n                  return function renderBuffer() {\n                    return _ref4.apply(this, arguments);\n                  };\n                }();\n\n                _context4.t0 = processBuffer;\n                _context4.t1 = proxy;\n\n                if (!(numberOfChannels === 0)) {\n                  _context4.next = 21;\n                  break;\n                }\n\n                _context4.t2 = null;\n                _context4.next = 24;\n                break;\n\n              case 21:\n                _context4.next = 23;\n                return renderBuffer();\n\n              case 23:\n                _context4.t2 = _context4.sent;\n\n              case 24:\n                _context4.t3 = _context4.t2;\n                _context4.t4 = nativeOfflineAudioContext;\n                _context4.t5 = options;\n                _context4.t6 = processorConstructor;\n                _context4.t7 = exposeCurrentFrameAndCurrentTime;\n                processedBufferPromise = (0, _context4.t0)(_context4.t1, _context4.t3, _context4.t4, _context4.t5, _context4.t6, _context4.t7);\n\n              case 30:\n                _context4.next = 32;\n                return processedBufferPromise;\n\n              case 32:\n                _processedBuffer = _context4.sent;\n                audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);\n                _nativeOutputNodes = nativeOutputNodes, _nativeOutputNodes2 = _slicedToArray(_nativeOutputNodes, 3), _outputChannelSplitterNode = _nativeOutputNodes2[0], _outputChannelMergerNodes = _nativeOutputNodes2[1], _outputGainNode = _nativeOutputNodes2[2];\n\n                if (_processedBuffer !== null) {\n                  audioBufferSourceNode.buffer = _processedBuffer;\n                  audioBufferSourceNode.start(0);\n                }\n\n                audioBufferSourceNode.connect(_outputChannelSplitterNode);\n\n                for (_i3 = 0, outputChannelSplitterNodeOutput = 0; _i3 < proxy.numberOfOutputs; _i3 += 1) {\n                  outputChannelMergerNode = _outputChannelMergerNodes[_i3];\n\n                  for (j = 0; j < options.outputChannelCount[_i3]; j += 1) {\n                    _outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                  }\n\n                  outputChannelSplitterNodeOutput += options.outputChannelCount[_i3];\n                }\n\n                return _context4.abrupt(\"return\", _outputGainNode);\n\n              case 39:\n                if (nativeAudioWorkletNodeIsOwnedByContext) {\n                  _context4.next = 59;\n                  break;\n                }\n\n                _iterator2 = _createForOfIteratorHelper(proxy.parameters.entries());\n                _context4.prev = 41;\n\n                _iterator2.s();\n\n              case 43:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context4.next = 49;\n                  break;\n                }\n\n                _step2$value = _slicedToArray(_step2.value, 2), nm = _step2$value[0], audioParam = _step2$value[1];\n                _context4.next = 47;\n                return renderAutomation(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                nativeAudioWorkletNode.parameters.get(nm), trace);\n\n              case 47:\n                _context4.next = 43;\n                break;\n\n              case 49:\n                _context4.next = 54;\n                break;\n\n              case 51:\n                _context4.prev = 51;\n                _context4.t8 = _context4[\"catch\"](41);\n\n                _iterator2.e(_context4.t8);\n\n              case 54:\n                _context4.prev = 54;\n\n                _iterator2.f();\n\n                return _context4.finish(54);\n\n              case 57:\n                _context4.next = 76;\n                break;\n\n              case 59:\n                _iterator3 = _createForOfIteratorHelper(proxy.parameters.entries());\n                _context4.prev = 60;\n\n                _iterator3.s();\n\n              case 62:\n                if ((_step3 = _iterator3.n()).done) {\n                  _context4.next = 68;\n                  break;\n                }\n\n                _step3$value = _slicedToArray(_step3.value, 2), _nm = _step3$value[0], _audioParam = _step3$value[1];\n                _context4.next = 66;\n                return connectAudioParam(nativeOfflineAudioContext, _audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                nativeAudioWorkletNode.parameters.get(_nm), trace);\n\n              case 66:\n                _context4.next = 62;\n                break;\n\n              case 68:\n                _context4.next = 73;\n                break;\n\n              case 70:\n                _context4.prev = 70;\n                _context4.t9 = _context4[\"catch\"](60);\n\n                _iterator3.e(_context4.t9);\n\n              case 73:\n                _context4.prev = 73;\n\n                _iterator3.f();\n\n                return _context4.finish(73);\n\n              case 76:\n                _context4.next = 78;\n                return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace);\n\n              case 78:\n                return _context4.abrupt(\"return\", nativeAudioWorkletNode);\n\n              case 79:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, null, [[41, 51, 54, 57], [60, 70, 73, 76]]);\n      }));\n\n      return function createAudioNode(_x7, _x8, _x9) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n\n    return {\n      render: function render(proxy, nativeOfflineAudioContext, trace) {\n        var renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n    };\n  };\n};","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/standardized-audio-context/build/es2018/factories/audio-worklet-node-renderer-factory.js"],"names":["copyFromChannel","copyToChannel","createNestedArrays","getAudioNodeConnections","getAudioWorkletProcessor","isOwnedByContext","processBuffer","proxy","renderedBuffer","nativeOfflineAudioContext","options","processorConstructor","exposeCurrentFrameAndCurrentTime","length","Math","ceil","context","numberOfInputChannels","channelCount","numberOfInputs","numberOfOutputChannels","outputChannelCount","reduce","sum","value","processedBuffer","createBuffer","sampleRate","undefined","Error","audioNodeConnections","audioWorkletProcessor","inputs","outputs","numberOfOutputs","parameters","Array","from","keys","prmtrs","name","Float32Array","i","j","k","parameterDescriptors","forEach","index","byteLength","potentiallyEmptyInputs","map","input","activeInputs","size","activeSourceFlag","process","outputChannelSplitterNodeOutput","error","dispatchEvent","ErrorEvent","createAudioWorkletNodeRendererFactory","connectAudioParam","connectMultipleOutputs","createNativeAudioBufferSourceNode","createNativeChannelMergerNode","createNativeChannelSplitterNode","createNativeConstantSourceNode","createNativeGainNode","disconnectMultipleOutputs","getNativeAudioNode","nativeAudioWorkletNodeConstructor","nativeOfflineAudioContextConstructor","renderAutomation","renderInputsOfAudioNode","renderNativeOfflineAudioContext","renderedNativeAudioNodes","WeakMap","processedBufferPromise","createAudioNode","trace","nativeAudioWorkletNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","outputChannelSplitterNode","max","channelCountMode","channelInterpretation","outputChannelMergerNodes","push","outputAudioNodes","outputGainNode","gain","connect","bind","disconnect","set","numberOfParameters","numberOfChannels","renderBuffer","partialOfflineAudioContext","gainNodes","inputChannelSplitterNodes","Promise","all","values","audioParam","constantSourceNode","offset","constantSourceNodes","inputChannelMergerNode","entries","start","destination","gainNode","audioBufferSourceNode","buffer","outputChannelMergerNode","nm","get","render","renderedNativeAudioWorkletNodeOrGainNode","resolve"],"mappings":"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","sourcesContent":["import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = (renderedBuffer === null) ? (Math.ceil(proxy.context.length / 128) * 128) : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer = (numberOfOutputChannels === 0) ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n    const parameters = Array\n        .from(proxy.parameters.keys())\n        .reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n        try {\n            const potentiallyEmptyInputs = inputs\n                .map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [new Float32Array(0)];\n                }\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n                }\n            }\n            if (!activeSourceFlag) {\n                break;\n            }\n        }\n        catch (error) {\n            proxy.dispatchEvent(new ErrorEvent('processorerror', { error }));\n            break;\n        }\n    }\n    return processedBuffer;\n};\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (name, options, processorConstructor) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let processedBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n            let nativeOutputNodes = null;\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes = [];\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: options.outputChannelCount[i]\n                    }));\n                }\n                // Bug #87: Expose at least one output to make this node connectable.\n                const outputAudioNodes = (options.numberOfOutputs === 0) ?\n                    [outputChannelSplitterNode] :\n                    outputChannelMergerNodes;\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n                outputGainNode.connect = connectMultipleOutputs.bind(null, outputAudioNodes);\n                outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputAudioNodes);\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            }\n            else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, (nativeOutputNodes === null) ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters = (processorConstructor.parameterDescriptors === undefined)\n                        ? 0\n                        : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, \n                        // Ceil the length to the next full render quantum.\n                        // Bug #17: Safari does not yet expose the length.\n                        Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                        const gainNodes = [];\n                        const inputChannelSplitterNodes = [];\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: options.channelCountMode,\n                                channelInterpretation: options.channelInterpretation,\n                                gain: 1\n                            }));\n                            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                numberOfOutputs: options.channelCount\n                            }));\n                        }\n                        const constantSourceNodes = await Promise\n                            .all(Array\n                            .from(proxy.parameters.values())\n                            .map(async (audioParam) => {\n                            const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                channelCount: 1,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                offset: audioParam.value\n                            });\n                            await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace);\n                            return constantSourceNode;\n                        }));\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, (i * options.channelCount) + j);\n                            }\n                        }\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                        await Promise\n                            .all(gainNodes\n                            .map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace)));\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n                    processedBufferPromise = processBuffer(proxy, (numberOfChannels === 0) ? null : await renderBuffer(), nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime);\n                }\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n                }\n                return outputGainNode;\n            }\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace);\n            return nativeAudioWorkletNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-worklet-node-renderer-factory.js.map"]},"metadata":{},"sourceType":"module"}