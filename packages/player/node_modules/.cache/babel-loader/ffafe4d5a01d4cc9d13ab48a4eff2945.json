{"ast":null,"code":"import _objectSpread from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _objectWithoutProperties from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport var createNativeWaveShaperNodeFakerFactory = function createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeGainNode, isDCCurve, monitorConnections) {\n  return function (nativeContext, _ref) {\n    var curve = _ref.curve,\n        oversample = _ref.oversample,\n        audioNodeOptions = _objectWithoutProperties(_ref, [\"curve\", \"oversample\"]);\n\n    var negativeWaveShaperNode = createNativeAudioNode(nativeContext, function (ntvCntxt) {\n      return ntvCntxt.createWaveShaper();\n    });\n    var positiveWaveShaperNode = createNativeAudioNode(nativeContext, function (ntvCntxt) {\n      return ntvCntxt.createWaveShaper();\n    });\n    assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n    assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n    var inputGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, audioNodeOptions), {}, {\n      gain: 1\n    }));\n    var invertGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, audioNodeOptions), {}, {\n      gain: -1\n    }));\n    var outputGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, audioNodeOptions), {}, {\n      gain: 1\n    }));\n    var revertGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, audioNodeOptions), {}, {\n      gain: -1\n    }));\n    var disconnectNativeAudioBufferSourceNode = null;\n    var isConnected = false;\n    var unmodifiedCurve = null;\n    var nativeWaveShaperNodeFaker = {\n      get bufferSize() {\n        return undefined;\n      },\n\n      get channelCount() {\n        return negativeWaveShaperNode.channelCount;\n      },\n\n      set channelCount(value) {\n        inputGainNode.channelCount = value;\n        invertGainNode.channelCount = value;\n        negativeWaveShaperNode.channelCount = value;\n        outputGainNode.channelCount = value;\n        positiveWaveShaperNode.channelCount = value;\n        revertGainNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return negativeWaveShaperNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        inputGainNode.channelCountMode = value;\n        invertGainNode.channelCountMode = value;\n        negativeWaveShaperNode.channelCountMode = value;\n        outputGainNode.channelCountMode = value;\n        positiveWaveShaperNode.channelCountMode = value;\n        revertGainNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return negativeWaveShaperNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        inputGainNode.channelInterpretation = value;\n        invertGainNode.channelInterpretation = value;\n        negativeWaveShaperNode.channelInterpretation = value;\n        outputGainNode.channelInterpretation = value;\n        positiveWaveShaperNode.channelInterpretation = value;\n        revertGainNode.channelInterpretation = value;\n      },\n\n      get context() {\n        return negativeWaveShaperNode.context;\n      },\n\n      get curve() {\n        return unmodifiedCurve;\n      },\n\n      set curve(value) {\n        // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n          throw createInvalidStateError();\n        }\n\n        if (value === null) {\n          negativeWaveShaperNode.curve = value;\n          positiveWaveShaperNode.curve = value;\n        } else {\n          var curveLength = value.length;\n          var negativeCurve = new Float32Array(curveLength + 2 - curveLength % 2);\n          var positiveCurve = new Float32Array(curveLength + 2 - curveLength % 2);\n          negativeCurve[0] = value[0];\n          positiveCurve[0] = -value[curveLength - 1];\n          var length = Math.ceil((curveLength + 1) / 2);\n          var centerIndex = (curveLength + 1) / 2 - 1;\n\n          for (var i = 1; i < length; i += 1) {\n            var theoreticIndex = i / length * centerIndex;\n            var lowerIndex = Math.floor(theoreticIndex);\n            var upperIndex = Math.ceil(theoreticIndex);\n            negativeCurve[i] = lowerIndex === upperIndex ? value[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * value[upperIndex];\n            positiveCurve[i] = lowerIndex === upperIndex ? -value[curveLength - 1 - lowerIndex] : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) - (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];\n          }\n\n          negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n          negativeWaveShaperNode.curve = negativeCurve;\n          positiveWaveShaperNode.curve = positiveCurve;\n        }\n\n        unmodifiedCurve = value;\n\n        if (isConnected) {\n          if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n            disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n          } else if (disconnectNativeAudioBufferSourceNode !== null) {\n            disconnectNativeAudioBufferSourceNode();\n            disconnectNativeAudioBufferSourceNode = null;\n          }\n        }\n      },\n\n      get inputs() {\n        return [inputGainNode];\n      },\n\n      get numberOfInputs() {\n        return negativeWaveShaperNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return negativeWaveShaperNode.numberOfOutputs;\n      },\n\n      get oversample() {\n        return negativeWaveShaperNode.oversample;\n      },\n\n      set oversample(value) {\n        negativeWaveShaperNode.oversample = value;\n        positiveWaveShaperNode.oversample = value;\n      },\n\n      addEventListener: function addEventListener() {\n        return inputGainNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      },\n      dispatchEvent: function dispatchEvent() {\n        return inputGainNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n      },\n      removeEventListener: function removeEventListener() {\n        return inputGainNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      }\n    };\n\n    if (curve !== nativeWaveShaperNodeFaker.curve) {\n      nativeWaveShaperNodeFaker.curve = curve;\n    }\n\n    if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n      nativeWaveShaperNodeFaker.oversample = oversample;\n    }\n\n    var whenConnected = function whenConnected() {\n      inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);\n      inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);\n      isConnected = true;\n\n      if (isDCCurve(unmodifiedCurve)) {\n        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n      }\n    };\n\n    var whenDisconnected = function whenDisconnected() {\n      inputGainNode.disconnect(negativeWaveShaperNode);\n      negativeWaveShaperNode.disconnect(outputGainNode);\n      inputGainNode.disconnect(invertGainNode);\n      invertGainNode.disconnect(positiveWaveShaperNode);\n      positiveWaveShaperNode.disconnect(revertGainNode);\n      revertGainNode.disconnect(outputGainNode);\n      isConnected = false;\n\n      if (disconnectNativeAudioBufferSourceNode !== null) {\n        disconnectNativeAudioBufferSourceNode();\n        disconnectNativeAudioBufferSourceNode = null;\n      }\n    };\n\n    return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/standardized-audio-context/build/es2018/factories/native-wave-shaper-node-faker-factory.js"],"names":["assignNativeAudioNodeOptions","interceptConnections","createNativeWaveShaperNodeFakerFactory","createConnectedNativeAudioBufferSourceNode","createInvalidStateError","createNativeAudioNode","createNativeGainNode","isDCCurve","monitorConnections","nativeContext","curve","oversample","audioNodeOptions","negativeWaveShaperNode","ntvCntxt","createWaveShaper","positiveWaveShaperNode","inputGainNode","gain","invertGainNode","outputGainNode","revertGainNode","disconnectNativeAudioBufferSourceNode","isConnected","unmodifiedCurve","nativeWaveShaperNodeFaker","bufferSize","undefined","channelCount","value","channelCountMode","channelInterpretation","context","length","curveLength","negativeCurve","Float32Array","positiveCurve","Math","ceil","centerIndex","i","theoreticIndex","lowerIndex","floor","upperIndex","inputs","numberOfInputs","numberOfOutputs","addEventListener","dispatchEvent","removeEventListener","whenConnected","connect","whenDisconnected","disconnect"],"mappings":"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","sourcesContent":["import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeWaveShaperNodeFakerFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeGainNode, isDCCurve, monitorConnections) => {\n    return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {\n        const negativeWaveShaperNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createWaveShaper());\n        const positiveWaveShaperNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createWaveShaper());\n        assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n        assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        let disconnectNativeAudioBufferSourceNode = null;\n        let isConnected = false;\n        let unmodifiedCurve = null;\n        const nativeWaveShaperNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return negativeWaveShaperNode.channelCount;\n            },\n            set channelCount(value) {\n                inputGainNode.channelCount = value;\n                invertGainNode.channelCount = value;\n                negativeWaveShaperNode.channelCount = value;\n                outputGainNode.channelCount = value;\n                positiveWaveShaperNode.channelCount = value;\n                revertGainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return negativeWaveShaperNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                inputGainNode.channelCountMode = value;\n                invertGainNode.channelCountMode = value;\n                negativeWaveShaperNode.channelCountMode = value;\n                outputGainNode.channelCountMode = value;\n                positiveWaveShaperNode.channelCountMode = value;\n                revertGainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return negativeWaveShaperNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                invertGainNode.channelInterpretation = value;\n                negativeWaveShaperNode.channelInterpretation = value;\n                outputGainNode.channelInterpretation = value;\n                positiveWaveShaperNode.channelInterpretation = value;\n                revertGainNode.channelInterpretation = value;\n            },\n            get context() {\n                return negativeWaveShaperNode.context;\n            },\n            get curve() {\n                return unmodifiedCurve;\n            },\n            set curve(value) {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                if (curve !== null && curve.length < 2) {\n                    throw createInvalidStateError();\n                }\n                if (value === null) {\n                    negativeWaveShaperNode.curve = value;\n                    positiveWaveShaperNode.curve = value;\n                }\n                else {\n                    const curveLength = value.length;\n                    const negativeCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    const positiveCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    negativeCurve[0] = value[0];\n                    positiveCurve[0] = -value[curveLength - 1];\n                    const length = Math.ceil((curveLength + 1) / 2);\n                    const centerIndex = ((curveLength + 1) / 2) - 1;\n                    for (let i = 1; i < length; i += 1) {\n                        const theoreticIndex = (i / length) * centerIndex;\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        negativeCurve[i] = (lowerIndex === upperIndex)\n                            ? value[lowerIndex]\n                            : ((1 - (theoreticIndex - lowerIndex)) * value[lowerIndex])\n                                + ((1 - (upperIndex - theoreticIndex)) * value[upperIndex]);\n                        positiveCurve[i] = (lowerIndex === upperIndex)\n                            ? -value[curveLength - 1 - lowerIndex]\n                            : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex])\n                                - ((1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex]);\n                    }\n                    negativeCurve[length] = (curveLength % 2 === 1) ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n                    negativeWaveShaperNode.curve = negativeCurve;\n                    positiveWaveShaperNode.curve = positiveCurve;\n                }\n                unmodifiedCurve = value;\n                if (isConnected) {\n                    if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n                        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n                    }\n                    else if (disconnectNativeAudioBufferSourceNode !== null) {\n                        disconnectNativeAudioBufferSourceNode();\n                        disconnectNativeAudioBufferSourceNode = null;\n                    }\n                }\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get numberOfInputs() {\n                return negativeWaveShaperNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return negativeWaveShaperNode.numberOfOutputs;\n            },\n            get oversample() {\n                return negativeWaveShaperNode.oversample;\n            },\n            set oversample(value) {\n                negativeWaveShaperNode.oversample = value;\n                positiveWaveShaperNode.oversample = value;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        if (curve !== nativeWaveShaperNodeFaker.curve) {\n            nativeWaveShaperNodeFaker.curve = curve;\n        }\n        if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n            nativeWaveShaperNodeFaker.oversample = oversample;\n        }\n        const whenConnected = () => {\n            inputGainNode\n                .connect(negativeWaveShaperNode)\n                .connect(outputGainNode);\n            inputGainNode\n                .connect(invertGainNode)\n                .connect(positiveWaveShaperNode)\n                .connect(revertGainNode)\n                .connect(outputGainNode);\n            isConnected = true;\n            if (isDCCurve(unmodifiedCurve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n            }\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(negativeWaveShaperNode);\n            negativeWaveShaperNode.disconnect(outputGainNode);\n            inputGainNode.disconnect(invertGainNode);\n            invertGainNode.disconnect(positiveWaveShaperNode);\n            positiveWaveShaperNode.disconnect(revertGainNode);\n            revertGainNode.disconnect(outputGainNode);\n            isConnected = false;\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n        return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-wave-shaper-node-faker-factory.js.map"]},"metadata":{},"sourceType":"module"}