{"ast":null,"code":"import bounds from \"./bounds\";\nimport cut from \"./cut\";\nimport dedup from \"./dedup\";\nimport delta from \"./delta\";\nimport extract from \"./extract\";\nimport geometry from \"./geometry\";\nimport hashmap from \"./hash/hashmap\";\nimport prequantize from \"./prequantize\"; // Constructs the TopoJSON Topology for the specified hash of features.\n// Each object in the specified hash must be a GeoJSON object,\n// meaning FeatureCollection, a Feature or a geometry object.\n\nexport default function (objects, quantization) {\n  var bbox = bounds(objects = geometry(objects)),\n      transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),\n      topology = dedup(cut(extract(objects))),\n      coordinates = topology.coordinates,\n      indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);\n  objects = topology.objects; // for garbage collection\n\n  topology.bbox = bbox;\n  topology.arcs = topology.arcs.map(function (arc, i) {\n    indexByArc.set(arc, i);\n    return coordinates.slice(arc[0], arc[1] + 1);\n  });\n  delete topology.coordinates;\n  coordinates = null;\n\n  function indexGeometry(geometry) {\n    if (geometry && indexGeometryType.hasOwnProperty(geometry.type)) indexGeometryType[geometry.type](geometry);\n  }\n\n  var indexGeometryType = {\n    GeometryCollection: function GeometryCollection(o) {\n      o.geometries.forEach(indexGeometry);\n    },\n    LineString: function LineString(o) {\n      o.arcs = indexArcs(o.arcs);\n    },\n    MultiLineString: function MultiLineString(o) {\n      o.arcs = o.arcs.map(indexArcs);\n    },\n    Polygon: function Polygon(o) {\n      o.arcs = o.arcs.map(indexArcs);\n    },\n    MultiPolygon: function MultiPolygon(o) {\n      o.arcs = o.arcs.map(indexMultiArcs);\n    }\n  };\n\n  function indexArcs(arc) {\n    var indexes = [];\n\n    do {\n      var index = indexByArc.get(arc);\n      indexes.push(arc[0] < arc[1] ? index : ~index);\n    } while (arc = arc.next);\n\n    return indexes;\n  }\n\n  function indexMultiArcs(arcs) {\n    return arcs.map(indexArcs);\n  }\n\n  for (var key in objects) {\n    indexGeometry(objects[key]);\n  }\n\n  if (transform) {\n    topology.transform = transform;\n    topology.arcs = delta(topology.arcs);\n  }\n\n  return topology;\n}\n\nfunction hashArc(arc) {\n  var i = arc[0],\n      j = arc[1],\n      t;\n  if (j < i) t = i, i = j, j = t;\n  return i + 31 * j;\n}\n\nfunction equalArc(arcA, arcB) {\n  var ia = arcA[0],\n      ja = arcA[1],\n      ib = arcB[0],\n      jb = arcB[1],\n      t;\n  if (ja < ia) t = ia, ia = ja, ja = t;\n  if (jb < ib) t = ib, ib = jb, jb = t;\n  return ia === ib && ja === jb;\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/topojson/node_modules/topojson-server/src/topology.js"],"names":["bounds","cut","dedup","delta","extract","geometry","hashmap","prequantize","objects","quantization","bbox","transform","topology","coordinates","indexByArc","arcs","length","hashArc","equalArc","map","arc","i","set","slice","indexGeometry","indexGeometryType","hasOwnProperty","type","GeometryCollection","o","geometries","forEach","LineString","indexArcs","MultiLineString","Polygon","MultiPolygon","indexMultiArcs","indexes","index","get","push","next","key","j","t","arcA","arcB","ia","ja","ib","jb"],"mappings":"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","sourcesContent":["import bounds from \"./bounds\";\nimport cut from \"./cut\";\nimport dedup from \"./dedup\";\nimport delta from \"./delta\";\nimport extract from \"./extract\";\nimport geometry from \"./geometry\";\nimport hashmap from \"./hash/hashmap\";\nimport prequantize from \"./prequantize\";\n\n// Constructs the TopoJSON Topology for the specified hash of features.\n// Each object in the specified hash must be a GeoJSON object,\n// meaning FeatureCollection, a Feature or a geometry object.\nexport default function(objects, quantization) {\n  var bbox = bounds(objects = geometry(objects)),\n      transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),\n      topology = dedup(cut(extract(objects))),\n      coordinates = topology.coordinates,\n      indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);\n\n  objects = topology.objects; // for garbage collection\n  topology.bbox = bbox;\n  topology.arcs = topology.arcs.map(function(arc, i) {\n    indexByArc.set(arc, i);\n    return coordinates.slice(arc[0], arc[1] + 1);\n  });\n\n  delete topology.coordinates;\n  coordinates = null;\n\n  function indexGeometry(geometry) {\n    if (geometry && indexGeometryType.hasOwnProperty(geometry.type)) indexGeometryType[geometry.type](geometry);\n  }\n\n  var indexGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(indexGeometry); },\n    LineString: function(o) { o.arcs = indexArcs(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(indexArcs); },\n    Polygon: function(o) { o.arcs = o.arcs.map(indexArcs); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(indexMultiArcs); }\n  };\n\n  function indexArcs(arc) {\n    var indexes = [];\n    do {\n      var index = indexByArc.get(arc);\n      indexes.push(arc[0] < arc[1] ? index : ~index);\n    } while (arc = arc.next);\n    return indexes;\n  }\n\n  function indexMultiArcs(arcs) {\n    return arcs.map(indexArcs);\n  }\n\n  for (var key in objects) {\n    indexGeometry(objects[key]);\n  }\n\n  if (transform) {\n    topology.transform = transform;\n    topology.arcs = delta(topology.arcs);\n  }\n\n  return topology;\n}\n\nfunction hashArc(arc) {\n  var i = arc[0], j = arc[1], t;\n  if (j < i) t = i, i = j, j = t;\n  return i + 31 * j;\n}\n\nfunction equalArc(arcA, arcB) {\n  var ia = arcA[0], ja = arcA[1],\n      ib = arcB[0], jb = arcB[1], t;\n  if (ja < ia) t = ia, ia = ja, ja = t;\n  if (jb < ib) t = ib, ib = jb, jb = t;\n  return ia === ib && ja === jb;\n}\n"]},"metadata":{},"sourceType":"module"}