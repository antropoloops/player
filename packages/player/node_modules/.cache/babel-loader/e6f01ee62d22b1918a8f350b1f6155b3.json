{"ast":null,"code":"export var wrapAudioBufferSourceNodeStartMethodDurationParameter = function wrapAudioBufferSourceNodeStartMethodDurationParameter(nativeAudioScheduledSourceNode, nativeContext) {\n  var endTime = Number.POSITIVE_INFINITY;\n  var stopTime = Number.POSITIVE_INFINITY;\n\n  nativeAudioScheduledSourceNode.start = function (start, stop) {\n    return function () {\n      var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.POSITIVE_INFINITY;\n      start.call(nativeAudioScheduledSourceNode, when, offset);\n\n      if (duration >= 0 && duration < Number.POSITIVE_INFINITY) {\n        var actualStartTime = Math.max(when, nativeContext.currentTime); // @todo The playbackRate could of course also have been automated and is not always fixed.\n\n        var durationInBufferTime = duration / nativeAudioScheduledSourceNode.playbackRate.value;\n        endTime = actualStartTime + durationInBufferTime;\n        stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n      }\n    };\n  }(nativeAudioScheduledSourceNode.start, nativeAudioScheduledSourceNode.stop);\n\n  nativeAudioScheduledSourceNode.stop = function (stop) {\n    return function () {\n      var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      stopTime = Math.max(when, nativeContext.currentTime);\n      stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n    };\n  }(nativeAudioScheduledSourceNode.stop);\n};","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-duration-parameter.js"],"names":["wrapAudioBufferSourceNodeStartMethodDurationParameter","nativeAudioScheduledSourceNode","nativeContext","endTime","Number","POSITIVE_INFINITY","stopTime","start","stop","when","offset","duration","call","actualStartTime","Math","max","currentTime","durationInBufferTime","playbackRate","value","min"],"mappings":"AAAA,OAAO,IAAMA,qDAAqD,GAAG,SAAxDA,qDAAwD,CAACC,8BAAD,EAAiCC,aAAjC,EAAmD;AACpH,MAAIC,OAAO,GAAGC,MAAM,CAACC,iBAArB;AACA,MAAIC,QAAQ,GAAGF,MAAM,CAACC,iBAAtB;;AACAJ,EAAAA,8BAA8B,CAACM,KAA/B,GAAwC,UAACA,KAAD,EAAQC,IAAR,EAAiB;AACrD,WAAO,YAA+D;AAAA,UAA9DC,IAA8D,uEAAvD,CAAuD;AAAA,UAApDC,MAAoD,uEAA3C,CAA2C;AAAA,UAAxCC,QAAwC,uEAA7BP,MAAM,CAACC,iBAAsB;AAClEE,MAAAA,KAAK,CAACK,IAAN,CAAWX,8BAAX,EAA2CQ,IAA3C,EAAiDC,MAAjD;;AACA,UAAIC,QAAQ,IAAI,CAAZ,IAAiBA,QAAQ,GAAGP,MAAM,CAACC,iBAAvC,EAA0D;AACtD,YAAMQ,eAAe,GAAGC,IAAI,CAACC,GAAL,CAASN,IAAT,EAAeP,aAAa,CAACc,WAA7B,CAAxB,CADsD,CAEtD;;AACA,YAAMC,oBAAoB,GAAIN,QAAQ,GAAGV,8BAA8B,CAACiB,YAA/B,CAA4CC,KAArF;AACAhB,QAAAA,OAAO,GAAGU,eAAe,GAAGI,oBAA5B;AACAT,QAAAA,IAAI,CAACI,IAAL,CAAUX,8BAAV,EAA0Ca,IAAI,CAACM,GAAL,CAASjB,OAAT,EAAkBG,QAAlB,CAA1C;AACH;AACJ,KATD;AAUH,GAXsC,CAWpCL,8BAA8B,CAACM,KAXK,EAWEN,8BAA8B,CAACO,IAXjC,CAAvC;;AAYAP,EAAAA,8BAA8B,CAACO,IAA/B,GAAuC,UAACA,IAAD,EAAU;AAC7C,WAAO,YAAc;AAAA,UAAbC,IAAa,uEAAN,CAAM;AACjBH,MAAAA,QAAQ,GAAGQ,IAAI,CAACC,GAAL,CAASN,IAAT,EAAeP,aAAa,CAACc,WAA7B,CAAX;AACAR,MAAAA,IAAI,CAACI,IAAL,CAAUX,8BAAV,EAA0Ca,IAAI,CAACM,GAAL,CAASjB,OAAT,EAAkBG,QAAlB,CAA1C;AACH,KAHD;AAIH,GALqC,CAKnCL,8BAA8B,CAACO,IALI,CAAtC;AAMH,CArBM","sourcesContent":["export const wrapAudioBufferSourceNodeStartMethodDurationParameter = (nativeAudioScheduledSourceNode, nativeContext) => {\n    let endTime = Number.POSITIVE_INFINITY;\n    let stopTime = Number.POSITIVE_INFINITY;\n    nativeAudioScheduledSourceNode.start = ((start, stop) => {\n        return (when = 0, offset = 0, duration = Number.POSITIVE_INFINITY) => {\n            start.call(nativeAudioScheduledSourceNode, when, offset);\n            if (duration >= 0 && duration < Number.POSITIVE_INFINITY) {\n                const actualStartTime = Math.max(when, nativeContext.currentTime);\n                // @todo The playbackRate could of course also have been automated and is not always fixed.\n                const durationInBufferTime = (duration / nativeAudioScheduledSourceNode.playbackRate.value);\n                endTime = actualStartTime + durationInBufferTime;\n                stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n            }\n        };\n    })(nativeAudioScheduledSourceNode.start, nativeAudioScheduledSourceNode.stop);\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            stopTime = Math.max(when, nativeContext.currentTime);\n            stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-duration-parameter.js.map"]},"metadata":{},"sourceType":"module"}