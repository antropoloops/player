{"ast":null,"code":"import { useCallback, useEffect, useState } from \"react\";\nimport { getActiveAudioContext } from \"../../../active-audio-context\";\nimport { AudiosetControl, EmptyControlState } from \"../../../player/Control\";\nexport function usePlayer(audioset, buffers) {\n  // Make visuals render after reference is set: https://dev.to/thekashey/the-same-useref-but-it-will-callback-8bo\n  const [el, setReference] = useState(null);\n  const visualsRef = useCallback(newRef => {\n    setReference(newRef);\n  }, []);\n  const [control, setControl] = useState();\n  const [state, setState] = useState(EmptyControlState);\n  useEffect(() => {\n    let cancelled = false;\n    let audio;\n    let visuals;\n\n    async function createControl() {\n      const ctx = await getActiveAudioContext();\n\n      if (cancelled) {\n        return;\n      }\n\n      const {\n        createAudioEffects\n      } = await import(\"../../../player/AudioEffects\");\n      audio = createAudioEffects(audioset, ctx, buffers);\n\n      if (el) {\n        const {\n          createVisualEffects\n        } = await import(\"../../../player/VisualEffects\");\n        visuals = createVisualEffects(audioset);\n        visuals.attach(el);\n      }\n\n      const ctl = new AudiosetControl(audioset, {\n        onControlStateChanged: newState => {\n          setState(newState);\n        },\n        onControlCommand: command => {\n          var _audio, _visuals;\n\n          (_audio = audio) === null || _audio === void 0 ? void 0 : _audio.run(command);\n          (_visuals = visuals) === null || _visuals === void 0 ? void 0 : _visuals.run(command);\n        }\n      });\n      return ctl;\n    }\n\n    createControl().then(instance => {\n      if (instance) {\n        setControl(instance);\n        setState(instance.getState());\n      }\n    });\n    return () => {\n      var _visuals2, _audio2;\n\n      cancelled = true;\n      (_visuals2 = visuals) === null || _visuals2 === void 0 ? void 0 : _visuals2.detach();\n      (_audio2 = audio) === null || _audio2 === void 0 ? void 0 : _audio2.detach();\n    };\n  }, [audioset, buffers, el]);\n  return {\n    visualsRef,\n    control,\n    state\n  };\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/packages/player/src/ui/components/Player/usePlayer.tsx"],"names":["useCallback","useEffect","useState","getActiveAudioContext","AudiosetControl","EmptyControlState","usePlayer","audioset","buffers","el","setReference","visualsRef","newRef","control","setControl","state","setState","cancelled","audio","visuals","createControl","ctx","createAudioEffects","createVisualEffects","attach","ctl","onControlStateChanged","newState","onControlCommand","command","run","then","instance","getState","detach"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,SAAtB,EAAiCC,QAAjC,QAAiD,OAAjD;AACA,SAASC,qBAAT,QAAsC,+BAAtC;AAEA,SACEC,eADF,EAEEC,iBAFF,QAIO,yBAJP;AAQA,OAAO,SAASC,SAAT,CAAmBC,QAAnB,EAAuCC,OAAvC,EAA+D;AACpE;AACA,QAAM,CAACC,EAAD,EAAKC,YAAL,IAAqBR,QAAQ,CAAwB,IAAxB,CAAnC;AACA,QAAMS,UAAU,GAAGX,WAAW,CAAEY,MAAD,IAA4B;AACzDF,IAAAA,YAAY,CAACE,MAAD,CAAZ;AACD,GAF6B,EAE3B,EAF2B,CAA9B;AAIA,QAAM,CAACC,OAAD,EAAUC,UAAV,IAAwBZ,QAAQ,EAAtC;AACA,QAAM,CAACa,KAAD,EAAQC,QAAR,IAAoBd,QAAQ,CAACG,iBAAD,CAAlC;AAEAJ,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIgB,SAAS,GAAG,KAAhB;AACA,QAAIC,KAAJ;AACA,QAAIC,OAAJ;;AAEA,mBAAeC,aAAf,GAA+B;AAC7B,YAAMC,GAAG,GAAG,MAAMlB,qBAAqB,EAAvC;;AAEA,UAAIc,SAAJ,EAAe;AACb;AACD;;AACD,YAAM;AAAEK,QAAAA;AAAF,UAAyB,MAAM,OACnC,8BADmC,CAArC;AAIAJ,MAAAA,KAAK,GAAGI,kBAAkB,CAACf,QAAD,EAAWc,GAAX,EAAgBb,OAAhB,CAA1B;;AAEA,UAAIC,EAAJ,EAAQ;AACN,cAAM;AAAEc,UAAAA;AAAF,YAA0B,MAAM,OACpC,+BADoC,CAAtC;AAGAJ,QAAAA,OAAO,GAAGI,mBAAmB,CAAChB,QAAD,CAA7B;AACAY,QAAAA,OAAO,CAACK,MAAR,CAAef,EAAf;AACD;;AAED,YAAMgB,GAAG,GAAG,IAAIrB,eAAJ,CAAoBG,QAApB,EAA8B;AACxCmB,QAAAA,qBAAqB,EAAEC,QAAQ,IAAI;AACjCX,UAAAA,QAAQ,CAACW,QAAD,CAAR;AACD,SAHuC;AAIxCC,QAAAA,gBAAgB,EAAEC,OAAO,IAAI;AAAA;;AAC3B,oBAAAX,KAAK,UAAL,wCAAOY,GAAP,CAAWD,OAAX;AACA,sBAAAV,OAAO,UAAP,4CAASW,GAAT,CAAaD,OAAb;AACD;AAPuC,OAA9B,CAAZ;AASA,aAAOJ,GAAP;AACD;;AACDL,IAAAA,aAAa,GAAGW,IAAhB,CAAqBC,QAAQ,IAAI;AAC/B,UAAIA,QAAJ,EAAc;AACZlB,QAAAA,UAAU,CAACkB,QAAD,CAAV;AACAhB,QAAAA,QAAQ,CAACgB,QAAQ,CAACC,QAAT,EAAD,CAAR;AACD;AACF,KALD;AAOA,WAAO,MAAM;AAAA;;AACXhB,MAAAA,SAAS,GAAG,IAAZ;AACA,mBAAAE,OAAO,UAAP,8CAASe,MAAT;AACA,iBAAAhB,KAAK,UAAL,0CAAOgB,MAAP;AACD,KAJD;AAKD,GAhDQ,EAgDN,CAAC3B,QAAD,EAAWC,OAAX,EAAoBC,EAApB,CAhDM,CAAT;AAkDA,SAAO;AAAEE,IAAAA,UAAF;AAAcE,IAAAA,OAAd;AAAuBE,IAAAA;AAAvB,GAAP;AACD","sourcesContent":["import { useCallback, useEffect, useState } from \"react\";\nimport { getActiveAudioContext } from \"../../../active-audio-context\";\nimport { Audioset } from \"../../../audioset\";\nimport {\n  AudiosetControl,\n  EmptyControlState,\n  PlayerControl,\n} from \"../../../player/Control\";\nimport { Effects } from \"../../../player/Control\";\nimport { SampleBuffers } from \"../../../sampler\";\n\nexport function usePlayer(audioset: Audioset, buffers: SampleBuffers) {\n  // Make visuals render after reference is set: https://dev.to/thekashey/the-same-useref-but-it-will-callback-8bo\n  const [el, setReference] = useState<HTMLDivElement | null>(null);\n  const visualsRef = useCallback((newRef: HTMLDivElement) => {\n    setReference(newRef);\n  }, []);\n\n  const [control, setControl] = useState<PlayerControl | undefined>();\n  const [state, setState] = useState(EmptyControlState);\n\n  useEffect(() => {\n    let cancelled = false;\n    let audio: Effects | undefined;\n    let visuals: Effects | undefined;\n\n    async function createControl() {\n      const ctx = await getActiveAudioContext();\n\n      if (cancelled) {\n        return;\n      }\n      const { createAudioEffects } = await import(\n        \"../../../player/AudioEffects\"\n      );\n\n      audio = createAudioEffects(audioset, ctx, buffers);\n\n      if (el) {\n        const { createVisualEffects } = await import(\n          \"../../../player/VisualEffects\"\n        );\n        visuals = createVisualEffects(audioset);\n        visuals.attach(el);\n      }\n\n      const ctl = new AudiosetControl(audioset, {\n        onControlStateChanged: newState => {\n          setState(newState);\n        },\n        onControlCommand: command => {\n          audio?.run(command);\n          visuals?.run(command);\n        },\n      });\n      return ctl;\n    }\n    createControl().then(instance => {\n      if (instance) {\n        setControl(instance);\n        setState(instance.getState());\n      }\n    });\n\n    return () => {\n      cancelled = true;\n      visuals?.detach();\n      audio?.detach();\n    };\n  }, [audioset, buffers, el]);\n\n  return { visualsRef, control, state };\n}\n"]},"metadata":{},"sourceType":"module"}