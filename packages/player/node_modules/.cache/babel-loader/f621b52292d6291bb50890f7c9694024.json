{"ast":null,"code":"import debug from \"debug\";\nimport { AudioContextEngine } from \"./AudioContextEngine\";\nconst log = debug(\"atpls:sampler\");\nexport function createAudioEffects(audioset, ctx, buffers) {\n  const audio = new AudioContextEngine(ctx);\n  return new AudioEffects(audioset, buffers, audio);\n}\n\nclass AudioEffects {\n  constructor(audioset, buffers, audio) {\n    this.audioset = audioset;\n    this.buffers = buffers;\n    this.audio = audio;\n    this.sampler = void 0;\n    this.sampler = new Sampler(audioset, buffers, audio);\n  }\n\n  attach() {// nothing to do?\n  }\n\n  detach() {\n    this.sampler.disconnect();\n  }\n\n  run(cmd) {\n    const command = cmd.command,\n          clipId = cmd.clipId,\n          time = cmd.time;\n\n    switch (command) {\n      case \"startClip\":\n        return this.sampler.start(clipId, time);\n\n      case \"stopClip\":\n        return this.sampler.stop(clipId, time);\n\n      default:\n    }\n  }\n\n}\n\nclass Sampler {\n  constructor(audioset, buffers, audio) {\n    this.audioset = audioset;\n    this.buffers = buffers;\n    this.audio = audio;\n    this.master = void 0;\n    this.tracks = {};\n    this.audioSources = {};\n    log(\"create sampler %s\", audioset.meta.title);\n    this.master = audio.createTrack(\"master\", {\n      volume: 0.8\n    });\n    audioset.tracks.forEach(track => {\n      this.tracks[track.id] = audio.createTrack(track.name, {\n        volume: 1\n      }, this.master);\n    });\n  }\n\n  connect() {// nothing to do?\n  }\n\n  disconnect() {\n    Object.keys(this.tracks).forEach(trackId => {\n      this.tracks[trackId].disconnect();\n    });\n  }\n\n  start(clipId, time) {\n    log(\"start %s\", clipId);\n\n    if (this.audioSources[clipId]) {\n      return;\n    }\n\n    const buffer = this.buffers.getBuffer(clipId);\n    const trackId = this.audioset.index.trackIdOfClip[clipId];\n    const track = this.tracks[trackId];\n    const source = this.audio.createAudioSource({\n      buffer\n    }, track);\n    this.audioSources[clipId] = source;\n    source.start(time);\n  }\n\n  stop(clipId, time) {\n    log(\"stop %s\", clipId);\n    const source = this.audioSources[clipId];\n\n    if (source !== undefined) {\n      source.stop(time);\n    }\n\n    this.audioSources[clipId] = undefined;\n  }\n\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/src/player/Audio/Sampler.ts"],"names":["debug","AudioContextEngine","log","createAudioEffects","audioset","ctx","buffers","audio","AudioEffects","constructor","sampler","Sampler","attach","detach","disconnect","run","cmd","command","clipId","time","start","stop","master","tracks","audioSources","meta","title","createTrack","volume","forEach","track","id","name","connect","Object","keys","trackId","buffer","getBuffer","index","trackIdOfClip","source","createAudioSource","undefined"],"mappings":"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","sourcesContent":["import debug from \"debug\";\nimport { IAudioContext } from \"standardized-audio-context\";\nimport { Audioset } from \"../../audioset\";\nimport { ControlCommand, Effects } from \"../Control\";\nimport { AudioEngine, AudioSource, AudioTrack } from \"./Audio\";\nimport { AudioContextEngine } from \"./AudioContextEngine\";\n\nconst log = debug(\"atpls:sampler\");\n\nexport interface SampleBuffers {\n  getBuffer(clipId: string): any;\n}\n\nexport function createAudioEffects(\n  audioset: Audioset,\n  ctx: IAudioContext,\n  buffers: SampleBuffers,\n): AudioEffects {\n  const audio = new AudioContextEngine(ctx);\n  return new AudioEffects(audioset, buffers, audio);\n}\n\nclass AudioEffects implements Effects {\n  public sampler: Sampler;\n  constructor(\n    private audioset: Audioset,\n    private buffers: SampleBuffers,\n    private audio: AudioEngine,\n  ) {\n    this.sampler = new Sampler(audioset, buffers, audio);\n  }\n\n  public attach() {\n    // nothing to do?\n  }\n\n  public detach() {\n    this.sampler.disconnect();\n  }\n\n  public run(cmd: ControlCommand) {\n    const { command, clipId, time } = cmd;\n    switch (command) {\n      case \"startClip\":\n        return this.sampler.start(clipId, time);\n      case \"stopClip\":\n        return this.sampler.stop(clipId, time);\n      default:\n    }\n  }\n}\nclass Sampler {\n  private master: AudioTrack;\n  private tracks: Record<string, AudioTrack> = {};\n  private audioSources: Record<string, AudioSource | undefined> = {};\n\n  constructor(\n    private audioset: Audioset,\n    private buffers: SampleBuffers,\n    private audio: AudioEngine,\n  ) {\n    log(\"create sampler %s\", audioset.meta.title);\n    this.master = audio.createTrack(\"master\", { volume: 0.8 });\n    audioset.tracks.forEach(track => {\n      this.tracks[track.id] = audio.createTrack(\n        track.name,\n        { volume: 1 },\n        this.master,\n      );\n    });\n  }\n  public connect() {\n    // nothing to do?\n  }\n\n  public disconnect() {\n    Object.keys(this.tracks).forEach(trackId => {\n      this.tracks[trackId].disconnect();\n    });\n  }\n\n  public start(clipId: string, time: number) {\n    log(\"start %s\", clipId);\n    if (this.audioSources[clipId]) {\n      return;\n    }\n\n    const buffer = this.buffers.getBuffer(clipId);\n    const trackId = this.audioset.index.trackIdOfClip[clipId];\n    const track = this.tracks[trackId];\n    const source = this.audio.createAudioSource({ buffer }, track);\n    this.audioSources[clipId] = source;\n\n    source.start(time);\n  }\n\n  public stop(clipId: string, time: number) {\n    log(\"stop %s\", clipId);\n    const source = this.audioSources[clipId];\n    if (source !== undefined) {\n      source.stop(time);\n    }\n    this.audioSources[clipId] = undefined;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}