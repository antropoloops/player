{"ast":null,"code":"import { geoProjectionMutator as projectionMutator, geoAzimuthalEquidistantRaw as azimuthalEquidistantRaw } from \"d3-geo\";\nimport { abs, acos, asin, atan, atan2, cos, degrees, halfPi, pi, radians, round, sin, sqrt, tan } from \"./math.js\";\nexport function berghausRaw(lobes) {\n  var k = 2 * pi / lobes;\n\n  function forward(lambda, phi) {\n    var p = azimuthalEquidistantRaw(lambda, phi);\n\n    if (abs(lambda) > halfPi) {\n      // back hemisphere\n      var theta = atan2(p[1], p[0]),\n          r = sqrt(p[0] * p[0] + p[1] * p[1]),\n          theta0 = k * round((theta - halfPi) / k) + halfPi,\n          alpha = atan2(sin(theta -= theta0), 2 - cos(theta)); // angle relative to lobe end\n\n      theta = theta0 + asin(pi / r * sin(alpha)) - alpha;\n      p[0] = r * cos(theta);\n      p[1] = r * sin(theta);\n    }\n\n    return p;\n  }\n\n  forward.invert = function (x, y) {\n    var r = sqrt(x * x + y * y);\n\n    if (r > halfPi) {\n      var theta = atan2(y, x),\n          theta0 = k * round((theta - halfPi) / k) + halfPi,\n          s = theta > theta0 ? -1 : 1,\n          A = r * cos(theta0 - theta),\n          cotAlpha = 1 / tan(s * acos((A - pi) / sqrt(pi * (pi - 2 * A) + r * r)));\n      theta = theta0 + 2 * atan((cotAlpha + s * sqrt(cotAlpha * cotAlpha - 3)) / 3);\n      x = r * cos(theta), y = r * sin(theta);\n    }\n\n    return azimuthalEquidistantRaw.invert(x, y);\n  };\n\n  return forward;\n}\nexport default function () {\n  var lobes = 5,\n      m = projectionMutator(berghausRaw),\n      p = m(lobes),\n      projectionStream = p.stream,\n      epsilon = 1e-2,\n      cr = -cos(epsilon * radians),\n      sr = sin(epsilon * radians);\n\n  p.lobes = function (_) {\n    return arguments.length ? m(lobes = +_) : lobes;\n  };\n\n  p.stream = function (stream) {\n    var rotate = p.rotate(),\n        rotateStream = projectionStream(stream),\n        sphereStream = (p.rotate([0, 0]), projectionStream(stream));\n    p.rotate(rotate);\n\n    rotateStream.sphere = function () {\n      sphereStream.polygonStart(), sphereStream.lineStart();\n\n      for (var i = 0, delta = 360 / lobes, delta0 = 2 * pi / lobes, phi = 90 - 180 / lobes, phi0 = halfPi; i < lobes; ++i, phi -= delta, phi0 -= delta0) {\n        sphereStream.point(atan2(sr * cos(phi0), cr) * degrees, asin(sr * sin(phi0)) * degrees);\n\n        if (phi < -90) {\n          sphereStream.point(-90, -180 - phi - epsilon);\n          sphereStream.point(-90, -180 - phi + epsilon);\n        } else {\n          sphereStream.point(90, phi + epsilon);\n          sphereStream.point(90, phi - epsilon);\n        }\n      }\n\n      sphereStream.lineEnd(), sphereStream.polygonEnd();\n    };\n\n    return rotateStream;\n  };\n\n  return p.scale(87.8076).center([0, 17.1875]).clipAngle(180 - 1e-3);\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/d3-geo-projection/src/berghaus.js"],"names":["geoProjectionMutator","projectionMutator","geoAzimuthalEquidistantRaw","azimuthalEquidistantRaw","abs","acos","asin","atan","atan2","cos","degrees","halfPi","pi","radians","round","sin","sqrt","tan","berghausRaw","lobes","k","forward","lambda","phi","p","theta","r","theta0","alpha","invert","x","y","s","A","cotAlpha","m","projectionStream","stream","epsilon","cr","sr","_","arguments","length","rotate","rotateStream","sphereStream","sphere","polygonStart","lineStart","i","delta","delta0","phi0","point","lineEnd","polygonEnd","scale","center","clipAngle"],"mappings":"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","sourcesContent":["import {geoProjectionMutator as projectionMutator, geoAzimuthalEquidistantRaw as azimuthalEquidistantRaw} from \"d3-geo\";\nimport {abs, acos, asin, atan, atan2, cos, degrees, halfPi, pi, radians, round, sin, sqrt, tan} from \"./math.js\";\n\nexport function berghausRaw(lobes) {\n  var k = 2 * pi / lobes;\n\n  function forward(lambda, phi) {\n    var p = azimuthalEquidistantRaw(lambda, phi);\n    if (abs(lambda) > halfPi) { // back hemisphere\n      var theta = atan2(p[1], p[0]),\n          r = sqrt(p[0] * p[0] + p[1] * p[1]),\n          theta0 = k * round((theta - halfPi) / k) + halfPi,\n          alpha = atan2(sin(theta -= theta0), 2 - cos(theta)); // angle relative to lobe end\n      theta = theta0 + asin(pi / r * sin(alpha)) - alpha;\n      p[0] = r * cos(theta);\n      p[1] = r * sin(theta);\n    }\n    return p;\n  }\n\n  forward.invert = function(x, y) {\n    var r = sqrt(x * x + y * y);\n    if (r > halfPi) {\n      var theta = atan2(y, x),\n          theta0 = k * round((theta - halfPi) / k) + halfPi,\n          s = theta > theta0 ? -1 : 1,\n          A = r * cos(theta0 - theta),\n          cotAlpha = 1 / tan(s * acos((A - pi) / sqrt(pi * (pi - 2 * A) + r * r)));\n      theta = theta0 + 2 * atan((cotAlpha + s * sqrt(cotAlpha * cotAlpha - 3)) / 3);\n      x = r * cos(theta), y = r * sin(theta);\n    }\n    return azimuthalEquidistantRaw.invert(x, y);\n  };\n\n  return forward;\n}\n\nexport default function() {\n  var lobes = 5,\n      m = projectionMutator(berghausRaw),\n      p = m(lobes),\n      projectionStream = p.stream,\n      epsilon = 1e-2,\n      cr = -cos(epsilon * radians),\n      sr = sin(epsilon * radians);\n\n  p.lobes = function(_) {\n    return arguments.length ? m(lobes = +_) : lobes;\n  };\n\n  p.stream = function(stream) {\n    var rotate = p.rotate(),\n        rotateStream = projectionStream(stream),\n        sphereStream = (p.rotate([0, 0]), projectionStream(stream));\n    p.rotate(rotate);\n    rotateStream.sphere = function() {\n      sphereStream.polygonStart(), sphereStream.lineStart();\n      for (var i = 0, delta = 360 / lobes, delta0 = 2 * pi / lobes, phi = 90 - 180 / lobes, phi0 = halfPi; i < lobes; ++i, phi -= delta, phi0 -= delta0) {\n        sphereStream.point(atan2(sr * cos(phi0), cr) * degrees, asin(sr * sin(phi0)) * degrees);\n        if (phi < -90) {\n          sphereStream.point(-90, -180 - phi - epsilon);\n          sphereStream.point(-90, -180 - phi + epsilon);\n        } else {\n          sphereStream.point(90, phi + epsilon);\n          sphereStream.point(90, phi - epsilon);\n        }\n      }\n      sphereStream.lineEnd(), sphereStream.polygonEnd();\n    };\n    return rotateStream;\n  };\n\n  return p\n      .scale(87.8076)\n      .center([0, 17.1875])\n      .clipAngle(180 - 1e-3);\n}\n"]},"metadata":{},"sourceType":"module"}