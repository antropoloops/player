{"ast":null,"code":"import*as d3geo from\"d3-geo-projection\";import*as d3 from\"d3\";import{WORLDRATIO}from\"./dimensions\";export function drawMap(container,countries,width,height,visuals){var scaleFactor=visuals.geomap.scaleFactor;var center=visuals.geomap.center;var scale=calculateMapScale(width,height);var projector=createMapProjector(width,height,scale*scaleFactor,center);var path=d3.geoPath().projection(projector);container.selectAll(\".countries\").data(countries).enter().append(\"path\").attr(\"id\",function(d){return\"country\".concat(d.id);}).attr(\"class\",\"countries\").attr(\"d\",path).style(\"stroke\",\"#2c2c2c\").style(\"stroke-width\",0.5).style(\"fill\",\"#888888\");}export function createMapProjector(width,height,scale,center){return d3geo.geoRobinson().scale(scale).center([center.x,center.y]).translate([width/2,height/2]);}export function calculateMapScale(width,height){var containerAspectRatio=width/height;var mapWidth=containerAspectRatio<WORLDRATIO?width:height*WORLDRATIO;// This is the scale needed for a world map drawn using the robinson projection to fit in a rectangle\n// with a WORLDRATIO proportion, defined as width-dependent\nvar scale=mapWidth/5.9;return scale;}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/src/visuals/drawMap.ts"],"names":["d3geo","d3","WORLDRATIO","drawMap","container","countries","width","height","visuals","scaleFactor","geomap","center","scale","calculateMapScale","projector","createMapProjector","path","geoPath","projection","selectAll","data","enter","append","attr","d","id","style","geoRobinson","x","y","translate","containerAspectRatio","mapWidth"],"mappings":"AAAA,MAAO,GAAKA,CAAAA,KAAZ,KAAuB,mBAAvB,CACA,MAAO,GAAKC,CAAAA,EAAZ,KAAoB,IAApB,CACA,OAASC,UAAT,KAA2B,cAA3B,CAGA,MAAO,SAASC,CAAAA,OAAT,CAAiBC,SAAjB,CAAiCC,SAAjC,CAAiDC,KAAjD,CAAgEC,MAAhE,CAAgFC,OAAhF,CAAqG,CAC1G,GAAMC,CAAAA,WAAW,CAAGD,OAAO,CAACE,MAAR,CAAeD,WAAnC,CACA,GAAME,CAAAA,MAAM,CAAGH,OAAO,CAACE,MAAR,CAAeC,MAA9B,CACA,GAAMC,CAAAA,KAAK,CAAGC,iBAAiB,CAACP,KAAD,CAAQC,MAAR,CAA/B,CAEA,GAAMO,CAAAA,SAAS,CAAGC,kBAAkB,CAACT,KAAD,CAAQC,MAAR,CAAgBK,KAAK,CAAGH,WAAxB,CAAqCE,MAArC,CAApC,CAEA,GAAMK,CAAAA,IAAI,CAAGf,EAAE,CAACgB,OAAH,GAAaC,UAAb,CAAwBJ,SAAxB,CAAb,CAEAV,SAAS,CACNe,SADH,CACa,YADb,EAEGC,IAFH,CAEQf,SAFR,EAGGgB,KAHH,GAIGC,MAJH,CAIU,MAJV,EAKGC,IALH,CAKQ,IALR,CAKc,SAACC,CAAD,yBAA8BA,CAAC,CAACC,EAAhC,GALd,EAMGF,IANH,CAMQ,OANR,CAMiB,WANjB,EAOGA,IAPH,CAOQ,GAPR,CAOaP,IAPb,EAQGU,KARH,CAQS,QART,CAQmB,SARnB,EASGA,KATH,CASS,cATT,CASyB,GATzB,EAUGA,KAVH,CAUS,MAVT,CAUiB,SAVjB,EAWD,CAED,MAAO,SAASX,CAAAA,kBAAT,CAA4BT,KAA5B,CAA2CC,MAA3C,CAA2DK,KAA3D,CAA0ED,MAA1E,CAAsG,CAC3G,MAAOX,CAAAA,KAAK,CAAC2B,WAAN,GAAoBf,KAApB,CAA0BA,KAA1B,EAAiCD,MAAjC,CAAwC,CAACA,MAAM,CAACiB,CAAR,CAAWjB,MAAM,CAACkB,CAAlB,CAAxC,EAA8DC,SAA9D,CAAwE,CAACxB,KAAK,CAAG,CAAT,CAAYC,MAAM,CAAG,CAArB,CAAxE,CAAP,CACD,CAED,MAAO,SAASM,CAAAA,iBAAT,CAA2BP,KAA3B,CAA0CC,MAA1C,CAA0D,CAC/D,GAAMwB,CAAAA,oBAAoB,CAAGzB,KAAK,CAAGC,MAArC,CACA,GAAMyB,CAAAA,QAAQ,CAAGD,oBAAoB,CAAG7B,UAAvB,CAAoCI,KAApC,CAA4CC,MAAM,CAAGL,UAAtE,CAEA;AACA;AACA,GAAMU,CAAAA,KAAK,CAAGoB,QAAQ,CAAG,GAAzB,CAEA,MAAOpB,CAAAA,KAAP,CACD","sourcesContent":["import * as d3geo from \"d3-geo-projection\";\nimport * as d3 from \"d3\";\nimport { WORLDRATIO } from \"./dimensions\";\nimport { MapVisuals } from \"../Audioset\";\n\nexport function drawMap(container: any, countries: any, width: number, height: number, visuals: MapVisuals) {\n  const scaleFactor = visuals.geomap.scaleFactor;\n  const center = visuals.geomap.center;\n  const scale = calculateMapScale(width, height);\n\n  const projector = createMapProjector(width, height, scale * scaleFactor, center);\n\n  const path = d3.geoPath().projection(projector);\n\n  container\n    .selectAll(\".countries\")\n    .data(countries)\n    .enter()\n    .append(\"path\")\n    .attr(\"id\", (d: { id: any }) => `country${d.id}`)\n    .attr(\"class\", \"countries\")\n    .attr(\"d\", path)\n    .style(\"stroke\", \"#2c2c2c\")\n    .style(\"stroke-width\", 0.5)\n    .style(\"fill\", \"#888888\");\n}\n\nexport function createMapProjector(width: number, height: number, scale: number, center: { x: any; y: any }) {\n  return d3geo.geoRobinson().scale(scale).center([center.x, center.y]).translate([width / 2, height / 2]);\n}\n\nexport function calculateMapScale(width: number, height: number) {\n  const containerAspectRatio = width / height;\n  const mapWidth = containerAspectRatio < WORLDRATIO ? width : height * WORLDRATIO;\n\n  // This is the scale needed for a world map drawn using the robinson projection to fit in a rectangle\n  // with a WORLDRATIO proportion, defined as width-dependent\n  const scale = mapWidth / 5.9;\n\n  return scale;\n}\n"]},"metadata":{},"sourceType":"module"}