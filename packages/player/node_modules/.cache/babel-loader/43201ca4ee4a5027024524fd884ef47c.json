{"ast":null,"code":"import { abs, acos, asin, atan, cos, epsilon, pi, sin, tan } from \"./math.js\";\nimport parallel1 from \"./parallel1.js\";\nexport function rectangularPolyconicRaw(phi0) {\n  var sinPhi0 = sin(phi0);\n\n  function forward(lambda, phi) {\n    var A = sinPhi0 ? tan(lambda * sinPhi0 / 2) / sinPhi0 : lambda / 2;\n    if (!phi) return [2 * A, -phi0];\n    var E = 2 * atan(A * sin(phi)),\n        cotPhi = 1 / tan(phi);\n    return [sin(E) * cotPhi, phi + (1 - cos(E)) * cotPhi - phi0];\n  } // TODO return null for points outside outline.\n\n\n  forward.invert = function (x, y) {\n    if (abs(y += phi0) < epsilon) return [sinPhi0 ? 2 * atan(sinPhi0 * x / 2) / sinPhi0 : x, 0];\n    var k = x * x + y * y,\n        phi = 0,\n        i = 10,\n        delta;\n\n    do {\n      var tanPhi = tan(phi),\n          secPhi = 1 / cos(phi),\n          j = k - 2 * y * phi + phi * phi;\n      phi -= delta = (tanPhi * j + 2 * (phi - y)) / (2 + j * secPhi * secPhi + 2 * (phi - y) * tanPhi);\n    } while (abs(delta) > epsilon && --i > 0);\n\n    var E = x * (tanPhi = tan(phi)),\n        A = tan(abs(y) < abs(phi + 1 / tanPhi) ? asin(E) * 0.5 : acos(E) * 0.5 + pi / 4) / sin(phi);\n    return [sinPhi0 ? 2 * atan(sinPhi0 * A) / sinPhi0 : 2 * A, phi];\n  };\n\n  return forward;\n}\nexport default function () {\n  return parallel1(rectangularPolyconicRaw).scale(131.215);\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/d3-geo-projection/src/rectangularPolyconic.js"],"names":["abs","acos","asin","atan","cos","epsilon","pi","sin","tan","parallel1","rectangularPolyconicRaw","phi0","sinPhi0","forward","lambda","phi","A","E","cotPhi","invert","x","y","k","i","delta","tanPhi","secPhi","j","scale"],"mappings":"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","sourcesContent":["import {abs, acos, asin, atan, cos, epsilon, pi, sin, tan} from \"./math.js\";\nimport parallel1 from \"./parallel1.js\";\n\nexport function rectangularPolyconicRaw(phi0) {\n  var sinPhi0 = sin(phi0);\n\n  function forward(lambda, phi) {\n    var A = sinPhi0 ? tan(lambda * sinPhi0 / 2) / sinPhi0 : lambda / 2;\n    if (!phi) return [2 * A, -phi0];\n    var E = 2 * atan(A * sin(phi)),\n        cotPhi = 1 / tan(phi);\n    return [\n      sin(E) * cotPhi,\n      phi + (1 - cos(E)) * cotPhi - phi0\n    ];\n  }\n\n  // TODO return null for points outside outline.\n  forward.invert = function(x, y) {\n    if (abs(y += phi0) < epsilon) return [sinPhi0 ? 2 * atan(sinPhi0 * x / 2) / sinPhi0 : x, 0];\n    var k = x * x + y * y,\n        phi = 0,\n        i = 10, delta;\n    do {\n      var tanPhi = tan(phi),\n          secPhi = 1 / cos(phi),\n          j = k - 2 * y * phi + phi * phi;\n      phi -= delta = (tanPhi * j + 2 * (phi - y)) / (2 + j * secPhi * secPhi + 2 * (phi - y) * tanPhi);\n    } while (abs(delta) > epsilon && --i > 0);\n    var E = x * (tanPhi = tan(phi)),\n        A = tan(abs(y) < abs(phi + 1 / tanPhi) ? asin(E) * 0.5 : acos(E) * 0.5 + pi / 4) / sin(phi);\n    return [\n      sinPhi0 ? 2 * atan(sinPhi0 * A) / sinPhi0 : 2 * A,\n      phi\n    ];\n  };\n\n  return forward;\n}\n\nexport default function() {\n  return parallel1(rectangularPolyconicRaw)\n      .scale(131.215);\n}\n"]},"metadata":{},"sourceType":"module"}