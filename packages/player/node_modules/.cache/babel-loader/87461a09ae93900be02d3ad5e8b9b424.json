{"ast":null,"code":"import _defineProperty from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nvar DEFAULT_OPTIONS = {\n  numberOfChannels: 1\n};\nexport var createMinimalOfflineAudioContextConstructor = function createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, _startRendering) {\n  return (\n    /*#__PURE__*/\n    function (_minimalBaseAudioCont) {\n      _inherits(MinimalOfflineAudioContext, _minimalBaseAudioCont);\n\n      function MinimalOfflineAudioContext(options) {\n        var _this;\n\n        _classCallCheck(this, MinimalOfflineAudioContext);\n\n        var _DEFAULT_OPTIONS$opti = _objectSpread({}, DEFAULT_OPTIONS, {}, options),\n            length = _DEFAULT_OPTIONS$opti.length,\n            numberOfChannels = _DEFAULT_OPTIONS$opti.numberOfChannels,\n            sampleRate = _DEFAULT_OPTIONS$opti.sampleRate;\n\n        var nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate); // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n\n        if (!cacheTestResult(testPromiseSupport, function () {\n          return testPromiseSupport(nativeOfflineAudioContext);\n        })) {\n          nativeOfflineAudioContext.addEventListener('statechange', function () {\n            var i = 0;\n\n            var delayStateChangeEvent = function delayStateChangeEvent(event) {\n              if (_this._state === 'running') {\n                if (i > 0) {\n                  nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                  event.stopImmediatePropagation();\n\n                  _this._waitForThePromiseToSettle(event);\n                } else {\n                  i += 1;\n                }\n              }\n            };\n\n            return delayStateChangeEvent;\n          }());\n        }\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(MinimalOfflineAudioContext).call(this, nativeOfflineAudioContext, numberOfChannels));\n        _this._length = length;\n        _this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n        _this._state = null;\n        return _this;\n      }\n\n      _createClass(MinimalOfflineAudioContext, [{\n        key: \"startRendering\",\n        value: function startRendering() {\n          var _this2 = this;\n\n          /*\n           * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n           * the state of the nativeOfflineAudioContext might no transition to running immediately.\n           */\n          if (this._state === 'running') {\n            return Promise.reject(createInvalidStateError());\n          }\n\n          this._state = 'running';\n          return _startRendering(this.destination, this._nativeOfflineAudioContext).then(function (audioBuffer) {\n            _this2._state = null;\n            /*\n             * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n             * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n             */\n\n            return audioBuffer;\n          }) // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n          .catch(function (err) {\n            _this2._state = null;\n            /*\n             * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n             * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n             */\n\n            throw err; // tslint:disable-line:rxjs-throw-error\n          });\n        }\n      }, {\n        key: \"_waitForThePromiseToSettle\",\n        value: function _waitForThePromiseToSettle(event) {\n          var _this3 = this;\n\n          if (this._state === null) {\n            this._nativeOfflineAudioContext.dispatchEvent(event);\n          } else {\n            setTimeout(function () {\n              return _this3._waitForThePromiseToSettle(event);\n            });\n          }\n        }\n      }, {\n        key: \"length\",\n        get: function get() {\n          // Bug #17: Safari does not yet expose the length.\n          if (this._nativeOfflineAudioContext.length === undefined) {\n            return this._length;\n          }\n\n          return this._nativeOfflineAudioContext.length;\n        }\n      }, {\n        key: \"state\",\n        get: function get() {\n          return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n      }]);\n\n      return MinimalOfflineAudioContext;\n    }(minimalBaseAudioContextConstructor)\n  );\n};","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/standardized-audio-context/build/es2018/factories/minimal-offline-audio-context-constructor.js"],"names":["testPromiseSupport","DEFAULT_OPTIONS","numberOfChannels","createMinimalOfflineAudioContextConstructor","cacheTestResult","createInvalidStateError","createNativeOfflineAudioContext","minimalBaseAudioContextConstructor","startRendering","options","length","sampleRate","nativeOfflineAudioContext","addEventListener","i","delayStateChangeEvent","event","_state","removeEventListener","stopImmediatePropagation","_waitForThePromiseToSettle","_length","_nativeOfflineAudioContext","Promise","reject","destination","then","audioBuffer","catch","err","dispatchEvent","setTimeout","undefined","state"],"mappings":"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","sourcesContent":["import { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createMinimalOfflineAudioContextConstructor = (cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering) => {\n    return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(options) {\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener('statechange', (() => {\n                    let i = 0;\n                    const delayStateChangeEvent = (event) => {\n                        if (this._state === 'running') {\n                            if (i > 0) {\n                                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                event.stopImmediatePropagation();\n                                this._waitForThePromiseToSettle(event);\n                            }\n                            else {\n                                i += 1;\n                            }\n                        }\n                    };\n                    return delayStateChangeEvent;\n                })());\n            }\n            super(nativeOfflineAudioContext, numberOfChannels);\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n        get length() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n        }\n        get state() {\n            return (this._state === null) ? this._nativeOfflineAudioContext.state : this._state;\n        }\n        startRendering() {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return startRendering(this.destination, this._nativeOfflineAudioContext)\n                .then((audioBuffer) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                return audioBuffer;\n            })\n                // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n                .catch((err) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n        _waitForThePromiseToSettle(event) {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            }\n            else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/minimal-offline-audio-context-constructor.js.map"]},"metadata":{},"sourceType":"module"}