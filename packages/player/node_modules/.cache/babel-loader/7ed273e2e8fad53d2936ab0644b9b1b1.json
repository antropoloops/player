{"ast":null,"code":"export const createWrapAudioBufferCopyChannelMethodsOutOfBounds = convertNumberToUnsignedLong => {\n  return audioBuffer => {\n    audioBuffer.copyFromChannel = (copyFromChannel => {\n      return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n        const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n        const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n        if (bufferOffset < audioBuffer.length) {\n          return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n        }\n      };\n    })(audioBuffer.copyFromChannel);\n\n    audioBuffer.copyToChannel = (copyToChannel => {\n      return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n        const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n        const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n        if (bufferOffset < audioBuffer.length) {\n          return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n        }\n      };\n    })(audioBuffer.copyToChannel);\n  };\n};","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/standardized-audio-context/build/es2018/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js"],"names":["createWrapAudioBufferCopyChannelMethodsOutOfBounds","convertNumberToUnsignedLong","audioBuffer","copyFromChannel","destination","channelNumberAsNumber","bufferOffsetAsNumber","bufferOffset","channelNumber","length","call","copyToChannel","source"],"mappings":"AAAA,OAAO,MAAMA,kDAAkD,GAAIC,2BAAD,IAAiC;AAC/F,SAAQC,WAAD,IAAiB;AACpBA,IAAAA,WAAW,CAACC,eAAZ,GAA8B,CAAEA,eAAD,IAAqB;AAChD,aAAO,CAACC,WAAD,EAAcC,qBAAd,EAAqCC,oBAAoB,GAAG,CAA5D,KAAkE;AACrE,cAAMC,YAAY,GAAGN,2BAA2B,CAACK,oBAAD,CAAhD;AACA,cAAME,aAAa,GAAGP,2BAA2B,CAACI,qBAAD,CAAjD;;AACA,YAAIE,YAAY,GAAGL,WAAW,CAACO,MAA/B,EAAuC;AACnC,iBAAON,eAAe,CAACO,IAAhB,CAAqBR,WAArB,EAAkCE,WAAlC,EAA+CI,aAA/C,EAA8DD,YAA9D,CAAP;AACH;AACJ,OAND;AAOH,KAR6B,EAQ3BL,WAAW,CAACC,eARe,CAA9B;;AASAD,IAAAA,WAAW,CAACS,aAAZ,GAA4B,CAAEA,aAAD,IAAmB;AAC5C,aAAO,CAACC,MAAD,EAASP,qBAAT,EAAgCC,oBAAoB,GAAG,CAAvD,KAA6D;AAChE,cAAMC,YAAY,GAAGN,2BAA2B,CAACK,oBAAD,CAAhD;AACA,cAAME,aAAa,GAAGP,2BAA2B,CAACI,qBAAD,CAAjD;;AACA,YAAIE,YAAY,GAAGL,WAAW,CAACO,MAA/B,EAAuC;AACnC,iBAAOE,aAAa,CAACD,IAAd,CAAmBR,WAAnB,EAAgCU,MAAhC,EAAwCJ,aAAxC,EAAuDD,YAAvD,CAAP;AACH;AACJ,OAND;AAOH,KAR2B,EAQzBL,WAAW,CAACS,aARa,CAA5B;AASH,GAnBD;AAoBH,CArBM","sourcesContent":["export const createWrapAudioBufferCopyChannelMethodsOutOfBounds = (convertNumberToUnsignedLong) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = ((copyFromChannel) => {\n            return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyFromChannel);\n        audioBuffer.copyToChannel = ((copyToChannel) => {\n            return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyToChannel);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js.map"]},"metadata":{},"sourceType":"module"}