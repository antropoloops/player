{"ast":null,"code":"import { geoProjectionMutator as projectionMutator } from \"d3-geo\";\nimport { abs, atan2, cos, degrees, epsilon, radians, sin, tan } from \"./math.js\";\nexport function armadilloRaw(phi0) {\n  var sinPhi0 = sin(phi0),\n      cosPhi0 = cos(phi0),\n      sPhi0 = phi0 >= 0 ? 1 : -1,\n      tanPhi0 = tan(sPhi0 * phi0),\n      k = (1 + sinPhi0 - cosPhi0) / 2;\n\n  function forward(lambda, phi) {\n    var cosPhi = cos(phi),\n        cosLambda = cos(lambda /= 2);\n    return [(1 + cosPhi) * sin(lambda), (sPhi0 * phi > -atan2(cosLambda, tanPhi0) - 1e-3 ? 0 : -sPhi0 * 10) + k + sin(phi) * cosPhi0 - (1 + cosPhi) * sinPhi0 * cosLambda // TODO D3 core should allow null or [NaN, NaN] to be returned.\n    ];\n  }\n\n  forward.invert = function (x, y) {\n    var lambda = 0,\n        phi = 0,\n        i = 50;\n\n    do {\n      var cosLambda = cos(lambda),\n          sinLambda = sin(lambda),\n          cosPhi = cos(phi),\n          sinPhi = sin(phi),\n          A = 1 + cosPhi,\n          fx = A * sinLambda - x,\n          fy = k + sinPhi * cosPhi0 - A * sinPhi0 * cosLambda - y,\n          dxdLambda = A * cosLambda / 2,\n          dxdPhi = -sinLambda * sinPhi,\n          dydLambda = sinPhi0 * A * sinLambda / 2,\n          dydPhi = cosPhi0 * cosPhi + sinPhi0 * cosLambda * sinPhi,\n          denominator = dxdPhi * dydLambda - dydPhi * dxdLambda,\n          dLambda = (fy * dxdPhi - fx * dydPhi) / denominator / 2,\n          dPhi = (fx * dydLambda - fy * dxdLambda) / denominator;\n      if (abs(dPhi) > 2) dPhi /= 2;\n      lambda -= dLambda, phi -= dPhi;\n    } while ((abs(dLambda) > epsilon || abs(dPhi) > epsilon) && --i > 0);\n\n    return sPhi0 * phi > -atan2(cos(lambda), tanPhi0) - 1e-3 ? [lambda * 2, phi] : null;\n  };\n\n  return forward;\n}\nexport default function () {\n  var phi0 = 20 * radians,\n      sPhi0 = phi0 >= 0 ? 1 : -1,\n      tanPhi0 = tan(sPhi0 * phi0),\n      m = projectionMutator(armadilloRaw),\n      p = m(phi0),\n      stream_ = p.stream;\n\n  p.parallel = function (_) {\n    if (!arguments.length) return phi0 * degrees;\n    tanPhi0 = tan((sPhi0 = (phi0 = _ * radians) >= 0 ? 1 : -1) * phi0);\n    return m(phi0);\n  };\n\n  p.stream = function (stream) {\n    var rotate = p.rotate(),\n        rotateStream = stream_(stream),\n        sphereStream = (p.rotate([0, 0]), stream_(stream)),\n        precision = p.precision();\n    p.rotate(rotate);\n\n    rotateStream.sphere = function () {\n      sphereStream.polygonStart(), sphereStream.lineStart();\n\n      for (var lambda = sPhi0 * -180; sPhi0 * lambda < 180; lambda += sPhi0 * 90) {\n        sphereStream.point(lambda, sPhi0 * 90);\n      }\n\n      if (phi0) while (sPhi0 * (lambda -= 3 * sPhi0 * precision) >= -180) {\n        sphereStream.point(lambda, sPhi0 * -atan2(cos(lambda * radians / 2), tanPhi0) * degrees);\n      }\n      sphereStream.lineEnd(), sphereStream.polygonEnd();\n    };\n\n    return rotateStream;\n  };\n\n  return p.scale(218.695).center([0, 28.0974]);\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/d3-geo-projection/src/armadillo.js"],"names":["geoProjectionMutator","projectionMutator","abs","atan2","cos","degrees","epsilon","radians","sin","tan","armadilloRaw","phi0","sinPhi0","cosPhi0","sPhi0","tanPhi0","k","forward","lambda","phi","cosPhi","cosLambda","invert","x","y","i","sinLambda","sinPhi","A","fx","fy","dxdLambda","dxdPhi","dydLambda","dydPhi","denominator","dLambda","dPhi","m","p","stream_","stream","parallel","_","arguments","length","rotate","rotateStream","sphereStream","precision","sphere","polygonStart","lineStart","point","lineEnd","polygonEnd","scale","center"],"mappings":"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","sourcesContent":["import {geoProjectionMutator as projectionMutator} from \"d3-geo\";\nimport {abs, atan2, cos, degrees, epsilon, radians, sin, tan} from \"./math.js\";\n\nexport function armadilloRaw(phi0) {\n  var sinPhi0 = sin(phi0),\n      cosPhi0 = cos(phi0),\n      sPhi0 = phi0 >= 0 ? 1 : -1,\n      tanPhi0 = tan(sPhi0 * phi0),\n      k = (1 + sinPhi0 - cosPhi0) / 2;\n\n  function forward(lambda, phi) {\n    var cosPhi = cos(phi),\n        cosLambda = cos(lambda /= 2);\n    return [\n      (1 + cosPhi) * sin(lambda),\n      (sPhi0 * phi > -atan2(cosLambda, tanPhi0) - 1e-3 ? 0 : -sPhi0 * 10) + k + sin(phi) * cosPhi0 - (1 + cosPhi) * sinPhi0 * cosLambda // TODO D3 core should allow null or [NaN, NaN] to be returned.\n    ];\n  }\n\n  forward.invert = function(x, y) {\n    var lambda = 0,\n        phi = 0,\n        i = 50;\n    do {\n      var cosLambda = cos(lambda),\n          sinLambda = sin(lambda),\n          cosPhi = cos(phi),\n          sinPhi = sin(phi),\n          A = 1 + cosPhi,\n          fx = A * sinLambda - x,\n          fy = k + sinPhi * cosPhi0 - A * sinPhi0 * cosLambda - y,\n          dxdLambda = A * cosLambda / 2,\n          dxdPhi = -sinLambda * sinPhi,\n          dydLambda = sinPhi0 * A * sinLambda / 2,\n          dydPhi = cosPhi0 * cosPhi + sinPhi0 * cosLambda * sinPhi,\n          denominator = dxdPhi * dydLambda - dydPhi * dxdLambda,\n          dLambda = (fy * dxdPhi - fx * dydPhi) / denominator / 2,\n          dPhi = (fx * dydLambda - fy * dxdLambda) / denominator;\n      if (abs(dPhi) > 2) dPhi /= 2;\n      lambda -= dLambda, phi -= dPhi;\n    } while ((abs(dLambda) > epsilon || abs(dPhi) > epsilon) && --i > 0);\n    return sPhi0 * phi > -atan2(cos(lambda), tanPhi0) - 1e-3 ? [lambda * 2, phi] : null;\n  };\n\n  return forward;\n}\n\nexport default function() {\n  var phi0 = 20 * radians,\n      sPhi0 = phi0 >= 0 ? 1 : -1,\n      tanPhi0 = tan(sPhi0 * phi0),\n      m = projectionMutator(armadilloRaw),\n      p = m(phi0),\n      stream_ = p.stream;\n\n  p.parallel = function(_) {\n    if (!arguments.length) return phi0 * degrees;\n    tanPhi0 = tan((sPhi0 = (phi0 = _ * radians) >= 0 ? 1 : -1) * phi0);\n    return m(phi0);\n  };\n\n  p.stream = function(stream) {\n    var rotate = p.rotate(),\n        rotateStream = stream_(stream),\n        sphereStream = (p.rotate([0, 0]), stream_(stream)),\n        precision = p.precision();\n    p.rotate(rotate);\n    rotateStream.sphere = function() {\n      sphereStream.polygonStart(), sphereStream.lineStart();\n      for (var lambda = sPhi0 * -180; sPhi0 * lambda < 180; lambda += sPhi0 * 90)\n        sphereStream.point(lambda, sPhi0 * 90);\n      if (phi0) while (sPhi0 * (lambda -= 3 * sPhi0 * precision) >= -180) {\n        sphereStream.point(lambda, sPhi0 * -atan2(cos(lambda * radians / 2), tanPhi0) * degrees);\n      }\n      sphereStream.lineEnd(), sphereStream.polygonEnd();\n    };\n    return rotateStream;\n  };\n\n  return p\n      .scale(218.695)\n      .center([0, 28.0974]);\n}\n"]},"metadata":{},"sourceType":"module"}