{"ast":null,"code":"import debug from \"debug\";\nconst log = debug(\"atpls:resources\"); // TODO: abstract the loader mechanism: { status, payload }\n\nexport class ResourceLoader {\n  constructor(audioset, listener) {\n    this.audioset = audioset;\n    this.listener = listener;\n    this.status = void 0;\n    this.total = void 0;\n    this.completed = void 0;\n    this.buffers = {};\n\n    this.fetch = () => Promise.reject();\n\n    log(\"creeate ResourceLoader\");\n    this.status = {\n      status: \"pending\"\n    };\n    this.total = this.audioset.clips.length;\n    this.completed = 0;\n  }\n\n  getBuffer(clipId) {\n    return this.buffers[clipId];\n  }\n\n  preload() {\n    log(\"Preload\"); // preload images and maps\n  }\n\n  load() {\n    const total = this.total,\n          completed = this.completed;\n\n    if (total === completed) {\n      return;\n    }\n\n    this._setStatus({\n      status: \"loading\",\n      total,\n      completed: 0\n    });\n\n    const clips = this.audioset.clips;\n    const promises = clips.map(clip => this._loadAudio(clip).catch(err => {\n      this._complete();\n\n      log(\"Error %o\", err);\n    }));\n    return Promise.all(promises);\n  } //// PRIVATE ////\n\n\n  _setStatus(status) {\n    this.status = status;\n    this.listener(status);\n  }\n\n  async _loadAudio(clip) {\n    // TODO: check other formats\n    const url = clip.resources.audio.mp3;\n    const buffer = await this.fetch(url);\n    this.buffers[clip.id] = buffer;\n\n    this._complete(url);\n\n    return buffer;\n  }\n\n  _complete(url) {\n    this.completed += 1;\n    const status = this.completed >= this.total ? {\n      status: \"ready\",\n      total: this.total\n    } : {\n      status: \"loading\",\n      total: this.total,\n      completed: this.completed\n    };\n\n    this._setStatus(status);\n  }\n\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/src/player/ResourceLoader.ts"],"names":["debug","log","ResourceLoader","constructor","audioset","listener","status","total","completed","buffers","fetch","Promise","reject","clips","length","getBuffer","clipId","preload","load","_setStatus","promises","map","clip","_loadAudio","catch","err","_complete","all","url","resources","audio","mp3","buffer","id"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AAGA,MAAMC,GAAG,GAAGD,KAAK,CAAC,iBAAD,CAAjB,C,CAEA;;AA0BA,OAAO,MAAME,cAAN,CAAqB;AAM1BC,EAAAA,WAAW,CACDC,QADC,EAEDC,QAFC,EAGT;AAAA,SAFQD,QAER,GAFQA,QAER;AAAA,SADQC,QACR,GADQA,QACR;AAAA,SARKC,MAQL;AAAA,SAPMC,KAON;AAAA,SANMC,SAMN;AAAA,SALMC,OAKN,GALqC,EAKrC;;AAAA,SAMKC,KANL,GAMyB,MAAMC,OAAO,CAACC,MAAR,EAN/B;;AACAX,IAAAA,GAAG,CAAC,wBAAD,CAAH;AACA,SAAKK,MAAL,GAAc;AAAEA,MAAAA,MAAM,EAAE;AAAV,KAAd;AACA,SAAKC,KAAL,GAAa,KAAKH,QAAL,CAAcS,KAAd,CAAoBC,MAAjC;AACA,SAAKN,SAAL,GAAiB,CAAjB;AACD;;AAGMO,EAAAA,SAAP,CAAiBC,MAAjB,EAAsC;AACpC,WAAO,KAAKP,OAAL,CAAaO,MAAb,CAAP;AACD;;AAEMC,EAAAA,OAAP,GAAiB;AACfhB,IAAAA,GAAG,CAAC,SAAD,CAAH,CADe,CAEf;AACD;;AAEMiB,EAAAA,IAAP,GAAc;AAAA,UACJX,KADI,GACiB,IADjB,CACJA,KADI;AAAA,UACGC,SADH,GACiB,IADjB,CACGA,SADH;;AAEZ,QAAID,KAAK,KAAKC,SAAd,EAAyB;AACvB;AACD;;AAED,SAAKW,UAAL,CAAgB;AAAEb,MAAAA,MAAM,EAAE,SAAV;AAAqBC,MAAAA,KAArB;AAA4BC,MAAAA,SAAS,EAAE;AAAvC,KAAhB;;AACA,UAAMK,KAAK,GAAG,KAAKT,QAAL,CAAcS,KAA5B;AACA,UAAMO,QAAQ,GAAGP,KAAK,CAACQ,GAAN,CAAUC,IAAI,IAC7B,KAAKC,UAAL,CAAgBD,IAAhB,EAAsBE,KAAtB,CAA4BC,GAAG,IAAI;AACjC,WAAKC,SAAL;;AACAzB,MAAAA,GAAG,CAAC,UAAD,EAAawB,GAAb,CAAH;AACD,KAHD,CADe,CAAjB;AAMA,WAAOd,OAAO,CAACgB,GAAR,CAAYP,QAAZ,CAAP;AACD,GAzCyB,CA2C1B;;;AACQD,EAAAA,UAAR,CAAmBb,MAAnB,EAA+C;AAC7C,SAAKA,MAAL,GAAcA,MAAd;AACA,SAAKD,QAAL,CAAcC,MAAd;AACD;;AAED,QAAciB,UAAd,CAAyBD,IAAzB,EAAqC;AACnC;AACA,UAAMM,GAAG,GAAGN,IAAI,CAACO,SAAL,CAAeC,KAAf,CAAqBC,GAAjC;AACA,UAAMC,MAAM,GAAG,MAAM,KAAKtB,KAAL,CAAWkB,GAAX,CAArB;AACA,SAAKnB,OAAL,CAAaa,IAAI,CAACW,EAAlB,IAAwBD,MAAxB;;AACA,SAAKN,SAAL,CAAeE,GAAf;;AAEA,WAAOI,MAAP;AACD;;AAEON,EAAAA,SAAR,CAAkBE,GAAlB,EAAgC;AAC9B,SAAKpB,SAAL,IAAkB,CAAlB;AACA,UAAMF,MAA0B,GAC9B,KAAKE,SAAL,IAAkB,KAAKD,KAAvB,GACI;AAAED,MAAAA,MAAM,EAAE,OAAV;AAAmBC,MAAAA,KAAK,EAAE,KAAKA;AAA/B,KADJ,GAEI;AAAED,MAAAA,MAAM,EAAE,SAAV;AAAqBC,MAAAA,KAAK,EAAE,KAAKA,KAAjC;AAAwCC,MAAAA,SAAS,EAAE,KAAKA;AAAxD,KAHN;;AAIA,SAAKW,UAAL,CAAgBb,MAAhB;AACD;;AAlEyB","sourcesContent":["import debug from \"debug\";\nimport { Audioset, Clip } from \"../audioset\";\n\nconst log = debug(\"atpls:resources\");\n\n// TODO: abstract the loader mechanism: { status, payload }\nexport interface LoadPending {\n  status: \"pending\";\n}\nexport interface LoadingResources {\n  status: \"loading\";\n  total: number;\n  completed: number;\n}\nexport interface ResourcesLoaded {\n  status: \"ready\";\n  total: number;\n}\nexport interface ResourceLoadError {\n  status: \"error\";\n  error: any;\n}\n\nexport type ResourceLoadStatus =\n  | LoadPending\n  | LoadingResources\n  | ResourcesLoaded\n  | ResourceLoadError;\n\nexport type FetchAudio = (url: string) => Promise<any>;\n\nexport class ResourceLoader {\n  public status: ResourceLoadStatus;\n  private total: number;\n  private completed: number;\n  private buffers: Record<string, any> = {};\n\n  constructor(\n    private audioset: Audioset,\n    private listener: (status: ResourceLoadStatus) => void,\n  ) {\n    log(\"creeate ResourceLoader\");\n    this.status = { status: \"pending\" };\n    this.total = this.audioset.clips.length;\n    this.completed = 0;\n  }\n  public fetch: FetchAudio = () => Promise.reject();\n\n  public getBuffer(clipId: string): any {\n    return this.buffers[clipId];\n  }\n\n  public preload() {\n    log(\"Preload\");\n    // preload images and maps\n  }\n\n  public load() {\n    const { total, completed } = this;\n    if (total === completed) {\n      return;\n    }\n\n    this._setStatus({ status: \"loading\", total, completed: 0 });\n    const clips = this.audioset.clips;\n    const promises = clips.map(clip =>\n      this._loadAudio(clip).catch(err => {\n        this._complete();\n        log(\"Error %o\", err);\n      }),\n    );\n    return Promise.all(promises);\n  }\n\n  //// PRIVATE ////\n  private _setStatus(status: ResourceLoadStatus) {\n    this.status = status;\n    this.listener(status);\n  }\n\n  private async _loadAudio(clip: Clip) {\n    // TODO: check other formats\n    const url = clip.resources.audio.mp3;\n    const buffer = await this.fetch(url);\n    this.buffers[clip.id] = buffer;\n    this._complete(url);\n\n    return buffer;\n  }\n\n  private _complete(url?: string) {\n    this.completed += 1;\n    const status: ResourceLoadStatus =\n      this.completed >= this.total\n        ? { status: \"ready\", total: this.total }\n        : { status: \"loading\", total: this.total, completed: this.completed };\n    this._setStatus(status);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}