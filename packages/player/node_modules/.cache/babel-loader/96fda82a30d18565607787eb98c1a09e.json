{"ast":null,"code":"import * as d3geo from \"d3-geo-projection\";\nimport * as d3 from \"d3\";\nimport { WORLDRATIO } from \"./dimensions\";\nexport function drawMap(container, countries, width, height, visuals) {\n  const scaleFactor = visuals.geomap.scaleFactor;\n  const center = visuals.geomap.center;\n  const scale = calculateMapScale(width, height);\n  const projector = createMapProjector(width, height, scale * scaleFactor, center);\n  const path = d3.geoPath().projection(projector);\n  container.selectAll(\".countries\").data(countries).enter().append(\"path\").attr(\"id\", d => \"country\".concat(d.id)).attr(\"class\", \"countries\").attr(\"d\", path).style(\"stroke\", \"#2c2c2c\").style(\"stroke-width\", 0.5).style(\"fill\", \"#888888\");\n}\nexport function createMapProjector(width, height, scale, center) {\n  return d3geo.geoRobinson().scale(scale).center([center.x, center.y]).translate([width / 2, height / 2]);\n}\nexport function calculateMapScale(width, height) {\n  const containerAspectRatio = width / height;\n  const mapWidth = containerAspectRatio < WORLDRATIO ? width : height * WORLDRATIO; // This is the scale needed for a world map drawn using the robinson projection to fit in a rectangle\n  // with a WORLDRATIO proportion, defined as width-dependent\n\n  const scale = mapWidth / 5.9;\n  return scale;\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/src/visuals/drawMap.ts"],"names":["d3geo","d3","WORLDRATIO","drawMap","container","countries","width","height","visuals","scaleFactor","geomap","center","scale","calculateMapScale","projector","createMapProjector","path","geoPath","projection","selectAll","data","enter","append","attr","d","id","style","geoRobinson","x","y","translate","containerAspectRatio","mapWidth"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,mBAAvB;AACA,OAAO,KAAKC,EAAZ,MAAoB,IAApB;AACA,SAASC,UAAT,QAA2B,cAA3B;AAGA,OAAO,SAASC,OAAT,CAAiBC,SAAjB,EAAiCC,SAAjC,EAAiDC,KAAjD,EAAgEC,MAAhE,EAAgFC,OAAhF,EAAqG;AAC1G,QAAMC,WAAW,GAAGD,OAAO,CAACE,MAAR,CAAeD,WAAnC;AACA,QAAME,MAAM,GAAGH,OAAO,CAACE,MAAR,CAAeC,MAA9B;AACA,QAAMC,KAAK,GAAGC,iBAAiB,CAACP,KAAD,EAAQC,MAAR,CAA/B;AAEA,QAAMO,SAAS,GAAGC,kBAAkB,CAACT,KAAD,EAAQC,MAAR,EAAgBK,KAAK,GAAGH,WAAxB,EAAqCE,MAArC,CAApC;AAEA,QAAMK,IAAI,GAAGf,EAAE,CAACgB,OAAH,GAAaC,UAAb,CAAwBJ,SAAxB,CAAb;AAEAV,EAAAA,SAAS,CACNe,SADH,CACa,YADb,EAEGC,IAFH,CAEQf,SAFR,EAGGgB,KAHH,GAIGC,MAJH,CAIU,MAJV,EAKGC,IALH,CAKQ,IALR,EAKeC,CAAD,qBAA8BA,CAAC,CAACC,EAAhC,CALd,EAMGF,IANH,CAMQ,OANR,EAMiB,WANjB,EAOGA,IAPH,CAOQ,GAPR,EAOaP,IAPb,EAQGU,KARH,CAQS,QART,EAQmB,SARnB,EASGA,KATH,CASS,cATT,EASyB,GATzB,EAUGA,KAVH,CAUS,MAVT,EAUiB,SAVjB;AAWD;AAED,OAAO,SAASX,kBAAT,CAA4BT,KAA5B,EAA2CC,MAA3C,EAA2DK,KAA3D,EAA0ED,MAA1E,EAAsG;AAC3G,SAAOX,KAAK,CAAC2B,WAAN,GAAoBf,KAApB,CAA0BA,KAA1B,EAAiCD,MAAjC,CAAwC,CAACA,MAAM,CAACiB,CAAR,EAAWjB,MAAM,CAACkB,CAAlB,CAAxC,EAA8DC,SAA9D,CAAwE,CAACxB,KAAK,GAAG,CAAT,EAAYC,MAAM,GAAG,CAArB,CAAxE,CAAP;AACD;AAED,OAAO,SAASM,iBAAT,CAA2BP,KAA3B,EAA0CC,MAA1C,EAA0D;AAC/D,QAAMwB,oBAAoB,GAAGzB,KAAK,GAAGC,MAArC;AACA,QAAMyB,QAAQ,GAAGD,oBAAoB,GAAG7B,UAAvB,GAAoCI,KAApC,GAA4CC,MAAM,GAAGL,UAAtE,CAF+D,CAI/D;AACA;;AACA,QAAMU,KAAK,GAAGoB,QAAQ,GAAG,GAAzB;AAEA,SAAOpB,KAAP;AACD","sourcesContent":["import * as d3geo from \"d3-geo-projection\";\nimport * as d3 from \"d3\";\nimport { WORLDRATIO } from \"./dimensions\";\nimport { MapVisuals } from \"../Audioset\";\n\nexport function drawMap(container: any, countries: any, width: number, height: number, visuals: MapVisuals) {\n  const scaleFactor = visuals.geomap.scaleFactor;\n  const center = visuals.geomap.center;\n  const scale = calculateMapScale(width, height);\n\n  const projector = createMapProjector(width, height, scale * scaleFactor, center);\n\n  const path = d3.geoPath().projection(projector);\n\n  container\n    .selectAll(\".countries\")\n    .data(countries)\n    .enter()\n    .append(\"path\")\n    .attr(\"id\", (d: { id: any }) => `country${d.id}`)\n    .attr(\"class\", \"countries\")\n    .attr(\"d\", path)\n    .style(\"stroke\", \"#2c2c2c\")\n    .style(\"stroke-width\", 0.5)\n    .style(\"fill\", \"#888888\");\n}\n\nexport function createMapProjector(width: number, height: number, scale: number, center: { x: any; y: any }) {\n  return d3geo.geoRobinson().scale(scale).center([center.x, center.y]).translate([width / 2, height / 2]);\n}\n\nexport function calculateMapScale(width: number, height: number) {\n  const containerAspectRatio = width / height;\n  const mapWidth = containerAspectRatio < WORLDRATIO ? width : height * WORLDRATIO;\n\n  // This is the scale needed for a world map drawn using the robinson projection to fit in a rectangle\n  // with a WORLDRATIO proportion, defined as width-dependent\n  const scale = mapWidth / 5.9;\n\n  return scale;\n}\n"]},"metadata":{},"sourceType":"module"}