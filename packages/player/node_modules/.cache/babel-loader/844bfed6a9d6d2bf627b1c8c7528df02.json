{"ast":null,"code":"import { transform } from \"topojson-client\";\nimport newHeap from \"./heap\";\nimport { planarTriangleArea } from \"./planar\";\n\nfunction copy(point) {\n  return [point[0], point[1], 0];\n}\n\nexport default function (topology, weight) {\n  var point = topology.transform ? transform(topology.transform) : copy,\n      heap = newHeap();\n  if (weight == null) weight = planarTriangleArea;\n  var arcs = topology.arcs.map(function (arc) {\n    var triangles = [],\n        maxWeight = 0,\n        triangle,\n        i,\n        n;\n    arc = arc.map(point);\n\n    for (i = 1, n = arc.length - 1; i < n; ++i) {\n      triangle = [arc[i - 1], arc[i], arc[i + 1]];\n      triangle[1][2] = weight(triangle);\n      triangles.push(triangle);\n      heap.push(triangle);\n    } // Always keep the arc endpoints!\n\n\n    arc[0][2] = arc[n][2] = Infinity;\n\n    for (i = 0, n = triangles.length; i < n; ++i) {\n      triangle = triangles[i];\n      triangle.previous = triangles[i - 1];\n      triangle.next = triangles[i + 1];\n    }\n\n    while (triangle = heap.pop()) {\n      var previous = triangle.previous,\n          next = triangle.next; // If the weight of the current point is less than that of the previous\n      // point to be eliminated, use the latter’s weight instead. This ensures\n      // that the current point cannot be eliminated without eliminating\n      // previously- eliminated points.\n\n      if (triangle[1][2] < maxWeight) triangle[1][2] = maxWeight;else maxWeight = triangle[1][2];\n\n      if (previous) {\n        previous.next = next;\n        previous[2] = triangle[2];\n        update(previous);\n      }\n\n      if (next) {\n        next.previous = previous;\n        next[0] = triangle[0];\n        update(next);\n      }\n    }\n\n    return arc;\n  });\n\n  function update(triangle) {\n    heap.remove(triangle);\n    triangle[1][2] = weight(triangle);\n    heap.push(triangle);\n  }\n\n  return {\n    type: \"Topology\",\n    bbox: topology.bbox,\n    objects: topology.objects,\n    arcs: arcs\n  };\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/topojson-simplify/src/presimplify.js"],"names":["transform","newHeap","planarTriangleArea","copy","point","topology","weight","heap","arcs","map","arc","triangles","maxWeight","triangle","i","n","length","push","Infinity","previous","next","pop","update","remove","type","bbox","objects"],"mappings":"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","sourcesContent":["import {transform} from \"topojson-client\";\nimport newHeap from \"./heap\";\nimport {planarTriangleArea} from \"./planar\";\n\nfunction copy(point) {\n  return [point[0], point[1], 0];\n}\n\nexport default function(topology, weight) {\n  var point = topology.transform ? transform(topology.transform) : copy,\n      heap = newHeap();\n\n  if (weight == null) weight = planarTriangleArea;\n\n  var arcs = topology.arcs.map(function(arc) {\n    var triangles = [],\n        maxWeight = 0,\n        triangle,\n        i,\n        n;\n\n    arc = arc.map(point);\n\n    for (i = 1, n = arc.length - 1; i < n; ++i) {\n      triangle = [arc[i - 1], arc[i], arc[i + 1]];\n      triangle[1][2] = weight(triangle);\n      triangles.push(triangle);\n      heap.push(triangle);\n    }\n\n    // Always keep the arc endpoints!\n    arc[0][2] = arc[n][2] = Infinity;\n\n    for (i = 0, n = triangles.length; i < n; ++i) {\n      triangle = triangles[i];\n      triangle.previous = triangles[i - 1];\n      triangle.next = triangles[i + 1];\n    }\n\n    while (triangle = heap.pop()) {\n      var previous = triangle.previous,\n          next = triangle.next;\n\n      // If the weight of the current point is less than that of the previous\n      // point to be eliminated, use the latter’s weight instead. This ensures\n      // that the current point cannot be eliminated without eliminating\n      // previously- eliminated points.\n      if (triangle[1][2] < maxWeight) triangle[1][2] = maxWeight;\n      else maxWeight = triangle[1][2];\n\n      if (previous) {\n        previous.next = next;\n        previous[2] = triangle[2];\n        update(previous);\n      }\n\n      if (next) {\n        next.previous = previous;\n        next[0] = triangle[0];\n        update(next);\n      }\n    }\n\n    return arc;\n  });\n\n  function update(triangle) {\n    heap.remove(triangle);\n    triangle[1][2] = weight(triangle);\n    heap.push(triangle);\n  }\n\n  return {\n    type: \"Topology\",\n    bbox: topology.bbox,\n    objects: topology.objects,\n    arcs: arcs\n  };\n}\n"]},"metadata":{},"sourceType":"module"}