{"ast":null,"code":"import { abs, epsilon, epsilon2 } from \"./math.js\"; // Approximate Newton-Raphson\n// Solve f(x) = y, start from x\n\nexport function solve(f, y, x) {\n  var steps = 100,\n      delta,\n      f0,\n      f1;\n  x = x === undefined ? 0 : +x;\n  y = +y;\n\n  do {\n    f0 = f(x);\n    f1 = f(x + epsilon);\n    if (f0 === f1) f1 = f0 + epsilon;\n    x -= delta = -1 * epsilon * (f0 - y) / (f0 - f1);\n  } while (steps-- > 0 && abs(delta) > epsilon);\n\n  return steps < 0 ? NaN : x;\n} // Approximate Newton-Raphson in 2D\n// Solve f(a,b) = [x,y]\n\nexport function solve2d(f, MAX_ITERATIONS, eps) {\n  if (MAX_ITERATIONS === undefined) MAX_ITERATIONS = 40;\n  if (eps === undefined) eps = epsilon2;\n  return function (x, y, a, b) {\n    var err2, da, db;\n    a = a === undefined ? 0 : +a;\n    b = b === undefined ? 0 : +b;\n\n    for (var i = 0; i < MAX_ITERATIONS; i++) {\n      var p = f(a, b),\n          // diffs\n      tx = p[0] - x,\n          ty = p[1] - y;\n      if (abs(tx) < eps && abs(ty) < eps) break; // we're there!\n      // backtrack if we overshot\n\n      var h = tx * tx + ty * ty;\n\n      if (h > err2) {\n        a -= da /= 2;\n        b -= db /= 2;\n        continue;\n      }\n\n      err2 = h; // partial derivatives\n\n      var ea = (a > 0 ? -1 : 1) * eps,\n          eb = (b > 0 ? -1 : 1) * eps,\n          pa = f(a + ea, b),\n          pb = f(a, b + eb),\n          dxa = (pa[0] - p[0]) / ea,\n          dya = (pa[1] - p[1]) / ea,\n          dxb = (pb[0] - p[0]) / eb,\n          dyb = (pb[1] - p[1]) / eb,\n          // determinant\n      D = dyb * dxa - dya * dxb,\n          // newton step — or half-step for small D\n      l = (abs(D) < 0.5 ? 0.5 : 1) / D;\n      da = (ty * dxb - tx * dyb) * l;\n      db = (tx * dya - ty * dxa) * l;\n      a += da;\n      b += db;\n      if (abs(da) < eps && abs(db) < eps) break; // we're crawling\n    }\n\n    return [a, b];\n  };\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/d3-geo-projection/src/newton.js"],"names":["abs","epsilon","epsilon2","solve","f","y","x","steps","delta","f0","f1","undefined","NaN","solve2d","MAX_ITERATIONS","eps","a","b","err2","da","db","i","p","tx","ty","h","ea","eb","pa","pb","dxa","dya","dxb","dyb","D","l"],"mappings":"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","sourcesContent":["import {abs, epsilon, epsilon2} from \"./math.js\";\n\n// Approximate Newton-Raphson\n// Solve f(x) = y, start from x\nexport function solve(f, y, x) {\n  var steps = 100, delta, f0, f1;\n  x = x === undefined ? 0 : +x;\n  y = +y;\n  do {\n    f0 = f(x);\n    f1 = f(x + epsilon);\n    if (f0 === f1) f1 = f0 + epsilon;\n    x -= delta = (-1 * epsilon * (f0 - y)) / (f0 - f1);\n  } while (steps-- > 0 && abs(delta) > epsilon);\n  return steps < 0 ? NaN : x;\n}\n\n// Approximate Newton-Raphson in 2D\n// Solve f(a,b) = [x,y]\nexport function solve2d(f, MAX_ITERATIONS, eps) {\n  if (MAX_ITERATIONS === undefined) MAX_ITERATIONS = 40;\n  if (eps === undefined) eps = epsilon2;\n  return function(x, y, a, b) {\n    var err2, da, db;\n    a = a === undefined ? 0 : +a;\n    b = b === undefined ? 0 : +b;\n    for (var i = 0; i < MAX_ITERATIONS; i++) {\n      var p = f(a, b),\n        // diffs\n        tx = p[0] - x,\n        ty = p[1] - y;\n      if (abs(tx) < eps && abs(ty) < eps) break; // we're there!\n\n      // backtrack if we overshot\n      var h = tx * tx + ty * ty;\n      if (h > err2) {\n        a -= da /= 2;\n        b -= db /= 2;\n        continue;\n      }\n      err2 = h;\n\n      // partial derivatives\n      var ea = (a > 0 ? -1 : 1) * eps,\n        eb = (b > 0 ? -1 : 1) * eps,\n        pa = f(a + ea, b),\n        pb = f(a, b + eb),\n        dxa = (pa[0] - p[0]) / ea,\n        dya = (pa[1] - p[1]) / ea,\n        dxb = (pb[0] - p[0]) / eb,\n        dyb = (pb[1] - p[1]) / eb,\n        // determinant\n        D = dyb * dxa - dya * dxb,\n        // newton step — or half-step for small D\n        l = (abs(D) < 0.5 ? 0.5 : 1) / D;\n      da = (ty * dxb - tx * dyb) * l;\n      db = (tx * dya - ty * dxa) * l;\n      a += da;\n      b += db;\n      if (abs(da) < eps && abs(db) < eps) break; // we're crawling\n    }\n    return [a, b];\n  };\n}"]},"metadata":{},"sourceType":"module"}