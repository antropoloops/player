{"ast":null,"code":"import { AutomationEventList } from 'automation-events';\nexport const createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor) => {\n  return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {\n    const automationEventList = new AutomationEventList(nativeAudioParam.defaultValue);\n    const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n    const audioParam = {\n      get defaultValue() {\n        return nativeAudioParam.defaultValue;\n      },\n\n      get maxValue() {\n        return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n      },\n\n      get minValue() {\n        return minValue === null ? nativeAudioParam.minValue : minValue;\n      },\n\n      get value() {\n        return nativeAudioParam.value;\n      },\n\n      set value(value) {\n        nativeAudioParam.value = value; // Bug #98: Edge, Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n\n        audioParam.setValueAtTime(value, audioNode.context.currentTime);\n      },\n\n      cancelAndHoldAtTime(cancelTime) {\n        // Bug #28: Edge, Firefox & Safari do not yet implement cancelAndHoldAtTime().\n        if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n          nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n        } else {\n          const previousLastEvent = Array.from(automationEventList).pop();\n\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n          const currentLastEvent = Array.from(automationEventList).pop();\n          nativeAudioParam.cancelScheduledValues(cancelTime);\n\n          if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n            if (currentLastEvent.type === 'exponentialRampToValue') {\n              nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n            } else if (currentLastEvent.type === 'linearRampToValue') {\n              nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n            } else if (currentLastEvent.type === 'setValue') {\n              nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n            } else if (currentLastEvent.type === 'setValueCurve') {\n              nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n            }\n          }\n        }\n\n        return audioParam;\n      },\n\n      cancelScheduledValues(cancelTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n        nativeAudioParam.cancelScheduledValues(cancelTime);\n        return audioParam;\n      },\n\n      exponentialRampToValueAtTime(value, endTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n        nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n        return audioParam;\n      },\n\n      linearRampToValueAtTime(value, endTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n        nativeAudioParam.linearRampToValueAtTime(value, endTime);\n        return audioParam;\n      },\n\n      setTargetAtTime(target, startTime, timeConstant) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n        nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n        return audioParam;\n      },\n\n      setValueAtTime(value, startTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createSetValueAutomationEvent(value, startTime));\n        nativeAudioParam.setValueAtTime(value, startTime);\n        return audioParam;\n      },\n\n      setValueCurveAtTime(values, startTime, duration) {\n        /*\n         * Bug #152: Safari does not correctly interpolate the values of the curve.\n         * @todo Unfortunately there is no way to test for this behavior in synchronous fashion which is why testing for the\n         * existence of the webkitAudioContext is used as a workaround here.\n         */\n        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n          const endTime = startTime + duration;\n          const sampleRate = audioNode.context.sampleRate;\n          const firstSample = Math.ceil(startTime * sampleRate);\n          const lastSample = Math.floor(endTime * sampleRate);\n          const numberOfInterpolatedValues = lastSample - firstSample;\n          const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n\n          for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n            const theoreticIndex = (values.length - 1) / duration * ((firstSample + i) / sampleRate - startTime);\n            const lowerIndex = Math.floor(theoreticIndex);\n            const upperIndex = Math.ceil(theoreticIndex);\n            interpolatedValues[i] = lowerIndex === upperIndex ? values[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n          }\n\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n          nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n          const timeOfLastSample = lastSample / sampleRate;\n\n          if (timeOfLastSample < endTime) {\n            audioParam.setValueAtTime(interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n          }\n\n          audioParam.setValueAtTime(values[values.length - 1], endTime);\n        } else {\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createSetValueCurveAutomationEvent(values, startTime, duration));\n          nativeAudioParam.setValueCurveAtTime(values, startTime, duration);\n        }\n\n        return audioParam;\n      }\n\n    };\n    audioParamStore.set(audioParam, nativeAudioParam);\n    audioParamAudioNodeStore.set(audioParam, audioNode);\n    addAudioParamConnections(audioParam, audioParamRenderer);\n    return audioParam;\n  };\n};","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/standardized-audio-context/build/es2018/factories/audio-param-factory.js"],"names":["AutomationEventList","createAudioParamFactory","addAudioParamConnections","audioParamAudioNodeStore","audioParamStore","createAudioParamRenderer","createCancelAndHoldAutomationEvent","createCancelScheduledValuesAutomationEvent","createExponentialRampToValueAutomationEvent","createLinearRampToValueAutomationEvent","createSetTargetAutomationEvent","createSetValueAutomationEvent","createSetValueCurveAutomationEvent","nativeAudioContextConstructor","audioNode","isAudioParamOfOfflineAudioContext","nativeAudioParam","maxValue","minValue","automationEventList","defaultValue","audioParamRenderer","audioParam","value","setValueAtTime","context","currentTime","cancelAndHoldAtTime","cancelTime","flush","add","previousLastEvent","Array","from","pop","currentLastEvent","cancelScheduledValues","undefined","type","exponentialRampToValueAtTime","endTime","linearRampToValueAtTime","startTime","setValueCurveAtTime","values","duration","setTargetAtTime","target","timeConstant","name","sampleRate","firstSample","Math","ceil","lastSample","floor","numberOfInterpolatedValues","interpolatedValues","Float32Array","i","theoreticIndex","length","lowerIndex","upperIndex","timeOfLastSample","set"],"mappings":"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","sourcesContent":["import { AutomationEventList } from 'automation-events';\nexport const createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor) => {\n    return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {\n        const automationEventList = new AutomationEventList(nativeAudioParam.defaultValue);\n        const audioParamRenderer = (isAudioParamOfOfflineAudioContext) ? createAudioParamRenderer(automationEventList) : null;\n        const audioParam = {\n            get defaultValue() {\n                return nativeAudioParam.defaultValue;\n            },\n            get maxValue() {\n                return (maxValue === null) ? nativeAudioParam.maxValue : maxValue;\n            },\n            get minValue() {\n                return (minValue === null) ? nativeAudioParam.minValue : minValue;\n            },\n            get value() {\n                return nativeAudioParam.value;\n            },\n            set value(value) {\n                nativeAudioParam.value = value;\n                // Bug #98: Edge, Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n                audioParam.setValueAtTime(value, audioNode.context.currentTime);\n            },\n            cancelAndHoldAtTime(cancelTime) {\n                // Bug #28: Edge, Firefox & Safari do not yet implement cancelAndHoldAtTime().\n                if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n                }\n                else {\n                    const previousLastEvent = Array\n                        .from(automationEventList)\n                        .pop();\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    const currentLastEvent = Array\n                        .from(automationEventList)\n                        .pop();\n                    nativeAudioParam.cancelScheduledValues(cancelTime);\n                    if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n                        if (currentLastEvent.type === 'exponentialRampToValue') {\n                            nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'linearRampToValue') {\n                            nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'setValue') {\n                            nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n                        }\n                        else if (currentLastEvent.type === 'setValueCurve') {\n                            nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n                        }\n                    }\n                }\n                return audioParam;\n            },\n            cancelScheduledValues(cancelTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n                nativeAudioParam.cancelScheduledValues(cancelTime);\n                return audioParam;\n            },\n            exponentialRampToValueAtTime(value, endTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            linearRampToValueAtTime(value, endTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.linearRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            setTargetAtTime(target, startTime, timeConstant) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n                return audioParam;\n            },\n            setValueAtTime(value, startTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetValueAutomationEvent(value, startTime));\n                nativeAudioParam.setValueAtTime(value, startTime);\n                return audioParam;\n            },\n            setValueCurveAtTime(values, startTime, duration) {\n                /*\n                 * Bug #152: Safari does not correctly interpolate the values of the curve.\n                 * @todo Unfortunately there is no way to test for this behavior in synchronous fashion which is why testing for the\n                 * existence of the webkitAudioContext is used as a workaround here.\n                 */\n                if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                    const endTime = startTime + duration;\n                    const sampleRate = audioNode.context.sampleRate;\n                    const firstSample = Math.ceil(startTime * sampleRate);\n                    const lastSample = Math.floor((endTime) * sampleRate);\n                    const numberOfInterpolatedValues = lastSample - firstSample;\n                    const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n                    for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n                        const theoreticIndex = ((values.length - 1) / duration) * (((firstSample + i) / sampleRate) - startTime);\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        interpolatedValues[i] = (lowerIndex === upperIndex)\n                            ? values[lowerIndex]\n                            : ((1 - (theoreticIndex - lowerIndex)) * values[lowerIndex])\n                                + ((1 - (upperIndex - theoreticIndex)) * values[upperIndex]);\n                    }\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n                    const timeOfLastSample = lastSample / sampleRate;\n                    if (timeOfLastSample < endTime) {\n                        audioParam.setValueAtTime(interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n                    }\n                    audioParam.setValueAtTime(values[values.length - 1], endTime);\n                }\n                else {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(values, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(values, startTime, duration);\n                }\n                return audioParam;\n            }\n        };\n        audioParamStore.set(audioParam, nativeAudioParam);\n        audioParamAudioNodeStore.set(audioParam, audioNode);\n        addAudioParamConnections(audioParam, audioParamRenderer);\n        return audioParam;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-param-factory.js.map"]},"metadata":{},"sourceType":"module"}