{"ast":null,"code":"import _slicedToArray from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { isNativeAudioNode } from '../guards/native-audio-node';\nexport const wrapAudioNodeDisconnectMethod = nativeAudioNode => {\n  const connections = new Map();\n\n  nativeAudioNode.connect = (connect => {\n    return (destination, output = 0, input = 0) => {\n      const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output); // Save the new connection only if the calls to connect above didn't throw an error.\n\n      const connectionsToDestination = connections.get(destination);\n\n      if (connectionsToDestination === undefined) {\n        connections.set(destination, [{\n          input,\n          output\n        }]);\n      } else {\n        if (connectionsToDestination.every(connection => connection.input !== input || connection.output !== output)) {\n          connectionsToDestination.push({\n            input,\n            output\n          });\n        }\n      }\n\n      return returnValue;\n    };\n  })(nativeAudioNode.connect.bind(nativeAudioNode));\n\n  nativeAudioNode.disconnect = (disconnect => {\n    return (destinationOrOutput, output, input) => {\n      disconnect.apply(nativeAudioNode);\n\n      if (destinationOrOutput === undefined) {\n        connections.clear();\n      } else if (typeof destinationOrOutput === 'number') {\n        for (const _ref of connections) {\n          var _ref2 = _slicedToArray(_ref, 2);\n\n          const destination = _ref2[0];\n          const connectionsToDestination = _ref2[1];\n          const filteredConnections = connectionsToDestination.filter(connection => connection.output !== destinationOrOutput);\n\n          if (filteredConnections.length === 0) {\n            connections.delete(destination);\n          } else {\n            connections.set(destination, filteredConnections);\n          }\n        }\n      } else if (connections.has(destinationOrOutput)) {\n        if (output === undefined) {\n          connections.delete(destinationOrOutput);\n        } else {\n          const connectionsToDestination = connections.get(destinationOrOutput);\n\n          if (connectionsToDestination !== undefined) {\n            const filteredConnections = connectionsToDestination.filter(connection => connection.output !== output && (connection.input !== input || input === undefined));\n\n            if (filteredConnections.length === 0) {\n              connections.delete(destinationOrOutput);\n            } else {\n              connections.set(destinationOrOutput, filteredConnections);\n            }\n          }\n        }\n      }\n\n      for (const _ref3 of connections) {\n        var _ref4 = _slicedToArray(_ref3, 2);\n\n        const destination = _ref4[0];\n        const connectionsToDestination = _ref4[1];\n        connectionsToDestination.forEach(connection => {\n          if (isNativeAudioNode(destination)) {\n            nativeAudioNode.connect(destination, connection.output, connection.input);\n          } else {\n            nativeAudioNode.connect(destination, connection.output);\n          }\n        });\n      }\n    };\n  })(nativeAudioNode.disconnect);\n};","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-node-disconnect-method.js"],"names":["isNativeAudioNode","wrapAudioNodeDisconnectMethod","nativeAudioNode","connections","Map","connect","destination","output","input","returnValue","connectionsToDestination","get","undefined","set","every","connection","push","bind","disconnect","destinationOrOutput","apply","clear","filteredConnections","filter","length","delete","has","forEach"],"mappings":";AAAA,SAASA,iBAAT,QAAkC,6BAAlC;AACA,OAAO,MAAMC,6BAA6B,GAAIC,eAAD,IAAqB;AAC9D,QAAMC,WAAW,GAAG,IAAIC,GAAJ,EAApB;;AACAF,EAAAA,eAAe,CAACG,OAAhB,GAA0B,CAAEA,OAAD,IAAa;AACpC,WAAO,CAACC,WAAD,EAAcC,MAAM,GAAG,CAAvB,EAA0BC,KAAK,GAAG,CAAlC,KAAwC;AAC3C,YAAMC,WAAW,GAAIT,iBAAiB,CAACM,WAAD,CAAlB,GACdD,OAAO,CAACC,WAAD,EAAcC,MAAd,EAAsBC,KAAtB,CADO,GAEdH,OAAO,CAACC,WAAD,EAAcC,MAAd,CAFb,CAD2C,CAI3C;;AACA,YAAMG,wBAAwB,GAAGP,WAAW,CAACQ,GAAZ,CAAgBL,WAAhB,CAAjC;;AACA,UAAII,wBAAwB,KAAKE,SAAjC,EAA4C;AACxCT,QAAAA,WAAW,CAACU,GAAZ,CAAgBP,WAAhB,EAA6B,CAAC;AAAEE,UAAAA,KAAF;AAASD,UAAAA;AAAT,SAAD,CAA7B;AACH,OAFD,MAGK;AACD,YAAIG,wBAAwB,CAACI,KAAzB,CAAgCC,UAAD,IAAiBA,UAAU,CAACP,KAAX,KAAqBA,KAArB,IAA8BO,UAAU,CAACR,MAAX,KAAsBA,MAApG,CAAJ,EAAkH;AAC9GG,UAAAA,wBAAwB,CAACM,IAAzB,CAA8B;AAAER,YAAAA,KAAF;AAASD,YAAAA;AAAT,WAA9B;AACH;AACJ;;AACD,aAAOE,WAAP;AACH,KAfD;AAgBH,GAjByB,EAiBvBP,eAAe,CAACG,OAAhB,CAAwBY,IAAxB,CAA6Bf,eAA7B,CAjBuB,CAA1B;;AAkBAA,EAAAA,eAAe,CAACgB,UAAhB,GAA6B,CAAEA,UAAD,IAAgB;AAC1C,WAAO,CAACC,mBAAD,EAAsBZ,MAAtB,EAA8BC,KAA9B,KAAwC;AAC3CU,MAAAA,UAAU,CAACE,KAAX,CAAiBlB,eAAjB;;AACA,UAAIiB,mBAAmB,KAAKP,SAA5B,EAAuC;AACnCT,QAAAA,WAAW,CAACkB,KAAZ;AACH,OAFD,MAGK,IAAI,OAAOF,mBAAP,KAA+B,QAAnC,EAA6C;AAC9C,2BAAsDhB,WAAtD,EAAmE;AAAA;;AAAA,gBAAvDG,WAAuD;AAAA,gBAA1CI,wBAA0C;AAC/D,gBAAMY,mBAAmB,GAAGZ,wBAAwB,CAC/Ca,MADuB,CACfR,UAAD,IAAiBA,UAAU,CAACR,MAAX,KAAsBY,mBADvB,CAA5B;;AAEA,cAAIG,mBAAmB,CAACE,MAApB,KAA+B,CAAnC,EAAsC;AAClCrB,YAAAA,WAAW,CAACsB,MAAZ,CAAmBnB,WAAnB;AACH,WAFD,MAGK;AACDH,YAAAA,WAAW,CAACU,GAAZ,CAAgBP,WAAhB,EAA6BgB,mBAA7B;AACH;AACJ;AACJ,OAXI,MAYA,IAAInB,WAAW,CAACuB,GAAZ,CAAgBP,mBAAhB,CAAJ,EAA0C;AAC3C,YAAIZ,MAAM,KAAKK,SAAf,EAA0B;AACtBT,UAAAA,WAAW,CAACsB,MAAZ,CAAmBN,mBAAnB;AACH,SAFD,MAGK;AACD,gBAAMT,wBAAwB,GAAGP,WAAW,CAACQ,GAAZ,CAAgBQ,mBAAhB,CAAjC;;AACA,cAAIT,wBAAwB,KAAKE,SAAjC,EAA4C;AACxC,kBAAMU,mBAAmB,GAAGZ,wBAAwB,CAC/Ca,MADuB,CACfR,UAAD,IAAiBA,UAAU,CAACR,MAAX,KAAsBA,MAAtB,KAAiCQ,UAAU,CAACP,KAAX,KAAqBA,KAArB,IAA8BA,KAAK,KAAKI,SAAzE,CADD,CAA5B;;AAEA,gBAAIU,mBAAmB,CAACE,MAApB,KAA+B,CAAnC,EAAsC;AAClCrB,cAAAA,WAAW,CAACsB,MAAZ,CAAmBN,mBAAnB;AACH,aAFD,MAGK;AACDhB,cAAAA,WAAW,CAACU,GAAZ,CAAgBM,mBAAhB,EAAqCG,mBAArC;AACH;AACJ;AACJ;AACJ;;AACD,0BAAsDnB,WAAtD,EAAmE;AAAA;;AAAA,cAAvDG,WAAuD;AAAA,cAA1CI,wBAA0C;AAC/DA,QAAAA,wBAAwB,CACnBiB,OADL,CACcZ,UAAD,IAAgB;AACzB,cAAIf,iBAAiB,CAACM,WAAD,CAArB,EAAoC;AAChCJ,YAAAA,eAAe,CAACG,OAAhB,CAAwBC,WAAxB,EAAqCS,UAAU,CAACR,MAAhD,EAAwDQ,UAAU,CAACP,KAAnE;AACH,WAFD,MAGK;AACDN,YAAAA,eAAe,CAACG,OAAhB,CAAwBC,WAAxB,EAAqCS,UAAU,CAACR,MAAhD;AACH;AACJ,SARD;AASH;AACJ,KA9CD;AA+CH,GAhD4B,EAgD1BL,eAAe,CAACgB,UAhDU,CAA7B;AAiDH,CArEM","sourcesContent":["import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const wrapAudioNodeDisconnectMethod = (nativeAudioNode) => {\n    const connections = new Map();\n    nativeAudioNode.connect = ((connect) => {\n        return (destination, output = 0, input = 0) => {\n            const returnValue = (isNativeAudioNode(destination))\n                ? connect(destination, output, input)\n                : connect(destination, output);\n            // Save the new connection only if the calls to connect above didn't throw an error.\n            const connectionsToDestination = connections.get(destination);\n            if (connectionsToDestination === undefined) {\n                connections.set(destination, [{ input, output }]);\n            }\n            else {\n                if (connectionsToDestination.every((connection) => (connection.input !== input || connection.output !== output))) {\n                    connectionsToDestination.push({ input, output });\n                }\n            }\n            return returnValue;\n        };\n    })(nativeAudioNode.connect.bind(nativeAudioNode));\n    nativeAudioNode.disconnect = ((disconnect) => {\n        return (destinationOrOutput, output, input) => {\n            disconnect.apply(nativeAudioNode);\n            if (destinationOrOutput === undefined) {\n                connections.clear();\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                for (const [destination, connectionsToDestination] of connections) {\n                    const filteredConnections = connectionsToDestination\n                        .filter((connection) => (connection.output !== destinationOrOutput));\n                    if (filteredConnections.length === 0) {\n                        connections.delete(destination);\n                    }\n                    else {\n                        connections.set(destination, filteredConnections);\n                    }\n                }\n            }\n            else if (connections.has(destinationOrOutput)) {\n                if (output === undefined) {\n                    connections.delete(destinationOrOutput);\n                }\n                else {\n                    const connectionsToDestination = connections.get(destinationOrOutput);\n                    if (connectionsToDestination !== undefined) {\n                        const filteredConnections = connectionsToDestination\n                            .filter((connection) => (connection.output !== output && (connection.input !== input || input === undefined)));\n                        if (filteredConnections.length === 0) {\n                            connections.delete(destinationOrOutput);\n                        }\n                        else {\n                            connections.set(destinationOrOutput, filteredConnections);\n                        }\n                    }\n                }\n            }\n            for (const [destination, connectionsToDestination] of connections) {\n                connectionsToDestination\n                    .forEach((connection) => {\n                    if (isNativeAudioNode(destination)) {\n                        nativeAudioNode.connect(destination, connection.output, connection.input);\n                    }\n                    else {\n                        nativeAudioNode.connect(destination, connection.output);\n                    }\n                });\n            }\n        };\n    })(nativeAudioNode.disconnect);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-node-disconnect-method.js.map"]},"metadata":{},"sourceType":"module"}