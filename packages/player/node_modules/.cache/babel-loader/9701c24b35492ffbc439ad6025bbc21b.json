{"ast":null,"code":"import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\n\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n  // Ceil the length to the next full render quantum.\n  // Bug #17: Safari does not yet expose the length.\n  const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n  const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n  const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n  const processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n\n  if (processorConstructor === undefined) {\n    throw new Error('Missing the processor constructor.');\n  }\n\n  const audioNodeConnections = getAudioNodeConnections(proxy);\n  const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n  const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n  const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n  const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs,\n    [name]: new Float32Array(128)\n  }), {});\n\n  for (let i = 0; i < length; i += 128) {\n    if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n      for (let j = 0; j < options.numberOfInputs; j += 1) {\n        for (let k = 0; k < options.channelCount; k += 1) {\n          copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n        }\n      }\n    }\n\n    if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n      processorConstructor.parameterDescriptors.forEach(({\n        name\n      }, index) => {\n        copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n      });\n    }\n\n    for (let j = 0; j < options.numberOfInputs; j += 1) {\n      for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (outputs[j][k].byteLength === 0) {\n          outputs[j][k] = new Float32Array(128);\n        }\n      }\n    }\n\n    try {\n      const potentiallyEmptyInputs = inputs.map((input, index) => {\n        if (audioNodeConnections.activeInputs[index].size === 0) {\n          return [new Float32Array(0)];\n        }\n\n        return input;\n      });\n      const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n\n      if (processedBuffer !== null) {\n        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n          for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n            copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n          }\n\n          outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n        }\n      }\n\n      if (!activeSourceFlag) {\n        break;\n      }\n    } catch (error) {\n      proxy.dispatchEvent(new ErrorEvent('processorerror', {\n        error\n      }));\n      break;\n    }\n  }\n\n  return processedBuffer;\n};\n\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n  return (name, options, processorConstructor) => {\n    const renderedNativeAudioNodes = new WeakMap();\n    let processedBufferPromise = null;\n\n    const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n      let nativeOutputNodes = null;\n      const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext); // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n\n      if (nativeAudioWorkletNodeConstructor === null) {\n        const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n          channelCount: Math.max(1, numberOfOutputChannels),\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n\n        for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n          outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: options.outputChannelCount[i]\n          }));\n        } // Bug #87: Expose at least one output to make this node connectable.\n\n\n        const outputAudioNodes = options.numberOfOutputs === 0 ? [outputChannelSplitterNode] : outputChannelMergerNodes;\n        const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n          channelCount: options.channelCount,\n          channelCountMode: options.channelCountMode,\n          channelInterpretation: options.channelInterpretation,\n          gain: 1\n        });\n        outputGainNode.connect = connectMultipleOutputs.bind(null, outputAudioNodes);\n        outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputAudioNodes);\n        nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n      } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n        nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n      }\n\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n\n      if (nativeOutputNodes !== null) {\n        if (processedBufferPromise === null) {\n          if (processorConstructor === undefined) {\n            throw new Error('Missing the processor constructor.');\n          }\n\n          if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n          } // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n\n\n          const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n          const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n          const numberOfChannels = numberOfInputChannels + numberOfParameters;\n\n          const renderBuffer = async () => {\n            const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, // Ceil the length to the next full render quantum.\n            // Bug #17: Safari does not yet expose the length.\n            Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n            const gainNodes = [];\n            const inputChannelSplitterNodes = [];\n\n            for (let i = 0; i < options.numberOfInputs; i += 1) {\n              gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n              }));\n              inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n              }));\n            }\n\n            const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async audioParam => {\n              const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                offset: audioParam.value\n              });\n              await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace);\n              return constantSourceNode;\n            }));\n            const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n              channelCount: 1,\n              channelCountMode: 'explicit',\n              channelInterpretation: 'speakers',\n              numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n            });\n\n            for (let i = 0; i < options.numberOfInputs; i += 1) {\n              gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n              for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n              }\n            }\n\n            for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n              constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n              constantSourceNode.start(0);\n            }\n\n            inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n            await Promise.all(gainNodes.map(gainNode => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace)));\n            return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n          };\n\n          processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime);\n        }\n\n        const processedBuffer = await processedBufferPromise;\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);\n        const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n\n        if (processedBuffer !== null) {\n          audioBufferSourceNode.buffer = processedBuffer;\n          audioBufferSourceNode.start(0);\n        }\n\n        audioBufferSourceNode.connect(outputChannelSplitterNode);\n\n        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n          const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n          for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n          }\n\n          outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n        }\n\n        return outputGainNode;\n      }\n\n      if (!nativeAudioWorkletNodeIsOwnedByContext) {\n        for (const [nm, audioParam] of proxy.parameters.entries()) {\n          await renderAutomation(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n          nativeAudioWorkletNode.parameters.get(nm), trace);\n        }\n      } else {\n        for (const [nm, audioParam] of proxy.parameters.entries()) {\n          await connectAudioParam(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n          nativeAudioWorkletNode.parameters.get(nm), trace);\n        }\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace);\n      return nativeAudioWorkletNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/standardized-audio-context/build/es2018/factories/audio-worklet-node-renderer-factory.js"],"names":["copyFromChannel","copyToChannel","createNestedArrays","getAudioNodeConnections","getAudioWorkletProcessor","isOwnedByContext","processBuffer","proxy","renderedBuffer","nativeOfflineAudioContext","options","processorConstructor","exposeCurrentFrameAndCurrentTime","length","Math","ceil","context","numberOfInputChannels","channelCount","numberOfInputs","numberOfOutputChannels","outputChannelCount","reduce","sum","value","processedBuffer","createBuffer","sampleRate","undefined","Error","audioNodeConnections","audioWorkletProcessor","inputs","outputs","numberOfOutputs","parameters","Array","from","keys","prmtrs","name","Float32Array","i","j","k","parameterDescriptors","forEach","index","byteLength","potentiallyEmptyInputs","map","input","activeInputs","size","activeSourceFlag","process","outputChannelSplitterNodeOutput","error","dispatchEvent","ErrorEvent","createAudioWorkletNodeRendererFactory","connectAudioParam","connectMultipleOutputs","createNativeAudioBufferSourceNode","createNativeChannelMergerNode","createNativeChannelSplitterNode","createNativeConstantSourceNode","createNativeGainNode","disconnectMultipleOutputs","getNativeAudioNode","nativeAudioWorkletNodeConstructor","nativeOfflineAudioContextConstructor","renderAutomation","renderInputsOfAudioNode","renderNativeOfflineAudioContext","renderedNativeAudioNodes","WeakMap","processedBufferPromise","createAudioNode","trace","nativeAudioWorkletNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","outputChannelSplitterNode","max","channelCountMode","channelInterpretation","outputChannelMergerNodes","push","outputAudioNodes","outputGainNode","gain","connect","bind","disconnect","set","numberOfParameters","numberOfChannels","renderBuffer","partialOfflineAudioContext","gainNodes","inputChannelSplitterNodes","constantSourceNodes","Promise","all","values","audioParam","constantSourceNode","offset","inputChannelMergerNode","entries","start","destination","gainNode","audioBufferSourceNode","buffer","outputChannelMergerNode","nm","get","render","renderedNativeAudioWorkletNodeOrGainNode","resolve"],"mappings":"AAAA,SAASA,eAAT,QAAgC,8BAAhC;AACA,SAASC,aAAT,QAA8B,4BAA9B;AACA,SAASC,kBAAT,QAAmC,iCAAnC;AACA,SAASC,uBAAT,QAAwC,uCAAxC;AACA,SAASC,wBAAT,QAAyC,wCAAzC;AACA,SAASC,gBAAT,QAAiC,gCAAjC;;AACA,MAAMC,aAAa,GAAG,OAAOC,KAAP,EAAcC,cAAd,EAA8BC,yBAA9B,EAAyDC,OAAzD,EAAkEC,oBAAlE,EAAwFC,gCAAxF,KAA6H;AAC/I;AACA;AACA,QAAMC,MAAM,GAAIL,cAAc,KAAK,IAApB,GAA6BM,IAAI,CAACC,IAAL,CAAUR,KAAK,CAACS,OAAN,CAAcH,MAAd,GAAuB,GAAjC,IAAwC,GAArE,GAA4EL,cAAc,CAACK,MAA1G;AACA,QAAMI,qBAAqB,GAAGP,OAAO,CAACQ,YAAR,GAAuBR,OAAO,CAACS,cAA7D;AACA,QAAMC,sBAAsB,GAAGV,OAAO,CAACW,kBAAR,CAA2BC,MAA3B,CAAkC,CAACC,GAAD,EAAMC,KAAN,KAAgBD,GAAG,GAAGC,KAAxD,EAA+D,CAA/D,CAA/B;AACA,QAAMC,eAAe,GAAIL,sBAAsB,KAAK,CAA5B,GAAiC,IAAjC,GAAwCX,yBAAyB,CAACiB,YAA1B,CAAuCN,sBAAvC,EAA+DP,MAA/D,EAAuEJ,yBAAyB,CAACkB,UAAjG,CAAhE;;AACA,MAAIhB,oBAAoB,KAAKiB,SAA7B,EAAwC;AACpC,UAAM,IAAIC,KAAJ,CAAU,oCAAV,CAAN;AACH;;AACD,QAAMC,oBAAoB,GAAG3B,uBAAuB,CAACI,KAAD,CAApD;AACA,QAAMwB,qBAAqB,GAAG,MAAM3B,wBAAwB,CAACK,yBAAD,EAA4BF,KAA5B,CAA5D;AACA,QAAMyB,MAAM,GAAG9B,kBAAkB,CAACQ,OAAO,CAACS,cAAT,EAAyBT,OAAO,CAACQ,YAAjC,CAAjC;AACA,QAAMe,OAAO,GAAG/B,kBAAkB,CAACQ,OAAO,CAACwB,eAAT,EAA0BxB,OAAO,CAACW,kBAAlC,CAAlC;AACA,QAAMc,UAAU,GAAGC,KAAK,CACnBC,IADc,CACT9B,KAAK,CAAC4B,UAAN,CAAiBG,IAAjB,EADS,EAEdhB,MAFc,CAEP,CAACiB,MAAD,EAASC,IAAT,MAAmB,EAAE,GAAGD,MAAL;AAAa,KAACC,IAAD,GAAQ,IAAIC,YAAJ,CAAiB,GAAjB;AAArB,GAAnB,CAFO,EAE2D,EAF3D,CAAnB;;AAGA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG7B,MAApB,EAA4B6B,CAAC,IAAI,GAAjC,EAAsC;AAClC,QAAIhC,OAAO,CAACS,cAAR,GAAyB,CAAzB,IAA8BX,cAAc,KAAK,IAArD,EAA2D;AACvD,WAAK,IAAImC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjC,OAAO,CAACS,cAA5B,EAA4CwB,CAAC,IAAI,CAAjD,EAAoD;AAChD,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlC,OAAO,CAACQ,YAA5B,EAA0C0B,CAAC,IAAI,CAA/C,EAAkD;AAC9C5C,UAAAA,eAAe,CAACQ,cAAD,EAAiBwB,MAAM,CAACW,CAAD,CAAvB,EAA4BC,CAA5B,EAA+BA,CAA/B,EAAkCF,CAAlC,CAAf;AACH;AACJ;AACJ;;AACD,QAAI/B,oBAAoB,CAACkC,oBAArB,KAA8CjB,SAA9C,IAA2DpB,cAAc,KAAK,IAAlF,EAAwF;AACpFG,MAAAA,oBAAoB,CAACkC,oBAArB,CAA0CC,OAA1C,CAAkD,CAAC;AAAEN,QAAAA;AAAF,OAAD,EAAWO,KAAX,KAAqB;AACnE/C,QAAAA,eAAe,CAACQ,cAAD,EAAiB2B,UAAjB,EAA6BK,IAA7B,EAAmCvB,qBAAqB,GAAG8B,KAA3D,EAAkEL,CAAlE,CAAf;AACH,OAFD;AAGH;;AACD,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjC,OAAO,CAACS,cAA5B,EAA4CwB,CAAC,IAAI,CAAjD,EAAoD;AAChD,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlC,OAAO,CAACW,kBAAR,CAA2BsB,CAA3B,CAApB,EAAmDC,CAAC,IAAI,CAAxD,EAA2D;AACvD;AACA,YAAIX,OAAO,CAACU,CAAD,CAAP,CAAWC,CAAX,EAAcI,UAAd,KAA6B,CAAjC,EAAoC;AAChCf,UAAAA,OAAO,CAACU,CAAD,CAAP,CAAWC,CAAX,IAAgB,IAAIH,YAAJ,CAAiB,GAAjB,CAAhB;AACH;AACJ;AACJ;;AACD,QAAI;AACA,YAAMQ,sBAAsB,GAAGjB,MAAM,CAChCkB,GAD0B,CACtB,CAACC,KAAD,EAAQJ,KAAR,KAAkB;AACvB,YAAIjB,oBAAoB,CAACsB,YAArB,CAAkCL,KAAlC,EAAyCM,IAAzC,KAAkD,CAAtD,EAAyD;AACrD,iBAAO,CAAC,IAAIZ,YAAJ,CAAiB,CAAjB,CAAD,CAAP;AACH;;AACD,eAAOU,KAAP;AACH,OAN8B,CAA/B;AAOA,YAAMG,gBAAgB,GAAG1C,gCAAgC,CAAC8B,CAAC,GAAGjC,yBAAyB,CAACkB,UAA/B,EAA2ClB,yBAAyB,CAACkB,UAArE,EAAiF,MAAMI,qBAAqB,CAACwB,OAAtB,CAA8BN,sBAA9B,EAAsDhB,OAAtD,EAA+DE,UAA/D,CAAvF,CAAzD;;AACA,UAAIV,eAAe,KAAK,IAAxB,EAA8B;AAC1B,aAAK,IAAIkB,CAAC,GAAG,CAAR,EAAWa,+BAA+B,GAAG,CAAlD,EAAqDb,CAAC,GAAGjC,OAAO,CAACwB,eAAjE,EAAkFS,CAAC,IAAI,CAAvF,EAA0F;AACtF,eAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlC,OAAO,CAACW,kBAAR,CAA2BsB,CAA3B,CAApB,EAAmDC,CAAC,IAAI,CAAxD,EAA2D;AACvD3C,YAAAA,aAAa,CAACwB,eAAD,EAAkBQ,OAAO,CAACU,CAAD,CAAzB,EAA8BC,CAA9B,EAAiCY,+BAA+B,GAAGZ,CAAnE,EAAsEF,CAAtE,CAAb;AACH;;AACDc,UAAAA,+BAA+B,IAAI9C,OAAO,CAACW,kBAAR,CAA2BsB,CAA3B,CAAnC;AACH;AACJ;;AACD,UAAI,CAACW,gBAAL,EAAuB;AACnB;AACH;AACJ,KApBD,CAqBA,OAAOG,KAAP,EAAc;AACVlD,MAAAA,KAAK,CAACmD,aAAN,CAAoB,IAAIC,UAAJ,CAAe,gBAAf,EAAiC;AAAEF,QAAAA;AAAF,OAAjC,CAApB;AACA;AACH;AACJ;;AACD,SAAOhC,eAAP;AACH,CAjED;;AAkEA,OAAO,MAAMmC,qCAAqC,GAAG,CAACC,iBAAD,EAAoBC,sBAApB,EAA4CC,iCAA5C,EAA+EC,6BAA/E,EAA8GC,+BAA9G,EAA+IC,8BAA/I,EAA+KC,oBAA/K,EAAqMC,yBAArM,EAAgOxD,gCAAhO,EAAkQyD,kBAAlQ,EAAsRC,iCAAtR,EAAyTC,oCAAzT,EAA+VC,gBAA/V,EAAiXC,uBAAjX,EAA0YC,+BAA1Y,KAA8a;AAC/d,SAAO,CAAClC,IAAD,EAAO9B,OAAP,EAAgBC,oBAAhB,KAAyC;AAC5C,UAAMgE,wBAAwB,GAAG,IAAIC,OAAJ,EAAjC;AACA,QAAIC,sBAAsB,GAAG,IAA7B;;AACA,UAAMC,eAAe,GAAG,OAAOvE,KAAP,EAAcE,yBAAd,EAAyCsE,KAAzC,KAAmD;AACvE,UAAIC,sBAAsB,GAAGX,kBAAkB,CAAC9D,KAAD,CAA/C;AACA,UAAI0E,iBAAiB,GAAG,IAAxB;AACA,YAAMC,sCAAsC,GAAG7E,gBAAgB,CAAC2E,sBAAD,EAAyBvE,yBAAzB,CAA/D,CAHuE,CAIvE;;AACA,UAAI6D,iCAAiC,KAAK,IAA1C,EAAgD;AAC5C,cAAMlD,sBAAsB,GAAGV,OAAO,CAACW,kBAAR,CAA2BC,MAA3B,CAAkC,CAACC,GAAD,EAAMC,KAAN,KAAgBD,GAAG,GAAGC,KAAxD,EAA+D,CAA/D,CAA/B;AACA,cAAM2D,yBAAyB,GAAGlB,+BAA+B,CAACxD,yBAAD,EAA4B;AACzFS,UAAAA,YAAY,EAAEJ,IAAI,CAACsE,GAAL,CAAS,CAAT,EAAYhE,sBAAZ,CAD2E;AAEzFiE,UAAAA,gBAAgB,EAAE,UAFuE;AAGzFC,UAAAA,qBAAqB,EAAE,UAHkE;AAIzFpD,UAAAA,eAAe,EAAEpB,IAAI,CAACsE,GAAL,CAAS,CAAT,EAAYhE,sBAAZ;AAJwE,SAA5B,CAAjE;AAMA,cAAMmE,wBAAwB,GAAG,EAAjC;;AACA,aAAK,IAAI7C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnC,KAAK,CAAC2B,eAA1B,EAA2CQ,CAAC,IAAI,CAAhD,EAAmD;AAC/C6C,UAAAA,wBAAwB,CAACC,IAAzB,CAA8BxB,6BAA6B,CAACvD,yBAAD,EAA4B;AACnFS,YAAAA,YAAY,EAAE,CADqE;AAEnFmE,YAAAA,gBAAgB,EAAE,UAFiE;AAGnFC,YAAAA,qBAAqB,EAAE,UAH4D;AAInFnE,YAAAA,cAAc,EAAET,OAAO,CAACW,kBAAR,CAA2BqB,CAA3B;AAJmE,WAA5B,CAA3D;AAMH,SAhB2C,CAiB5C;;;AACA,cAAM+C,gBAAgB,GAAI/E,OAAO,CAACwB,eAAR,KAA4B,CAA7B,GACrB,CAACiD,yBAAD,CADqB,GAErBI,wBAFJ;AAGA,cAAMG,cAAc,GAAGvB,oBAAoB,CAAC1D,yBAAD,EAA4B;AACnES,UAAAA,YAAY,EAAER,OAAO,CAACQ,YAD6C;AAEnEmE,UAAAA,gBAAgB,EAAE3E,OAAO,CAAC2E,gBAFyC;AAGnEC,UAAAA,qBAAqB,EAAE5E,OAAO,CAAC4E,qBAHoC;AAInEK,UAAAA,IAAI,EAAE;AAJ6D,SAA5B,CAA3C;AAMAD,QAAAA,cAAc,CAACE,OAAf,GAAyB9B,sBAAsB,CAAC+B,IAAvB,CAA4B,IAA5B,EAAkCJ,gBAAlC,CAAzB;AACAC,QAAAA,cAAc,CAACI,UAAf,GAA4B1B,yBAAyB,CAACyB,IAA1B,CAA+B,IAA/B,EAAqCJ,gBAArC,CAA5B;AACAR,QAAAA,iBAAiB,GAAG,CAACE,yBAAD,EAA4BI,wBAA5B,EAAsDG,cAAtD,CAApB;AACH,OA9BD,MA+BK,IAAI,CAACR,sCAAL,EAA6C;AAC9CF,QAAAA,sBAAsB,GAAG,IAAIV,iCAAJ,CAAsC7D,yBAAtC,EAAiE+B,IAAjE,CAAzB;AACH;;AACDmC,MAAAA,wBAAwB,CAACoB,GAAzB,CAA6BtF,yBAA7B,EAAyDwE,iBAAiB,KAAK,IAAvB,GAA+BD,sBAA/B,GAAwDC,iBAAiB,CAAC,CAAD,CAAjI;;AACA,UAAIA,iBAAiB,KAAK,IAA1B,EAAgC;AAC5B,YAAIJ,sBAAsB,KAAK,IAA/B,EAAqC;AACjC,cAAIlE,oBAAoB,KAAKiB,SAA7B,EAAwC;AACpC,kBAAM,IAAIC,KAAJ,CAAU,oCAAV,CAAN;AACH;;AACD,cAAI0C,oCAAoC,KAAK,IAA7C,EAAmD;AAC/C,kBAAM,IAAI1C,KAAJ,CAAU,qDAAV,CAAN;AACH,WANgC,CAOjC;;;AACA,gBAAMZ,qBAAqB,GAAGV,KAAK,CAACW,YAAN,GAAqBX,KAAK,CAACY,cAAzD;AACA,gBAAM6E,kBAAkB,GAAIrF,oBAAoB,CAACkC,oBAArB,KAA8CjB,SAA/C,GACrB,CADqB,GAErBjB,oBAAoB,CAACkC,oBAArB,CAA0ChC,MAFhD;AAGA,gBAAMoF,gBAAgB,GAAGhF,qBAAqB,GAAG+E,kBAAjD;;AACA,gBAAME,YAAY,GAAG,YAAY;AAC7B,kBAAMC,0BAA0B,GAAG,IAAI5B,oCAAJ,CAAyC0B,gBAAzC,EACnC;AACA;AACAnF,YAAAA,IAAI,CAACC,IAAL,CAAUR,KAAK,CAACS,OAAN,CAAcH,MAAd,GAAuB,GAAjC,IAAwC,GAHL,EAGUJ,yBAAyB,CAACkB,UAHpC,CAAnC;AAIA,kBAAMyE,SAAS,GAAG,EAAlB;AACA,kBAAMC,yBAAyB,GAAG,EAAlC;;AACA,iBAAK,IAAI3D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhC,OAAO,CAACS,cAA5B,EAA4CuB,CAAC,IAAI,CAAjD,EAAoD;AAChD0D,cAAAA,SAAS,CAACZ,IAAV,CAAerB,oBAAoB,CAACgC,0BAAD,EAA6B;AAC5DjF,gBAAAA,YAAY,EAAER,OAAO,CAACQ,YADsC;AAE5DmE,gBAAAA,gBAAgB,EAAE3E,OAAO,CAAC2E,gBAFkC;AAG5DC,gBAAAA,qBAAqB,EAAE5E,OAAO,CAAC4E,qBAH6B;AAI5DK,gBAAAA,IAAI,EAAE;AAJsD,eAA7B,CAAnC;AAMAU,cAAAA,yBAAyB,CAACb,IAA1B,CAA+BvB,+BAA+B,CAACkC,0BAAD,EAA6B;AACvFjF,gBAAAA,YAAY,EAAER,OAAO,CAACQ,YADiE;AAEvFmE,gBAAAA,gBAAgB,EAAE,UAFqE;AAGvFC,gBAAAA,qBAAqB,EAAE,UAHgE;AAIvFpD,gBAAAA,eAAe,EAAExB,OAAO,CAACQ;AAJ8D,eAA7B,CAA9D;AAMH;;AACD,kBAAMoF,mBAAmB,GAAG,MAAMC,OAAO,CACpCC,GAD6B,CACzBpE,KAAK,CACTC,IADI,CACC9B,KAAK,CAAC4B,UAAN,CAAiBsE,MAAjB,EADD,EAEJvD,GAFI,CAEA,MAAOwD,UAAP,IAAsB;AAC3B,oBAAMC,kBAAkB,GAAGzC,8BAA8B,CAACiC,0BAAD,EAA6B;AAClFjF,gBAAAA,YAAY,EAAE,CADoE;AAElFmE,gBAAAA,gBAAgB,EAAE,UAFgE;AAGlFC,gBAAAA,qBAAqB,EAAE,UAH2D;AAIlFsB,gBAAAA,MAAM,EAAEF,UAAU,CAAClF;AAJ+D,eAA7B,CAAzD;AAMA,oBAAMgD,gBAAgB,CAAC2B,0BAAD,EAA6BO,UAA7B,EAAyCC,kBAAkB,CAACC,MAA5D,EAAoE7B,KAApE,CAAtB;AACA,qBAAO4B,kBAAP;AACH,aAXQ,CADyB,CAAlC;AAaA,kBAAME,sBAAsB,GAAG7C,6BAA6B,CAACmC,0BAAD,EAA6B;AACrFjF,cAAAA,YAAY,EAAE,CADuE;AAErFmE,cAAAA,gBAAgB,EAAE,UAFmE;AAGrFC,cAAAA,qBAAqB,EAAE,UAH8D;AAIrFnE,cAAAA,cAAc,EAAEL,IAAI,CAACsE,GAAL,CAAS,CAAT,EAAYnE,qBAAqB,GAAG+E,kBAApC;AAJqE,aAA7B,CAA5D;;AAMA,iBAAK,IAAItD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhC,OAAO,CAACS,cAA5B,EAA4CuB,CAAC,IAAI,CAAjD,EAAoD;AAChD0D,cAAAA,SAAS,CAAC1D,CAAD,CAAT,CAAakD,OAAb,CAAqBS,yBAAyB,CAAC3D,CAAD,CAA9C;;AACA,mBAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjC,OAAO,CAACQ,YAA5B,EAA0CyB,CAAC,IAAI,CAA/C,EAAkD;AAC9C0D,gBAAAA,yBAAyB,CAAC3D,CAAD,CAAzB,CAA6BkD,OAA7B,CAAqCiB,sBAArC,EAA6DlE,CAA7D,EAAiED,CAAC,GAAGhC,OAAO,CAACQ,YAAb,GAA6ByB,CAA7F;AACH;AACJ;;AACD,iBAAK,MAAM,CAACI,KAAD,EAAQ4D,kBAAR,CAAX,IAA0CL,mBAAmB,CAACQ,OAApB,EAA1C,EAAyE;AACrEH,cAAAA,kBAAkB,CAACf,OAAnB,CAA2BiB,sBAA3B,EAAmD,CAAnD,EAAsD5F,qBAAqB,GAAG8B,KAA9E;AACA4D,cAAAA,kBAAkB,CAACI,KAAnB,CAAyB,CAAzB;AACH;;AACDF,YAAAA,sBAAsB,CAACjB,OAAvB,CAA+BO,0BAA0B,CAACa,WAA1D;AACA,kBAAMT,OAAO,CACRC,GADC,CACGJ,SAAS,CACblD,GADI,CACC+D,QAAD,IAAcxC,uBAAuB,CAAClE,KAAD,EAAQ4F,0BAAR,EAAoCc,QAApC,EAA8ClC,KAA9C,CADrC,CADH,CAAN;AAGA,mBAAOL,+BAA+B,CAACyB,0BAAD,CAAtC;AACH,WAvDD;;AAwDAtB,UAAAA,sBAAsB,GAAGvE,aAAa,CAACC,KAAD,EAAS0F,gBAAgB,KAAK,CAAtB,GAA2B,IAA3B,GAAkC,MAAMC,YAAY,EAA5D,EAAgEzF,yBAAhE,EAA2FC,OAA3F,EAAoGC,oBAApG,EAA0HC,gCAA1H,CAAtC;AACH;;AACD,cAAMa,eAAe,GAAG,MAAMoD,sBAA9B;AACA,cAAMqC,qBAAqB,GAAGnD,iCAAiC,CAACtD,yBAAD,CAA/D;AACA,cAAM,CAAC0E,yBAAD,EAA4BI,wBAA5B,EAAsDG,cAAtD,IAAwET,iBAA9E;;AACA,YAAIxD,eAAe,KAAK,IAAxB,EAA8B;AAC1ByF,UAAAA,qBAAqB,CAACC,MAAtB,GAA+B1F,eAA/B;AACAyF,UAAAA,qBAAqB,CAACH,KAAtB,CAA4B,CAA5B;AACH;;AACDG,QAAAA,qBAAqB,CAACtB,OAAtB,CAA8BT,yBAA9B;;AACA,aAAK,IAAIzC,CAAC,GAAG,CAAR,EAAWc,+BAA+B,GAAG,CAAlD,EAAqDd,CAAC,GAAGnC,KAAK,CAAC2B,eAA/D,EAAgFQ,CAAC,IAAI,CAArF,EAAwF;AACpF,gBAAM0E,uBAAuB,GAAG7B,wBAAwB,CAAC7C,CAAD,CAAxD;;AACA,eAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGjC,OAAO,CAACW,kBAAR,CAA2BqB,CAA3B,CAApB,EAAmDC,CAAC,IAAI,CAAxD,EAA2D;AACvDwC,YAAAA,yBAAyB,CAACS,OAA1B,CAAkCwB,uBAAlC,EAA2D5D,+BAA+B,GAAGb,CAA7F,EAAgGA,CAAhG;AACH;;AACDa,UAAAA,+BAA+B,IAAI9C,OAAO,CAACW,kBAAR,CAA2BqB,CAA3B,CAAnC;AACH;;AACD,eAAOgD,cAAP;AACH;;AACD,UAAI,CAACR,sCAAL,EAA6C;AACzC,aAAK,MAAM,CAACmC,EAAD,EAAKX,UAAL,CAAX,IAA+BnG,KAAK,CAAC4B,UAAN,CAAiB2E,OAAjB,EAA/B,EAA2D;AACvD,gBAAMtC,gBAAgB,CAAC/D,yBAAD,EAA4BiG,UAA5B,EACtB;AACA1B,UAAAA,sBAAsB,CAAC7C,UAAvB,CAAkCmF,GAAlC,CAAsCD,EAAtC,CAFsB,EAEqBtC,KAFrB,CAAtB;AAGH;AACJ,OAND,MAOK;AACD,aAAK,MAAM,CAACsC,EAAD,EAAKX,UAAL,CAAX,IAA+BnG,KAAK,CAAC4B,UAAN,CAAiB2E,OAAjB,EAA/B,EAA2D;AACvD,gBAAMjD,iBAAiB,CAACpD,yBAAD,EAA4BiG,UAA5B,EACvB;AACA1B,UAAAA,sBAAsB,CAAC7C,UAAvB,CAAkCmF,GAAlC,CAAsCD,EAAtC,CAFuB,EAEoBtC,KAFpB,CAAvB;AAGH;AACJ;;AACD,YAAMN,uBAAuB,CAAClE,KAAD,EAAQE,yBAAR,EAAmCuE,sBAAnC,EAA2DD,KAA3D,CAA7B;AACA,aAAOC,sBAAP;AACH,KAjJD;;AAkJA,WAAO;AACHuC,MAAAA,MAAM,CAAChH,KAAD,EAAQE,yBAAR,EAAmCsE,KAAnC,EAA0C;AAC5C,cAAMyC,wCAAwC,GAAG7C,wBAAwB,CAAC2C,GAAzB,CAA6B7G,yBAA7B,CAAjD;;AACA,YAAI+G,wCAAwC,KAAK5F,SAAjD,EAA4D;AACxD,iBAAO2E,OAAO,CAACkB,OAAR,CAAgBD,wCAAhB,CAAP;AACH;;AACD,eAAO1C,eAAe,CAACvE,KAAD,EAAQE,yBAAR,EAAmCsE,KAAnC,CAAtB;AACH;;AAPE,KAAP;AASH,GA9JD;AA+JH,CAhKM","sourcesContent":["import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = (renderedBuffer === null) ? (Math.ceil(proxy.context.length / 128) * 128) : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer = (numberOfOutputChannels === 0) ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n    const parameters = Array\n        .from(proxy.parameters.keys())\n        .reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n        try {\n            const potentiallyEmptyInputs = inputs\n                .map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [new Float32Array(0)];\n                }\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n                }\n            }\n            if (!activeSourceFlag) {\n                break;\n            }\n        }\n        catch (error) {\n            proxy.dispatchEvent(new ErrorEvent('processorerror', { error }));\n            break;\n        }\n    }\n    return processedBuffer;\n};\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (name, options, processorConstructor) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let processedBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n            let nativeOutputNodes = null;\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes = [];\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: options.outputChannelCount[i]\n                    }));\n                }\n                // Bug #87: Expose at least one output to make this node connectable.\n                const outputAudioNodes = (options.numberOfOutputs === 0) ?\n                    [outputChannelSplitterNode] :\n                    outputChannelMergerNodes;\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n                outputGainNode.connect = connectMultipleOutputs.bind(null, outputAudioNodes);\n                outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputAudioNodes);\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            }\n            else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, (nativeOutputNodes === null) ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters = (processorConstructor.parameterDescriptors === undefined)\n                        ? 0\n                        : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, \n                        // Ceil the length to the next full render quantum.\n                        // Bug #17: Safari does not yet expose the length.\n                        Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                        const gainNodes = [];\n                        const inputChannelSplitterNodes = [];\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: options.channelCountMode,\n                                channelInterpretation: options.channelInterpretation,\n                                gain: 1\n                            }));\n                            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                numberOfOutputs: options.channelCount\n                            }));\n                        }\n                        const constantSourceNodes = await Promise\n                            .all(Array\n                            .from(proxy.parameters.values())\n                            .map(async (audioParam) => {\n                            const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                channelCount: 1,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                offset: audioParam.value\n                            });\n                            await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace);\n                            return constantSourceNode;\n                        }));\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, (i * options.channelCount) + j);\n                            }\n                        }\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                        await Promise\n                            .all(gainNodes\n                            .map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace)));\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n                    processedBufferPromise = processBuffer(proxy, (numberOfChannels === 0) ? null : await renderBuffer(), nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime);\n                }\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n                }\n                return outputGainNode;\n            }\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace);\n            return nativeAudioWorkletNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-worklet-node-renderer-factory.js.map"]},"metadata":{},"sourceType":"module"}