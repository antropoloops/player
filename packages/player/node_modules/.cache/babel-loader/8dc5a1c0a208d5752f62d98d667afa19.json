{"ast":null,"code":"import { interceptConnections } from '../helpers/intercept-connections';\nexport const createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = createNativeAudioNode => {\n  return (nativeAudioScheduledSourceNode, nativeContext) => {\n    const nativeGainNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createGain());\n    nativeAudioScheduledSourceNode.connect(nativeGainNode);\n\n    const disconnectGainNode = (disconnect => {\n      return () => {\n        // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n        disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n        nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n      };\n    })(nativeAudioScheduledSourceNode.disconnect);\n\n    nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n    interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n\n    nativeAudioScheduledSourceNode.stop = (stop => {\n      let isStopped = false;\n      return (when = 0) => {\n        if (isStopped) {\n          try {\n            stop.call(nativeAudioScheduledSourceNode, when);\n          } catch (_a) {\n            nativeGainNode.gain.setValueAtTime(0, when);\n          }\n        } else {\n          stop.call(nativeAudioScheduledSourceNode, when);\n          isStopped = true;\n        }\n      };\n    })(nativeAudioScheduledSourceNode.stop);\n  };\n};","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/standardized-audio-context/build/es2018/factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js"],"names":["interceptConnections","createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","createNativeAudioNode","nativeAudioScheduledSourceNode","nativeContext","nativeGainNode","ntvCntxt","createGain","connect","disconnectGainNode","disconnect","call","removeEventListener","addEventListener","stop","isStopped","when","_a","gain","setValueAtTime"],"mappings":"AAAA,SAASA,oBAAT,QAAqC,kCAArC;AACA,OAAO,MAAMC,4DAA4D,GAAIC,qBAAD,IAA2B;AACnG,SAAO,CAACC,8BAAD,EAAiCC,aAAjC,KAAmD;AACtD,UAAMC,cAAc,GAAGH,qBAAqB,CAACE,aAAD,EAAiBE,QAAD,IAAcA,QAAQ,CAACC,UAAT,EAA9B,CAA5C;AACAJ,IAAAA,8BAA8B,CAACK,OAA/B,CAAuCH,cAAvC;;AACA,UAAMI,kBAAkB,GAAG,CAAEC,UAAD,IAAgB;AACxC,aAAO,MAAM;AACT;AACAA,QAAAA,UAAU,CAACC,IAAX,CAAgBR,8BAAhB,EAAgDE,cAAhD;AACAF,QAAAA,8BAA8B,CAACS,mBAA/B,CAAmD,OAAnD,EAA4DH,kBAA5D;AACH,OAJD;AAKH,KAN0B,EAMxBN,8BAA8B,CAACO,UANP,CAA3B;;AAOAP,IAAAA,8BAA8B,CAACU,gBAA/B,CAAgD,OAAhD,EAAyDJ,kBAAzD;AACAT,IAAAA,oBAAoB,CAACG,8BAAD,EAAiCE,cAAjC,CAApB;;AACAF,IAAAA,8BAA8B,CAACW,IAA/B,GAAsC,CAAEA,IAAD,IAAU;AAC7C,UAAIC,SAAS,GAAG,KAAhB;AACA,aAAO,CAACC,IAAI,GAAG,CAAR,KAAc;AACjB,YAAID,SAAJ,EAAe;AACX,cAAI;AACAD,YAAAA,IAAI,CAACH,IAAL,CAAUR,8BAAV,EAA0Ca,IAA1C;AACH,WAFD,CAGA,OAAOC,EAAP,EAAW;AACPZ,YAAAA,cAAc,CAACa,IAAf,CAAoBC,cAApB,CAAmC,CAAnC,EAAsCH,IAAtC;AACH;AACJ,SAPD,MAQK;AACDF,UAAAA,IAAI,CAACH,IAAL,CAAUR,8BAAV,EAA0Ca,IAA1C;AACAD,UAAAA,SAAS,GAAG,IAAZ;AACH;AACJ,OAbD;AAcH,KAhBqC,EAgBnCZ,8BAA8B,CAACW,IAhBI,CAAtC;AAiBH,GA7BD;AA8BH,CA/BM","sourcesContent":["import { interceptConnections } from '../helpers/intercept-connections';\nexport const createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = (createNativeAudioNode) => {\n    return (nativeAudioScheduledSourceNode, nativeContext) => {\n        const nativeGainNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createGain());\n        nativeAudioScheduledSourceNode.connect(nativeGainNode);\n        const disconnectGainNode = ((disconnect) => {\n            return () => {\n                // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n                disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n                nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n            };\n        })(nativeAudioScheduledSourceNode.disconnect);\n        nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n        interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n        nativeAudioScheduledSourceNode.stop = ((stop) => {\n            let isStopped = false;\n            return (when = 0) => {\n                if (isStopped) {\n                    try {\n                        stop.call(nativeAudioScheduledSourceNode, when);\n                    }\n                    catch (_a) {\n                        nativeGainNode.gain.setValueAtTime(0, when);\n                    }\n                }\n                else {\n                    stop.call(nativeAudioScheduledSourceNode, when);\n                    isStopped = true;\n                }\n            };\n        })(nativeAudioScheduledSourceNode.stop);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js.map"]},"metadata":{},"sourceType":"module"}