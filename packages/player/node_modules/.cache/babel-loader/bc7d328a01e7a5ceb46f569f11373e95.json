{"ast":null,"code":"import _defineProperty from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport var createNativeAudioWorkletNodeFakerFactory = function createNativeAudioWorkletNodeFakerFactory(auxiliaryGainNodeStore, connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, monitorConnections) {\n  return function (nativeContext, baseLatency, processorConstructor, options) {\n    if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n      throw createNotSupportedError();\n    }\n\n    if (options.outputChannelCount !== undefined) {\n      // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n      if (options.outputChannelCount.some(function (channelCount) {\n        return channelCount < 1;\n      })) {\n        throw createNotSupportedError();\n      }\n\n      if (options.outputChannelCount.length !== options.numberOfOutputs) {\n        throw createIndexSizeError();\n      }\n    } // Bug #61: This is not part of the standard but required for the faker to work.\n\n\n    if (options.channelCountMode !== 'explicit') {\n      throw createNotSupportedError();\n    }\n\n    var numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    var numberOfOutputChannels = options.outputChannelCount.reduce(function (sum, value) {\n      return sum + value;\n    }, 0);\n    var numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length; // Bug #61: This is not part of the standard but required for the faker to work.\n\n    if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n      throw createNotSupportedError();\n    }\n\n    var messageChannel = new MessageChannel();\n    var gainNodes = [];\n    var inputChannelSplitterNodes = [];\n\n    for (var i = 0; i < options.numberOfInputs; i += 1) {\n      gainNodes.push(createNativeGainNode(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: options.channelCountMode,\n        channelInterpretation: options.channelInterpretation,\n        gain: 1\n      }));\n      inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'discrete',\n        numberOfOutputs: options.channelCount\n      }));\n    }\n\n    var constantSourceNodes = [];\n\n    if (processorConstructor.parameterDescriptors !== undefined) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        var _loop = function _loop() {\n          var _ref = _step.value;\n          var defaultValue = _ref.defaultValue;\n          var maxValue = _ref.maxValue;\n          var minValue = _ref.minValue;\n          var name = _ref.name;\n          var constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            offset: options.parameterData[name] !== undefined ? options.parameterData[name] : defaultValue === undefined ? 0 : defaultValue\n          });\n          Object.defineProperties(constantSourceNode.offset, {\n            defaultValue: {\n              get: function get() {\n                return defaultValue === undefined ? 0 : defaultValue;\n              }\n            },\n            maxValue: {\n              get: function get() {\n                return maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue;\n              }\n            },\n            minValue: {\n              get: function get() {\n                return minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue;\n              }\n            }\n          });\n          constantSourceNodes.push(constantSourceNode);\n        };\n\n        for (var _iterator = processorConstructor.parameterDescriptors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          _loop();\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    var inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'speakers',\n      numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n    });\n    var bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n    var scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n    Math.max(1, numberOfOutputChannels));\n    var outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n      channelCount: Math.max(1, numberOfOutputChannels),\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      numberOfOutputs: Math.max(1, numberOfOutputChannels)\n    });\n    var outputChannelMergerNodes = [];\n\n    for (var _i = 0; _i < options.numberOfOutputs; _i += 1) {\n      outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n        channelCount: 1,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'speakers',\n        numberOfInputs: options.outputChannelCount[_i]\n      }));\n    }\n\n    for (var _i2 = 0; _i2 < options.numberOfInputs; _i2 += 1) {\n      gainNodes[_i2].connect(inputChannelSplitterNodes[_i2]);\n\n      for (var j = 0; j < options.channelCount; j += 1) {\n        inputChannelSplitterNodes[_i2].connect(inputChannelMergerNode, j, _i2 * options.channelCount + j);\n      }\n    }\n\n    var parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.map(function (_ref2, index) {\n      var name = _ref2.name;\n      var constantSourceNode = constantSourceNodes[index];\n      constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n      constantSourceNode.start(0);\n      return [name, constantSourceNode.offset];\n    }));\n    inputChannelMergerNode.connect(scriptProcessorNode);\n    var channelInterpretation = options.channelInterpretation;\n    var onprocessorerror = null; // Bug #87: Expose at least one output to make this node connectable.\n\n    var outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n    var nativeAudioWorkletNodeFaker = {\n      get bufferSize() {\n        return bufferSize;\n      },\n\n      get channelCount() {\n        return options.channelCount;\n      },\n\n      set channelCount(_) {\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        throw createInvalidStateError();\n      },\n\n      get channelCountMode() {\n        return options.channelCountMode;\n      },\n\n      set channelCountMode(_) {\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        throw createInvalidStateError();\n      },\n\n      get channelInterpretation() {\n        return channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = gainNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var gainNode = _step2.value;\n            gainNode.channelInterpretation = value;\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        channelInterpretation = value;\n      },\n\n      get context() {\n        return scriptProcessorNode.context;\n      },\n\n      get inputs() {\n        return gainNodes;\n      },\n\n      get numberOfInputs() {\n        return options.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return options.numberOfOutputs;\n      },\n\n      get onprocessorerror() {\n        return onprocessorerror;\n      },\n\n      set onprocessorerror(value) {\n        if (typeof onprocessorerror === 'function') {\n          nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n        }\n\n        onprocessorerror = typeof value === 'function' ? value : null;\n\n        if (typeof onprocessorerror === 'function') {\n          nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n        }\n      },\n\n      get parameters() {\n        return parameterMap;\n      },\n\n      get port() {\n        return messageChannel.port2;\n      },\n\n      addEventListener: function addEventListener() {\n        return scriptProcessorNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      },\n      connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n      disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n      dispatchEvent: function dispatchEvent() {\n        return scriptProcessorNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n      },\n      removeEventListener: function removeEventListener() {\n        return scriptProcessorNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      }\n    };\n    var patchedEventListeners = new Map(); // tslint:disable-line:max-line-length\n\n    messageChannel.port1.addEventListener = function (addEventListener) {\n      return function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        if (args[0] === 'message') {\n          var unpatchedEventListener = typeof args[1] === 'function' ? args[1] : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function' ? args[1].handleEvent : null;\n\n          if (unpatchedEventListener !== null) {\n            var patchedEventListener = patchedEventListeners.get(args[1]);\n\n            if (patchedEventListener !== undefined) {\n              args[1] = patchedEventListener;\n            } else {\n              args[1] = function (event) {\n                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, function () {\n                  return unpatchedEventListener(event);\n                });\n              };\n\n              patchedEventListeners.set(unpatchedEventListener, args[1]);\n            }\n          }\n        }\n\n        return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    }(messageChannel.port1.addEventListener);\n\n    messageChannel.port1.removeEventListener = function (removeEventListener) {\n      return function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        if (args[0] === 'message') {\n          var patchedEventListener = patchedEventListeners.get(args[1]);\n\n          if (patchedEventListener !== undefined) {\n            patchedEventListeners.delete(args[1]);\n            args[1] = patchedEventListener;\n          }\n        }\n\n        return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    }(messageChannel.port1.removeEventListener);\n\n    var onmessage = null;\n    Object.defineProperty(messageChannel.port1, 'onmessage', {\n      get: function get() {\n        return onmessage;\n      },\n      set: function set(value) {\n        if (typeof onmessage === 'function') {\n          messageChannel.port1.removeEventListener('message', onmessage);\n        }\n\n        onmessage = typeof value === 'function' ? value : null;\n\n        if (typeof onmessage === 'function') {\n          messageChannel.port1.addEventListener('message', onmessage);\n          messageChannel.port1.start();\n        }\n      }\n    });\n    processorConstructor.prototype.port = messageChannel.port1;\n    var audioWorkletProcessor = null;\n    var audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n    audioWorkletProcessorPromise.then(function (dWrkltPrcssr) {\n      return audioWorkletProcessor = dWrkltPrcssr;\n    });\n    var inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    var outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n    var parameters = processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.reduce(function (prmtrs, _ref3) {\n      var name = _ref3.name;\n      return _objectSpread({}, prmtrs, _defineProperty({}, name, new Float32Array(128)));\n    }, {});\n    var isActive = true;\n\n    var disconnectOutputsGraph = function disconnectOutputsGraph() {\n      if (options.numberOfOutputs > 0) {\n        scriptProcessorNode.disconnect(outputChannelSplitterNode);\n      }\n\n      for (var _i3 = 0, outputChannelSplitterNodeOutput = 0; _i3 < options.numberOfOutputs; _i3 += 1) {\n        var outputChannelMergerNode = outputChannelMergerNodes[_i3];\n\n        for (var _j = 0; _j < options.outputChannelCount[_i3]; _j += 1) {\n          outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + _j, _j);\n        }\n\n        outputChannelSplitterNodeOutput += options.outputChannelCount[_i3];\n      }\n    };\n\n    scriptProcessorNode.onaudioprocess = function (_ref4) {\n      var inputBuffer = _ref4.inputBuffer,\n          outputBuffer = _ref4.outputBuffer;\n\n      if (audioWorkletProcessor !== null) {\n        var _loop2 = function _loop2(_i4) {\n          for (var _j2 = 0; _j2 < options.numberOfInputs; _j2 += 1) {\n            for (var k = 0; k < options.channelCount; k += 1) {\n              copyFromChannel(inputBuffer, inputs[_j2], k, k, _i4);\n            }\n          }\n\n          if (processorConstructor.parameterDescriptors !== undefined) {\n            processorConstructor.parameterDescriptors.forEach(function (_ref5, index) {\n              var name = _ref5.name;\n              copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, _i4);\n            });\n          }\n\n          for (var _j3 = 0; _j3 < options.numberOfInputs; _j3 += 1) {\n            for (var _k = 0; _k < options.outputChannelCount[_j3]; _k += 1) {\n              // The byteLength will be 0 when the ArrayBuffer was transferred.\n              if (outputs[_j3][_k].byteLength === 0) {\n                outputs[_j3][_k] = new Float32Array(128);\n              }\n            }\n          }\n\n          try {\n            var potentiallyEmptyInputs = inputs.map(function (input, index) {\n              var auxiliaryGainNodes = auxiliaryGainNodeStore.get(nativeAudioWorkletNodeFaker);\n\n              if (auxiliaryGainNodes === undefined || auxiliaryGainNodes.get(index) === undefined) {\n                return [new Float32Array(0)];\n              }\n\n              return input;\n            });\n            var activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + _i4 / nativeContext.sampleRate, nativeContext.sampleRate, function () {\n              return audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters);\n            });\n            isActive = activeSourceFlag;\n\n            for (var _j4 = 0, outputChannelSplitterNodeOutput = 0; _j4 < options.numberOfOutputs; _j4 += 1) {\n              for (var _k2 = 0; _k2 < options.outputChannelCount[_j4]; _k2 += 1) {\n                copyToChannel(outputBuffer, outputs[_j4], _k2, outputChannelSplitterNodeOutput + _k2, _i4);\n              }\n\n              outputChannelSplitterNodeOutput += options.outputChannelCount[_j4];\n            }\n          } catch (error) {\n            isActive = false;\n            nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', {\n              error: error\n            }));\n          }\n\n          if (!isActive) {\n            for (var _j5 = 0; _j5 < options.numberOfInputs; _j5 += 1) {\n              gainNodes[_j5].disconnect(inputChannelSplitterNodes[_j5]);\n\n              for (var _k3 = 0; _k3 < options.channelCount; _k3 += 1) {\n                inputChannelSplitterNodes[_i4].disconnect(inputChannelMergerNode, _k3, _j5 * options.channelCount + _k3);\n              }\n            }\n\n            if (processorConstructor.parameterDescriptors !== undefined) {\n              var length = processorConstructor.parameterDescriptors.length;\n\n              for (var _j6 = 0; _j6 < length; _j6 += 1) {\n                var constantSourceNode = constantSourceNodes[_j6];\n                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + _j6);\n                constantSourceNode.stop();\n              }\n            }\n\n            inputChannelMergerNode.disconnect(scriptProcessorNode);\n            scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n\n            if (isConnected) {\n              disconnectOutputsGraph();\n            }\n\n            return \"break\";\n          }\n        };\n\n        for (var _i4 = 0; _i4 < bufferSize; _i4 += 128) {\n          var _ret = _loop2(_i4);\n\n          if (_ret === \"break\") break;\n        }\n      }\n    };\n\n    var isConnected = false;\n\n    var whenConnected = function whenConnected() {\n      if (isActive) {\n        if (options.numberOfOutputs > 0) {\n          scriptProcessorNode.connect(outputChannelSplitterNode);\n        }\n\n        for (var _i5 = 0, outputChannelSplitterNodeOutput = 0; _i5 < options.numberOfOutputs; _i5 += 1) {\n          var outputChannelMergerNode = outputChannelMergerNodes[_i5];\n\n          for (var _j7 = 0; _j7 < options.outputChannelCount[_i5]; _j7 += 1) {\n            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + _j7, _j7);\n          }\n\n          outputChannelSplitterNodeOutput += options.outputChannelCount[_i5];\n        }\n      }\n\n      isConnected = true;\n    };\n\n    var whenDisconnected = function whenDisconnected() {\n      if (isActive) {\n        disconnectOutputsGraph();\n      }\n\n      isConnected = false;\n    };\n\n    return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/standardized-audio-context/build/es2018/factories/native-audio-worklet-node-faker-factory.js"],"names":["MOST_NEGATIVE_SINGLE_FLOAT","MOST_POSITIVE_SINGLE_FLOAT","computeBufferSize","copyFromChannel","copyToChannel","createAudioWorkletProcessor","createNestedArrays","ReadOnlyMap","createNativeAudioWorkletNodeFakerFactory","auxiliaryGainNodeStore","connectMultipleOutputs","createIndexSizeError","createInvalidStateError","createNativeChannelMergerNode","createNativeChannelSplitterNode","createNativeConstantSourceNode","createNativeGainNode","createNativeScriptProcessorNode","createNotSupportedError","disconnectMultipleOutputs","exposeCurrentFrameAndCurrentTime","monitorConnections","nativeContext","baseLatency","processorConstructor","options","numberOfInputs","numberOfOutputs","outputChannelCount","undefined","some","channelCount","length","channelCountMode","numberOfInputChannels","numberOfOutputChannels","reduce","sum","value","numberOfParameters","parameterDescriptors","messageChannel","MessageChannel","gainNodes","inputChannelSplitterNodes","i","push","channelInterpretation","gain","constantSourceNodes","defaultValue","maxValue","minValue","name","constantSourceNode","offset","parameterData","Object","defineProperties","get","inputChannelMergerNode","Math","max","bufferSize","sampleRate","scriptProcessorNode","outputChannelSplitterNode","outputChannelMergerNodes","connect","j","parameterMap","map","index","start","onprocessorerror","outputAudioNodes","nativeAudioWorkletNodeFaker","_","gainNode","context","inputs","removeEventListener","addEventListener","parameters","port","port2","bind","disconnect","dispatchEvent","patchedEventListeners","Map","port1","args","unpatchedEventListener","handleEvent","patchedEventListener","event","currentTime","set","call","delete","onmessage","defineProperty","prototype","audioWorkletProcessor","audioWorkletProcessorPromise","then","dWrkltPrcssr","outputs","prmtrs","Float32Array","isActive","disconnectOutputsGraph","outputChannelSplitterNodeOutput","outputChannelMergerNode","onaudioprocess","inputBuffer","outputBuffer","k","forEach","byteLength","potentiallyEmptyInputs","input","auxiliaryGainNodes","activeSourceFlag","process","error","ErrorEvent","stop","isConnected","whenConnected","whenDisconnected"],"mappings":";;;;;;AAAA,SAASA,0BAAT,EAAqCC,0BAArC,QAAuE,cAAvE;AACA,SAASC,iBAAT,QAAkC,gCAAlC;AACA,SAASC,eAAT,QAAgC,8BAAhC;AACA,SAASC,aAAT,QAA8B,4BAA9B;AACA,SAASC,2BAAT,QAA4C,2CAA5C;AACA,SAASC,kBAAT,QAAmC,iCAAnC;AACA,SAASC,WAAT,QAA4B,kBAA5B;AACA,OAAO,IAAMC,wCAAwC,GAAG,SAA3CA,wCAA2C,CAACC,sBAAD,EAAyBC,sBAAzB,EAAiDC,oBAAjD,EAAuEC,uBAAvE,EAAgGC,6BAAhG,EAA+HC,+BAA/H,EAAgKC,8BAAhK,EAAgMC,oBAAhM,EAAsNC,+BAAtN,EAAuPC,uBAAvP,EAAgRC,yBAAhR,EAA2SC,gCAA3S,EAA6UC,kBAA7U,EAAoW;AACxZ,SAAO,UAACC,aAAD,EAAgBC,WAAhB,EAA6BC,oBAA7B,EAAmDC,OAAnD,EAA+D;AAClE,QAAIA,OAAO,CAACC,cAAR,KAA2B,CAA3B,IAAgCD,OAAO,CAACE,eAAR,KAA4B,CAAhE,EAAmE;AAC/D,YAAMT,uBAAuB,EAA7B;AACH;;AACD,QAAIO,OAAO,CAACG,kBAAR,KAA+BC,SAAnC,EAA8C;AAC1C;AACA,UAAIJ,OAAO,CAACG,kBAAR,CAA2BE,IAA3B,CAAgC,UAACC,YAAD;AAAA,eAAmBA,YAAY,GAAG,CAAlC;AAAA,OAAhC,CAAJ,EAA2E;AACvE,cAAMb,uBAAuB,EAA7B;AACH;;AACD,UAAIO,OAAO,CAACG,kBAAR,CAA2BI,MAA3B,KAAsCP,OAAO,CAACE,eAAlD,EAAmE;AAC/D,cAAMhB,oBAAoB,EAA1B;AACH;AACJ,KAZiE,CAalE;;;AACA,QAAIc,OAAO,CAACQ,gBAAR,KAA6B,UAAjC,EAA6C;AACzC,YAAMf,uBAAuB,EAA7B;AACH;;AACD,QAAMgB,qBAAqB,GAAGT,OAAO,CAACM,YAAR,GAAuBN,OAAO,CAACC,cAA7D;AACA,QAAMS,sBAAsB,GAAGV,OAAO,CAACG,kBAAR,CAA2BQ,MAA3B,CAAkC,UAACC,GAAD,EAAMC,KAAN;AAAA,aAAgBD,GAAG,GAAGC,KAAtB;AAAA,KAAlC,EAA+D,CAA/D,CAA/B;AACA,QAAMC,kBAAkB,GAAIf,oBAAoB,CAACgB,oBAArB,KAA8CX,SAA/C,GACrB,CADqB,GAErBL,oBAAoB,CAACgB,oBAArB,CAA0CR,MAFhD,CAnBkE,CAsBlE;;AACA,QAAIE,qBAAqB,GAAGK,kBAAxB,GAA6C,CAA7C,IAAkDJ,sBAAsB,GAAG,CAA/E,EAAkF;AAC9E,YAAMjB,uBAAuB,EAA7B;AACH;;AACD,QAAMuB,cAAc,GAAG,IAAIC,cAAJ,EAAvB;AACA,QAAMC,SAAS,GAAG,EAAlB;AACA,QAAMC,yBAAyB,GAAG,EAAlC;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpB,OAAO,CAACC,cAA5B,EAA4CmB,CAAC,IAAI,CAAjD,EAAoD;AAChDF,MAAAA,SAAS,CAACG,IAAV,CAAe9B,oBAAoB,CAACM,aAAD,EAAgB;AAC/CS,QAAAA,YAAY,EAAEN,OAAO,CAACM,YADyB;AAE/CE,QAAAA,gBAAgB,EAAER,OAAO,CAACQ,gBAFqB;AAG/Cc,QAAAA,qBAAqB,EAAEtB,OAAO,CAACsB,qBAHgB;AAI/CC,QAAAA,IAAI,EAAE;AAJyC,OAAhB,CAAnC;AAMAJ,MAAAA,yBAAyB,CAACE,IAA1B,CAA+BhC,+BAA+B,CAACQ,aAAD,EAAgB;AAC1ES,QAAAA,YAAY,EAAEN,OAAO,CAACM,YADoD;AAE1EE,QAAAA,gBAAgB,EAAE,UAFwD;AAG1Ec,QAAAA,qBAAqB,EAAE,UAHmD;AAI1EpB,QAAAA,eAAe,EAAEF,OAAO,CAACM;AAJiD,OAAhB,CAA9D;AAMH;;AACD,QAAMkB,mBAAmB,GAAG,EAA5B;;AACA,QAAIzB,oBAAoB,CAACgB,oBAArB,KAA8CX,SAAlD,EAA6D;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,cAC5CqB,YAD4C,QAC5CA,YAD4C;AAAA,cAC9BC,QAD8B,QAC9BA,QAD8B;AAAA,cACpBC,QADoB,QACpBA,QADoB;AAAA,cACVC,IADU,QACVA,IADU;AAErD,cAAMC,kBAAkB,GAAGvC,8BAA8B,CAACO,aAAD,EAAgB;AACrES,YAAAA,YAAY,EAAE,CADuD;AAErEE,YAAAA,gBAAgB,EAAE,UAFmD;AAGrEc,YAAAA,qBAAqB,EAAE,UAH8C;AAIrEQ,YAAAA,MAAM,EAAG9B,OAAO,CAAC+B,aAAR,CAAsBH,IAAtB,MAAgCxB,SAAjC,GACFJ,OAAO,CAAC+B,aAAR,CAAsBH,IAAtB,CADE,GAEDH,YAAY,KAAKrB,SAAlB,GACI,CADJ,GAEIqB;AAR2D,WAAhB,CAAzD;AAUAO,UAAAA,MAAM,CAACC,gBAAP,CAAwBJ,kBAAkB,CAACC,MAA3C,EAAmD;AAC/CL,YAAAA,YAAY,EAAE;AACVS,cAAAA,GAAG,EAAE;AAAA,uBAAOT,YAAY,KAAKrB,SAAlB,GAA+B,CAA/B,GAAmCqB,YAAzC;AAAA;AADK,aADiC;AAI/CC,YAAAA,QAAQ,EAAE;AACNQ,cAAAA,GAAG,EAAE;AAAA,uBAAOR,QAAQ,KAAKtB,SAAd,GAA2B5B,0BAA3B,GAAwDkD,QAA9D;AAAA;AADC,aAJqC;AAO/CC,YAAAA,QAAQ,EAAE;AACNO,cAAAA,GAAG,EAAE;AAAA,uBAAOP,QAAQ,KAAKvB,SAAd,GAA2B7B,0BAA3B,GAAwDoD,QAA9D;AAAA;AADC;AAPqC,WAAnD;AAWAH,UAAAA,mBAAmB,CAACH,IAApB,CAAyBQ,kBAAzB;AAvBqD;;AACzD,6BAAyD9B,oBAAoB,CAACgB,oBAA9E,8HAAoG;AAAA;AAuBnG;AAxBwD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyB5D;;AACD,QAAMoB,sBAAsB,GAAG/C,6BAA6B,CAACS,aAAD,EAAgB;AACxES,MAAAA,YAAY,EAAE,CAD0D;AAExEE,MAAAA,gBAAgB,EAAE,UAFsD;AAGxEc,MAAAA,qBAAqB,EAAE,UAHiD;AAIxErB,MAAAA,cAAc,EAAEmC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY5B,qBAAqB,GAAGK,kBAApC;AAJwD,KAAhB,CAA5D;AAMA,QAAMwB,UAAU,GAAG7D,iBAAiB,CAACqB,WAAD,EAAcD,aAAa,CAAC0C,UAA5B,CAApC;AACA,QAAMC,mBAAmB,GAAGhD,+BAA+B,CAACK,aAAD,EAAgByC,UAAhB,EAA4B7B,qBAAqB,GAAGK,kBAApD,EAC3D;AACAsB,IAAAA,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY3B,sBAAZ,CAF2D,CAA3D;AAGA,QAAM+B,yBAAyB,GAAGpD,+BAA+B,CAACQ,aAAD,EAAgB;AAC7ES,MAAAA,YAAY,EAAE8B,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY3B,sBAAZ,CAD+D;AAE7EF,MAAAA,gBAAgB,EAAE,UAF2D;AAG7Ec,MAAAA,qBAAqB,EAAE,UAHsD;AAI7EpB,MAAAA,eAAe,EAAEkC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY3B,sBAAZ;AAJ4D,KAAhB,CAAjE;AAMA,QAAMgC,wBAAwB,GAAG,EAAjC;;AACA,SAAK,IAAItB,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGpB,OAAO,CAACE,eAA5B,EAA6CkB,EAAC,IAAI,CAAlD,EAAqD;AACjDsB,MAAAA,wBAAwB,CAACrB,IAAzB,CAA8BjC,6BAA6B,CAACS,aAAD,EAAgB;AACvES,QAAAA,YAAY,EAAE,CADyD;AAEvEE,QAAAA,gBAAgB,EAAE,UAFqD;AAGvEc,QAAAA,qBAAqB,EAAE,UAHgD;AAIvErB,QAAAA,cAAc,EAAED,OAAO,CAACG,kBAAR,CAA2BiB,EAA3B;AAJuD,OAAhB,CAA3D;AAMH;;AACD,SAAK,IAAIA,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGpB,OAAO,CAACC,cAA5B,EAA4CmB,GAAC,IAAI,CAAjD,EAAoD;AAChDF,MAAAA,SAAS,CAACE,GAAD,CAAT,CAAauB,OAAb,CAAqBxB,yBAAyB,CAACC,GAAD,CAA9C;;AACA,WAAK,IAAIwB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5C,OAAO,CAACM,YAA5B,EAA0CsC,CAAC,IAAI,CAA/C,EAAkD;AAC9CzB,QAAAA,yBAAyB,CAACC,GAAD,CAAzB,CAA6BuB,OAA7B,CAAqCR,sBAArC,EAA6DS,CAA7D,EAAiExB,GAAC,GAAGpB,OAAO,CAACM,YAAb,GAA6BsC,CAA7F;AACH;AACJ;;AACD,QAAMC,YAAY,GAAG,IAAI/D,WAAJ,CAAiBiB,oBAAoB,CAACgB,oBAArB,KAA8CX,SAA/C,GAC/B,EAD+B,GAE/BL,oBAAoB,CAACgB,oBAArB,CACG+B,GADH,CACO,iBAAWC,KAAX,EAAqB;AAAA,UAAlBnB,IAAkB,SAAlBA,IAAkB;AAC1B,UAAMC,kBAAkB,GAAGL,mBAAmB,CAACuB,KAAD,CAA9C;AACAlB,MAAAA,kBAAkB,CAACc,OAAnB,CAA2BR,sBAA3B,EAAmD,CAAnD,EAAsD1B,qBAAqB,GAAGsC,KAA9E;AACAlB,MAAAA,kBAAkB,CAACmB,KAAnB,CAAyB,CAAzB;AACA,aAAO,CAACpB,IAAD,EAAOC,kBAAkB,CAACC,MAA1B,CAAP;AACH,KANC,CAFe,CAArB;AASAK,IAAAA,sBAAsB,CAACQ,OAAvB,CAA+BH,mBAA/B;AACA,QAAIlB,qBAAqB,GAAGtB,OAAO,CAACsB,qBAApC;AACA,QAAI2B,gBAAgB,GAAG,IAAvB,CAhHkE,CAiHlE;;AACA,QAAMC,gBAAgB,GAAIlD,OAAO,CAACE,eAAR,KAA4B,CAA7B,GAAkC,CAACsC,mBAAD,CAAlC,GAA0DE,wBAAnF;AACA,QAAMS,2BAA2B,GAAG;AAChC,UAAIb,UAAJ,GAAiB;AACb,eAAOA,UAAP;AACH,OAH+B;;AAIhC,UAAIhC,YAAJ,GAAmB;AACf,eAAON,OAAO,CAACM,YAAf;AACH,OAN+B;;AAOhC,UAAIA,YAAJ,CAAiB8C,CAAjB,EAAoB;AAChB;AACA,cAAMjE,uBAAuB,EAA7B;AACH,OAV+B;;AAWhC,UAAIqB,gBAAJ,GAAuB;AACnB,eAAOR,OAAO,CAACQ,gBAAf;AACH,OAb+B;;AAchC,UAAIA,gBAAJ,CAAqB4C,CAArB,EAAwB;AACpB;AACA,cAAMjE,uBAAuB,EAA7B;AACH,OAjB+B;;AAkBhC,UAAImC,qBAAJ,GAA4B;AACxB,eAAOA,qBAAP;AACH,OApB+B;;AAqBhC,UAAIA,qBAAJ,CAA0BT,KAA1B,EAAiC;AAAA;AAAA;AAAA;;AAAA;AAC7B,gCAAuBK,SAAvB,mIAAkC;AAAA,gBAAvBmC,QAAuB;AAC9BA,YAAAA,QAAQ,CAAC/B,qBAAT,GAAiCT,KAAjC;AACH;AAH4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAI7BS,QAAAA,qBAAqB,GAAGT,KAAxB;AACH,OA1B+B;;AA2BhC,UAAIyC,OAAJ,GAAc;AACV,eAAOd,mBAAmB,CAACc,OAA3B;AACH,OA7B+B;;AA8BhC,UAAIC,MAAJ,GAAa;AACT,eAAOrC,SAAP;AACH,OAhC+B;;AAiChC,UAAIjB,cAAJ,GAAqB;AACjB,eAAOD,OAAO,CAACC,cAAf;AACH,OAnC+B;;AAoChC,UAAIC,eAAJ,GAAsB;AAClB,eAAOF,OAAO,CAACE,eAAf;AACH,OAtC+B;;AAuChC,UAAI+C,gBAAJ,GAAuB;AACnB,eAAOA,gBAAP;AACH,OAzC+B;;AA0ChC,UAAIA,gBAAJ,CAAqBpC,KAArB,EAA4B;AACxB,YAAI,OAAOoC,gBAAP,KAA4B,UAAhC,EAA4C;AACxCE,UAAAA,2BAA2B,CAACK,mBAA5B,CAAgD,gBAAhD,EAAkEP,gBAAlE;AACH;;AACDA,QAAAA,gBAAgB,GAAI,OAAOpC,KAAP,KAAiB,UAAlB,GAAgCA,KAAhC,GAAwC,IAA3D;;AACA,YAAI,OAAOoC,gBAAP,KAA4B,UAAhC,EAA4C;AACxCE,UAAAA,2BAA2B,CAACM,gBAA5B,CAA6C,gBAA7C,EAA+DR,gBAA/D;AACH;AACJ,OAlD+B;;AAmDhC,UAAIS,UAAJ,GAAiB;AACb,eAAOb,YAAP;AACH,OArD+B;;AAsDhC,UAAIc,IAAJ,GAAW;AACP,eAAO3C,cAAc,CAAC4C,KAAtB;AACH,OAxD+B;;AAyDhCH,MAAAA,gBAzDgC,8BAyDN;AACtB,eAAOjB,mBAAmB,CAACiB,gBAApB,sJAAP;AACH,OA3D+B;AA4DhCd,MAAAA,OAAO,EAAE1D,sBAAsB,CAAC4E,IAAvB,CAA4B,IAA5B,EAAkCX,gBAAlC,CA5DuB;AA6DhCY,MAAAA,UAAU,EAAEpE,yBAAyB,CAACmE,IAA1B,CAA+B,IAA/B,EAAqCX,gBAArC,CA7DoB;AA8DhCa,MAAAA,aA9DgC,2BA8DT;AACnB,eAAOvB,mBAAmB,CAACuB,aAApB,kDAAP;AACH,OAhE+B;AAiEhCP,MAAAA,mBAjEgC,iCAiEH;AACzB,eAAOhB,mBAAmB,CAACgB,mBAApB,sJAAP;AACH;AAnE+B,KAApC;AAqEA,QAAMQ,qBAAqB,GAAG,IAAIC,GAAJ,EAA9B,CAxLkE,CAwLzB;;AACzCjD,IAAAA,cAAc,CAACkD,KAAf,CAAqBT,gBAArB,GAAyC,UAACA,gBAAD,EAAsB;AAC3D,aAAO,YAAa;AAAA,0CAATU,IAAS;AAATA,UAAAA,IAAS;AAAA;;AAChB,YAAIA,IAAI,CAAC,CAAD,CAAJ,KAAY,SAAhB,EAA2B;AACvB,cAAMC,sBAAsB,GAAI,OAAOD,IAAI,CAAC,CAAD,CAAX,KAAmB,UAApB,GACzBA,IAAI,CAAC,CAAD,CADqB,GAExB,OAAOA,IAAI,CAAC,CAAD,CAAX,KAAmB,QAAnB,IAA+BA,IAAI,CAAC,CAAD,CAAJ,KAAY,IAA3C,IAAmD,OAAOA,IAAI,CAAC,CAAD,CAAJ,CAAQE,WAAf,KAA+B,UAAnF,GACIF,IAAI,CAAC,CAAD,CAAJ,CAAQE,WADZ,GAEI,IAJV;;AAKA,cAAID,sBAAsB,KAAK,IAA/B,EAAqC;AACjC,gBAAME,oBAAoB,GAAGN,qBAAqB,CAAC9B,GAAtB,CAA0BiC,IAAI,CAAC,CAAD,CAA9B,CAA7B;;AACA,gBAAIG,oBAAoB,KAAKlE,SAA7B,EAAwC;AACpC+D,cAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUG,oBAAV;AACH,aAFD,MAGK;AACDH,cAAAA,IAAI,CAAC,CAAD,CAAJ,GAAU,UAACI,KAAD,EAAW;AACjB5E,gBAAAA,gCAAgC,CAACE,aAAa,CAAC2E,WAAf,EAA4B3E,aAAa,CAAC0C,UAA1C,EAAsD;AAAA,yBAAM6B,sBAAsB,CAACG,KAAD,CAA5B;AAAA,iBAAtD,CAAhC;AACH,eAFD;;AAGAP,cAAAA,qBAAqB,CAACS,GAAtB,CAA0BL,sBAA1B,EAAkDD,IAAI,CAAC,CAAD,CAAtD;AACH;AACJ;AACJ;;AACD,eAAOV,gBAAgB,CAACiB,IAAjB,CAAsB1D,cAAc,CAACkD,KAArC,EAA4CC,IAAI,CAAC,CAAD,CAAhD,EAAqDA,IAAI,CAAC,CAAD,CAAzD,EAA8DA,IAAI,CAAC,CAAD,CAAlE,CAAP;AACH,OArBD;AAsBH,KAvBuC,CAuBrCnD,cAAc,CAACkD,KAAf,CAAqBT,gBAvBgB,CAAxC;;AAwBAzC,IAAAA,cAAc,CAACkD,KAAf,CAAqBV,mBAArB,GAA4C,UAACA,mBAAD,EAAyB;AACjE,aAAO,YAAa;AAAA,2CAATW,IAAS;AAATA,UAAAA,IAAS;AAAA;;AAChB,YAAIA,IAAI,CAAC,CAAD,CAAJ,KAAY,SAAhB,EAA2B;AACvB,cAAMG,oBAAoB,GAAGN,qBAAqB,CAAC9B,GAAtB,CAA0BiC,IAAI,CAAC,CAAD,CAA9B,CAA7B;;AACA,cAAIG,oBAAoB,KAAKlE,SAA7B,EAAwC;AACpC4D,YAAAA,qBAAqB,CAACW,MAAtB,CAA6BR,IAAI,CAAC,CAAD,CAAjC;AACAA,YAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUG,oBAAV;AACH;AACJ;;AACD,eAAOd,mBAAmB,CAACkB,IAApB,CAAyB1D,cAAc,CAACkD,KAAxC,EAA+CC,IAAI,CAAC,CAAD,CAAnD,EAAwDA,IAAI,CAAC,CAAD,CAA5D,EAAiEA,IAAI,CAAC,CAAD,CAArE,CAAP;AACH,OATD;AAUH,KAX0C,CAWxCnD,cAAc,CAACkD,KAAf,CAAqBV,mBAXmB,CAA3C;;AAYA,QAAIoB,SAAS,GAAG,IAAhB;AACA5C,IAAAA,MAAM,CAAC6C,cAAP,CAAsB7D,cAAc,CAACkD,KAArC,EAA4C,WAA5C,EAAyD;AACrDhC,MAAAA,GAAG,EAAE;AAAA,eAAM0C,SAAN;AAAA,OADgD;AAErDH,MAAAA,GAAG,EAAE,aAAC5D,KAAD,EAAW;AACZ,YAAI,OAAO+D,SAAP,KAAqB,UAAzB,EAAqC;AACjC5D,UAAAA,cAAc,CAACkD,KAAf,CAAqBV,mBAArB,CAAyC,SAAzC,EAAoDoB,SAApD;AACH;;AACDA,QAAAA,SAAS,GAAI,OAAO/D,KAAP,KAAiB,UAAlB,GAAgCA,KAAhC,GAAwC,IAApD;;AACA,YAAI,OAAO+D,SAAP,KAAqB,UAAzB,EAAqC;AACjC5D,UAAAA,cAAc,CAACkD,KAAf,CAAqBT,gBAArB,CAAsC,SAAtC,EAAiDmB,SAAjD;AACA5D,UAAAA,cAAc,CAACkD,KAAf,CAAqBlB,KAArB;AACH;AACJ;AAXoD,KAAzD;AAaAjD,IAAAA,oBAAoB,CAAC+E,SAArB,CAA+BnB,IAA/B,GAAsC3C,cAAc,CAACkD,KAArD;AACA,QAAIa,qBAAqB,GAAG,IAA5B;AACA,QAAMC,4BAA4B,GAAGpG,2BAA2B,CAACiB,aAAD,EAAgBsD,2BAAhB,EAA6CpD,oBAA7C,EAAmEC,OAAnE,CAAhE;AACAgF,IAAAA,4BAA4B,CACvBC,IADL,CACU,UAACC,YAAD;AAAA,aAAkBH,qBAAqB,GAAGG,YAA1C;AAAA,KADV;AAEA,QAAM3B,MAAM,GAAG1E,kBAAkB,CAACmB,OAAO,CAACC,cAAT,EAAyBD,OAAO,CAACM,YAAjC,CAAjC;AACA,QAAM6E,OAAO,GAAGtG,kBAAkB,CAACmB,OAAO,CAACE,eAAT,EAA0BF,OAAO,CAACG,kBAAlC,CAAlC;AACA,QAAMuD,UAAU,GAAI3D,oBAAoB,CAACgB,oBAArB,KAA8CX,SAA/C,GACf,EADe,GAEfL,oBAAoB,CAACgB,oBAArB,CACKJ,MADL,CACY,UAACyE,MAAD;AAAA,UAAWxD,IAAX,SAAWA,IAAX;AAAA,+BAA4BwD,MAA5B,sBAAqCxD,IAArC,EAA4C,IAAIyD,YAAJ,CAAiB,GAAjB,CAA5C;AAAA,KADZ,EACkF,EADlF,CAFJ;AAIA,QAAIC,QAAQ,GAAG,IAAf;;AACA,QAAMC,sBAAsB,GAAG,SAAzBA,sBAAyB,GAAM;AACjC,UAAIvF,OAAO,CAACE,eAAR,GAA0B,CAA9B,EAAiC;AAC7BsC,QAAAA,mBAAmB,CAACsB,UAApB,CAA+BrB,yBAA/B;AACH;;AACD,WAAK,IAAIrB,GAAC,GAAG,CAAR,EAAWoE,+BAA+B,GAAG,CAAlD,EAAqDpE,GAAC,GAAGpB,OAAO,CAACE,eAAjE,EAAkFkB,GAAC,IAAI,CAAvF,EAA0F;AACtF,YAAMqE,uBAAuB,GAAG/C,wBAAwB,CAACtB,GAAD,CAAxD;;AACA,aAAK,IAAIwB,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAG5C,OAAO,CAACG,kBAAR,CAA2BiB,GAA3B,CAApB,EAAmDwB,EAAC,IAAI,CAAxD,EAA2D;AACvDH,UAAAA,yBAAyB,CAACqB,UAA1B,CAAqC2B,uBAArC,EAA8DD,+BAA+B,GAAG5C,EAAhG,EAAmGA,EAAnG;AACH;;AACD4C,QAAAA,+BAA+B,IAAIxF,OAAO,CAACG,kBAAR,CAA2BiB,GAA3B,CAAnC;AACH;AACJ,KAXD;;AAYAoB,IAAAA,mBAAmB,CAACkD,cAApB,GAAqC,iBAAmC;AAAA,UAAhCC,WAAgC,SAAhCA,WAAgC;AAAA,UAAnBC,YAAmB,SAAnBA,YAAmB;;AACpE,UAAIb,qBAAqB,KAAK,IAA9B,EAAoC;AAAA,qCACvB3D,GADuB;AAE5B,eAAK,IAAIwB,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAG5C,OAAO,CAACC,cAA5B,EAA4C2C,GAAC,IAAI,CAAjD,EAAoD;AAChD,iBAAK,IAAIiD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG7F,OAAO,CAACM,YAA5B,EAA0CuF,CAAC,IAAI,CAA/C,EAAkD;AAC9CnH,cAAAA,eAAe,CAACiH,WAAD,EAAcpC,MAAM,CAACX,GAAD,CAApB,EAAyBiD,CAAzB,EAA4BA,CAA5B,EAA+BzE,GAA/B,CAAf;AACH;AACJ;;AACD,cAAIrB,oBAAoB,CAACgB,oBAArB,KAA8CX,SAAlD,EAA6D;AACzDL,YAAAA,oBAAoB,CAACgB,oBAArB,CAA0C+E,OAA1C,CAAkD,iBAAW/C,KAAX,EAAqB;AAAA,kBAAlBnB,IAAkB,SAAlBA,IAAkB;AACnElD,cAAAA,eAAe,CAACiH,WAAD,EAAcjC,UAAd,EAA0B9B,IAA1B,EAAgCnB,qBAAqB,GAAGsC,KAAxD,EAA+D3B,GAA/D,CAAf;AACH,aAFD;AAGH;;AACD,eAAK,IAAIwB,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAG5C,OAAO,CAACC,cAA5B,EAA4C2C,GAAC,IAAI,CAAjD,EAAoD;AAChD,iBAAK,IAAIiD,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAG7F,OAAO,CAACG,kBAAR,CAA2ByC,GAA3B,CAApB,EAAmDiD,EAAC,IAAI,CAAxD,EAA2D;AACvD;AACA,kBAAIV,OAAO,CAACvC,GAAD,CAAP,CAAWiD,EAAX,EAAcE,UAAd,KAA6B,CAAjC,EAAoC;AAChCZ,gBAAAA,OAAO,CAACvC,GAAD,CAAP,CAAWiD,EAAX,IAAgB,IAAIR,YAAJ,CAAiB,GAAjB,CAAhB;AACH;AACJ;AACJ;;AACD,cAAI;AACA,gBAAMW,sBAAsB,GAAGzC,MAAM,CAChCT,GAD0B,CACtB,UAACmD,KAAD,EAAQlD,KAAR,EAAkB;AACvB,kBAAMmD,kBAAkB,GAAGlH,sBAAsB,CAACkD,GAAvB,CAA2BiB,2BAA3B,CAA3B;;AACA,kBAAI+C,kBAAkB,KAAK9F,SAAvB,IAAoC8F,kBAAkB,CAAChE,GAAnB,CAAuBa,KAAvB,MAAkC3C,SAA1E,EAAqF;AACjF,uBAAO,CAAC,IAAIiF,YAAJ,CAAiB,CAAjB,CAAD,CAAP;AACH;;AACD,qBAAOY,KAAP;AACH,aAP8B,CAA/B;AAQA,gBAAME,gBAAgB,GAAGxG,gCAAgC,CAACE,aAAa,CAAC2E,WAAd,GAA6BpD,GAAC,GAAGvB,aAAa,CAAC0C,UAAhD,EAA6D1C,aAAa,CAAC0C,UAA3E,EAAuF;AAAA,qBAAMwC,qBAAqB,CAACqB,OAAtB,CAA8BJ,sBAA9B,EAAsDb,OAAtD,EAA+DzB,UAA/D,CAAN;AAAA,aAAvF,CAAzD;AACA4B,YAAAA,QAAQ,GAAGa,gBAAX;;AACA,iBAAK,IAAIvD,GAAC,GAAG,CAAR,EAAW4C,+BAA+B,GAAG,CAAlD,EAAqD5C,GAAC,GAAG5C,OAAO,CAACE,eAAjE,EAAkF0C,GAAC,IAAI,CAAvF,EAA0F;AACtF,mBAAK,IAAIiD,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAG7F,OAAO,CAACG,kBAAR,CAA2ByC,GAA3B,CAApB,EAAmDiD,GAAC,IAAI,CAAxD,EAA2D;AACvDlH,gBAAAA,aAAa,CAACiH,YAAD,EAAeT,OAAO,CAACvC,GAAD,CAAtB,EAA2BiD,GAA3B,EAA8BL,+BAA+B,GAAGK,GAAhE,EAAmEzE,GAAnE,CAAb;AACH;;AACDoE,cAAAA,+BAA+B,IAAIxF,OAAO,CAACG,kBAAR,CAA2ByC,GAA3B,CAAnC;AACH;AACJ,WAjBD,CAkBA,OAAOyD,KAAP,EAAc;AACVf,YAAAA,QAAQ,GAAG,KAAX;AACAnC,YAAAA,2BAA2B,CAACY,aAA5B,CAA0C,IAAIuC,UAAJ,CAAe,gBAAf,EAAiC;AAAED,cAAAA,KAAK,EAALA;AAAF,aAAjC,CAA1C;AACH;;AACD,cAAI,CAACf,QAAL,EAAe;AACX,iBAAK,IAAI1C,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAG5C,OAAO,CAACC,cAA5B,EAA4C2C,GAAC,IAAI,CAAjD,EAAoD;AAChD1B,cAAAA,SAAS,CAAC0B,GAAD,CAAT,CAAakB,UAAb,CAAwB3C,yBAAyB,CAACyB,GAAD,CAAjD;;AACA,mBAAK,IAAIiD,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAG7F,OAAO,CAACM,YAA5B,EAA0CuF,GAAC,IAAI,CAA/C,EAAkD;AAC9C1E,gBAAAA,yBAAyB,CAACC,GAAD,CAAzB,CAA6B0C,UAA7B,CAAwC3B,sBAAxC,EAAgE0D,GAAhE,EAAoEjD,GAAC,GAAG5C,OAAO,CAACM,YAAb,GAA6BuF,GAAhG;AACH;AACJ;;AACD,gBAAI9F,oBAAoB,CAACgB,oBAArB,KAA8CX,SAAlD,EAA6D;AACzD,kBAAMG,MAAM,GAAGR,oBAAoB,CAACgB,oBAArB,CAA0CR,MAAzD;;AACA,mBAAK,IAAIqC,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGrC,MAApB,EAA4BqC,GAAC,IAAI,CAAjC,EAAoC;AAChC,oBAAMf,kBAAkB,GAAGL,mBAAmB,CAACoB,GAAD,CAA9C;AACAf,gBAAAA,kBAAkB,CAACiC,UAAnB,CAA8B3B,sBAA9B,EAAsD,CAAtD,EAAyD1B,qBAAqB,GAAGmC,GAAjF;AACAf,gBAAAA,kBAAkB,CAAC0E,IAAnB;AACH;AACJ;;AACDpE,YAAAA,sBAAsB,CAAC2B,UAAvB,CAAkCtB,mBAAlC;AACAA,YAAAA,mBAAmB,CAACkD,cAApB,GAAqC,IAArC,CAhBW,CAgBgC;;AAC3C,gBAAIc,WAAJ,EAAiB;AACbjB,cAAAA,sBAAsB;AACzB;;AACD;AACH;AA/D2B;;AAChC,aAAK,IAAInE,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGkB,UAApB,EAAgClB,GAAC,IAAI,GAArC,EAA0C;AAAA,4BAAjCA,GAAiC;;AAAA,gCA6DlC;AAEP;AACJ;AACJ,KAnED;;AAoEA,QAAIoF,WAAW,GAAG,KAAlB;;AACA,QAAMC,aAAa,GAAG,SAAhBA,aAAgB,GAAM;AACxB,UAAInB,QAAJ,EAAc;AACV,YAAItF,OAAO,CAACE,eAAR,GAA0B,CAA9B,EAAiC;AAC7BsC,UAAAA,mBAAmB,CAACG,OAApB,CAA4BF,yBAA5B;AACH;;AACD,aAAK,IAAIrB,GAAC,GAAG,CAAR,EAAWoE,+BAA+B,GAAG,CAAlD,EAAqDpE,GAAC,GAAGpB,OAAO,CAACE,eAAjE,EAAkFkB,GAAC,IAAI,CAAvF,EAA0F;AACtF,cAAMqE,uBAAuB,GAAG/C,wBAAwB,CAACtB,GAAD,CAAxD;;AACA,eAAK,IAAIwB,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAG5C,OAAO,CAACG,kBAAR,CAA2BiB,GAA3B,CAApB,EAAmDwB,GAAC,IAAI,CAAxD,EAA2D;AACvDH,YAAAA,yBAAyB,CAACE,OAA1B,CAAkC8C,uBAAlC,EAA2DD,+BAA+B,GAAG5C,GAA7F,EAAgGA,GAAhG;AACH;;AACD4C,UAAAA,+BAA+B,IAAIxF,OAAO,CAACG,kBAAR,CAA2BiB,GAA3B,CAAnC;AACH;AACJ;;AACDoF,MAAAA,WAAW,GAAG,IAAd;AACH,KAdD;;AAeA,QAAME,gBAAgB,GAAG,SAAnBA,gBAAmB,GAAM;AAC3B,UAAIpB,QAAJ,EAAc;AACVC,QAAAA,sBAAsB;AACzB;;AACDiB,MAAAA,WAAW,GAAG,KAAd;AACH,KALD;;AAMA,WAAO5G,kBAAkB,CAACuD,2BAAD,EAA8BsD,aAA9B,EAA6CC,gBAA7C,CAAzB;AACH,GA9VD;AA+VH,CAhWM","sourcesContent":["import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport const createNativeAudioWorkletNodeFakerFactory = (auxiliaryGainNodeStore, connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, monitorConnections) => {\n    return (nativeContext, baseLatency, processorConstructor, options) => {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n            throw createNotSupportedError();\n        }\n        if (options.outputChannelCount !== undefined) {\n            // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n            if (options.outputChannelCount.some((channelCount) => (channelCount < 1))) {\n                throw createNotSupportedError();\n            }\n            if (options.outputChannelCount.length !== options.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n        }\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n            throw createNotSupportedError();\n        }\n        const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const numberOfParameters = (processorConstructor.parameterDescriptors === undefined)\n            ? 0\n            : processorConstructor.parameterDescriptors.length;\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n            throw createNotSupportedError();\n        }\n        const messageChannel = new MessageChannel();\n        const gainNodes = [];\n        const inputChannelSplitterNodes = [];\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes.push(createNativeGainNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n            }));\n            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n            }));\n        }\n        const constantSourceNodes = [];\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: (options.parameterData[name] !== undefined)\n                        ? options.parameterData[name]\n                        : (defaultValue === undefined)\n                            ? 0\n                            : defaultValue\n                });\n                Object.defineProperties(constantSourceNode.offset, {\n                    defaultValue: {\n                        get: () => (defaultValue === undefined) ? 0 : defaultValue\n                    },\n                    maxValue: {\n                        get: () => (maxValue === undefined) ? MOST_POSITIVE_SINGLE_FLOAT : maxValue\n                    },\n                    minValue: {\n                        get: () => (minValue === undefined) ? MOST_NEGATIVE_SINGLE_FLOAT : minValue\n                    }\n                });\n                constantSourceNodes.push(constantSourceNode);\n            }\n        }\n        const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, \n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        Math.max(1, numberOfOutputChannels));\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n        for (let i = 0; i < options.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: options.outputChannelCount[i]\n            }));\n        }\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n            for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, (i * options.channelCount) + j);\n            }\n        }\n        const parameterMap = new ReadOnlyMap((processorConstructor.parameterDescriptors === undefined)\n            ? []\n            : processorConstructor.parameterDescriptors\n                .map(({ name }, index) => {\n                const constantSourceNode = constantSourceNodes[index];\n                constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                constantSourceNode.start(0);\n                return [name, constantSourceNode.offset];\n            }));\n        inputChannelMergerNode.connect(scriptProcessorNode);\n        let channelInterpretation = options.channelInterpretation;\n        let onprocessorerror = null;\n        // Bug #87: Expose at least one output to make this node connectable.\n        const outputAudioNodes = (options.numberOfOutputs === 0) ? [scriptProcessorNode] : outputChannelMergerNodes;\n        const nativeAudioWorkletNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return options.channelCount;\n            },\n            set channelCount(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelCountMode() {\n                return options.channelCountMode;\n            },\n            set channelCountMode(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelInterpretation() {\n                return channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                for (const gainNode of gainNodes) {\n                    gainNode.channelInterpretation = value;\n                }\n                channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return gainNodes;\n            },\n            get numberOfInputs() {\n                return options.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return options.numberOfOutputs;\n            },\n            get onprocessorerror() {\n                return onprocessorerror;\n            },\n            set onprocessorerror(value) {\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n                }\n                onprocessorerror = (typeof value === 'function') ? value : null;\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n                }\n            },\n            get parameters() {\n                return parameterMap;\n            },\n            get port() {\n                return messageChannel.port2;\n            },\n            addEventListener(...args) {\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n            disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        const patchedEventListeners = new Map(); // tslint:disable-line:max-line-length\n        messageChannel.port1.addEventListener = ((addEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const unpatchedEventListener = (typeof args[1] === 'function')\n                        ? args[1]\n                        : (typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function')\n                            ? args[1].handleEvent\n                            : null;\n                    if (unpatchedEventListener !== null) {\n                        const patchedEventListener = patchedEventListeners.get(args[1]);\n                        if (patchedEventListener !== undefined) {\n                            args[1] = patchedEventListener;\n                        }\n                        else {\n                            args[1] = (event) => {\n                                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));\n                            };\n                            patchedEventListeners.set(unpatchedEventListener, args[1]);\n                        }\n                    }\n                }\n                return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.addEventListener);\n        messageChannel.port1.removeEventListener = ((removeEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const patchedEventListener = patchedEventListeners.get(args[1]);\n                    if (patchedEventListener !== undefined) {\n                        patchedEventListeners.delete(args[1]);\n                        args[1] = patchedEventListener;\n                    }\n                }\n                return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.removeEventListener);\n        let onmessage = null;\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n            get: () => onmessage,\n            set: (value) => {\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.removeEventListener('message', onmessage);\n                }\n                onmessage = (typeof value === 'function') ? value : null;\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.addEventListener('message', onmessage);\n                    messageChannel.port1.start();\n                }\n            }\n        });\n        processorConstructor.prototype.port = messageChannel.port1;\n        let audioWorkletProcessor = null;\n        const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n        audioWorkletProcessorPromise\n            .then((dWrkltPrcssr) => audioWorkletProcessor = dWrkltPrcssr);\n        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n        const parameters = (processorConstructor.parameterDescriptors === undefined) ?\n            [] :\n            processorConstructor.parameterDescriptors\n                .reduce((prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n        let isActive = true;\n        const disconnectOutputsGraph = () => {\n            if (options.numberOfOutputs > 0) {\n                scriptProcessorNode.disconnect(outputChannelSplitterNode);\n            }\n            for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                const outputChannelMergerNode = outputChannelMergerNodes[i];\n                for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                    outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                }\n                outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n            }\n        };\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }) => {\n            if (audioWorkletProcessor !== null) {\n                for (let i = 0; i < bufferSize; i += 128) {\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(inputBuffer, inputs[j], k, k, i);\n                        }\n                    }\n                    if (processorConstructor.parameterDescriptors !== undefined) {\n                        processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                            copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                    }\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                            // The byteLength will be 0 when the ArrayBuffer was transferred.\n                            if (outputs[j][k].byteLength === 0) {\n                                outputs[j][k] = new Float32Array(128);\n                            }\n                        }\n                    }\n                    try {\n                        const potentiallyEmptyInputs = inputs\n                            .map((input, index) => {\n                            const auxiliaryGainNodes = auxiliaryGainNodeStore.get(nativeAudioWorkletNodeFaker);\n                            if (auxiliaryGainNodes === undefined || auxiliaryGainNodes.get(index) === undefined) {\n                                return [new Float32Array(0)];\n                            }\n                            return input;\n                        });\n                        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + (i / nativeContext.sampleRate), nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n                        isActive = activeSourceFlag;\n                        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                            }\n                            outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n                        }\n                    }\n                    catch (error) {\n                        isActive = false;\n                        nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', { error }));\n                    }\n                    if (!isActive) {\n                        for (let j = 0; j < options.numberOfInputs; j += 1) {\n                            gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n                            for (let k = 0; k < options.channelCount; k += 1) {\n                                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, (j * options.channelCount) + k);\n                            }\n                        }\n                        if (processorConstructor.parameterDescriptors !== undefined) {\n                            const length = processorConstructor.parameterDescriptors.length;\n                            for (let j = 0; j < length; j += 1) {\n                                const constantSourceNode = constantSourceNodes[j];\n                                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                                constantSourceNode.stop();\n                            }\n                        }\n                        inputChannelMergerNode.disconnect(scriptProcessorNode);\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        if (isConnected) {\n                            disconnectOutputsGraph();\n                        }\n                        break;\n                    }\n                }\n            }\n        };\n        let isConnected = false;\n        const whenConnected = () => {\n            if (isActive) {\n                if (options.numberOfOutputs > 0) {\n                    scriptProcessorNode.connect(outputChannelSplitterNode);\n                }\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n                }\n            }\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            if (isActive) {\n                disconnectOutputsGraph();\n            }\n            isConnected = false;\n        };\n        return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-worklet-node-faker-factory.js.map"]},"metadata":{},"sourceType":"module"}