{"ast":null,"code":"export default function (topology) {\n  var oldObjects = topology.objects,\n      newObjects = {},\n      oldArcs = topology.arcs,\n      oldArcsLength = oldArcs.length,\n      oldIndex = -1,\n      newIndexByOldIndex = new Array(oldArcsLength),\n      newArcsLength = 0,\n      newArcs,\n      newIndex = -1,\n      key;\n\n  function scanGeometry(input) {\n    switch (input.type) {\n      case \"GeometryCollection\":\n        input.geometries.forEach(scanGeometry);\n        break;\n\n      case \"LineString\":\n        scanArcs(input.arcs);\n        break;\n\n      case \"MultiLineString\":\n        input.arcs.forEach(scanArcs);\n        break;\n\n      case \"Polygon\":\n        input.arcs.forEach(scanArcs);\n        break;\n\n      case \"MultiPolygon\":\n        input.arcs.forEach(scanMultiArcs);\n        break;\n    }\n  }\n\n  function scanArc(index) {\n    if (index < 0) index = ~index;\n    if (!newIndexByOldIndex[index]) newIndexByOldIndex[index] = 1, ++newArcsLength;\n  }\n\n  function scanArcs(arcs) {\n    arcs.forEach(scanArc);\n  }\n\n  function scanMultiArcs(arcs) {\n    arcs.forEach(scanArcs);\n  }\n\n  function reindexGeometry(input) {\n    var output;\n\n    switch (input.type) {\n      case \"GeometryCollection\":\n        output = {\n          type: \"GeometryCollection\",\n          geometries: input.geometries.map(reindexGeometry)\n        };\n        break;\n\n      case \"LineString\":\n        output = {\n          type: \"LineString\",\n          arcs: reindexArcs(input.arcs)\n        };\n        break;\n\n      case \"MultiLineString\":\n        output = {\n          type: \"MultiLineString\",\n          arcs: input.arcs.map(reindexArcs)\n        };\n        break;\n\n      case \"Polygon\":\n        output = {\n          type: \"Polygon\",\n          arcs: input.arcs.map(reindexArcs)\n        };\n        break;\n\n      case \"MultiPolygon\":\n        output = {\n          type: \"MultiPolygon\",\n          arcs: input.arcs.map(reindexMultiArcs)\n        };\n        break;\n\n      default:\n        return input;\n    }\n\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function reindexArc(oldIndex) {\n    return oldIndex < 0 ? ~newIndexByOldIndex[~oldIndex] : newIndexByOldIndex[oldIndex];\n  }\n\n  function reindexArcs(arcs) {\n    return arcs.map(reindexArc);\n  }\n\n  function reindexMultiArcs(arcs) {\n    return arcs.map(reindexArcs);\n  }\n\n  for (key in oldObjects) {\n    scanGeometry(oldObjects[key]);\n  }\n\n  newArcs = new Array(newArcsLength);\n\n  while (++oldIndex < oldArcsLength) {\n    if (newIndexByOldIndex[oldIndex]) {\n      newIndexByOldIndex[oldIndex] = ++newIndex;\n      newArcs[newIndex] = oldArcs[oldIndex];\n    }\n  }\n\n  for (key in oldObjects) {\n    newObjects[key] = reindexGeometry(oldObjects[key]);\n  }\n\n  return {\n    type: \"Topology\",\n    bbox: topology.bbox,\n    transform: topology.transform,\n    objects: newObjects,\n    arcs: newArcs\n  };\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/topojson/node_modules/topojson-simplify/src/prune.js"],"names":["topology","oldObjects","objects","newObjects","oldArcs","arcs","oldArcsLength","length","oldIndex","newIndexByOldIndex","Array","newArcsLength","newArcs","newIndex","key","scanGeometry","input","type","geometries","forEach","scanArcs","scanMultiArcs","scanArc","index","reindexGeometry","output","map","reindexArcs","reindexMultiArcs","id","bbox","properties","reindexArc","transform"],"mappings":"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","sourcesContent":["export default function(topology) {\n  var oldObjects = topology.objects,\n      newObjects = {},\n      oldArcs = topology.arcs,\n      oldArcsLength = oldArcs.length,\n      oldIndex = -1,\n      newIndexByOldIndex = new Array(oldArcsLength),\n      newArcsLength = 0,\n      newArcs,\n      newIndex = -1,\n      key;\n\n  function scanGeometry(input) {\n    switch (input.type) {\n      case \"GeometryCollection\": input.geometries.forEach(scanGeometry); break;\n      case \"LineString\": scanArcs(input.arcs); break;\n      case \"MultiLineString\": input.arcs.forEach(scanArcs); break;\n      case \"Polygon\": input.arcs.forEach(scanArcs); break;\n      case \"MultiPolygon\": input.arcs.forEach(scanMultiArcs); break;\n    }\n  }\n\n  function scanArc(index) {\n    if (index < 0) index = ~index;\n    if (!newIndexByOldIndex[index]) newIndexByOldIndex[index] = 1, ++newArcsLength;\n  }\n\n  function scanArcs(arcs) {\n    arcs.forEach(scanArc);\n  }\n\n  function scanMultiArcs(arcs) {\n    arcs.forEach(scanArcs);\n  }\n\n  function reindexGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(reindexGeometry)}; break;\n      case \"LineString\": output = {type: \"LineString\", arcs: reindexArcs(input.arcs)}; break;\n      case \"MultiLineString\": output = {type: \"MultiLineString\", arcs: input.arcs.map(reindexArcs)}; break;\n      case \"Polygon\": output = {type: \"Polygon\", arcs: input.arcs.map(reindexArcs)}; break;\n      case \"MultiPolygon\": output = {type: \"MultiPolygon\", arcs: input.arcs.map(reindexMultiArcs)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function reindexArc(oldIndex) {\n    return oldIndex < 0 ? ~newIndexByOldIndex[~oldIndex] : newIndexByOldIndex[oldIndex];\n  }\n\n  function reindexArcs(arcs) {\n    return arcs.map(reindexArc);\n  }\n\n  function reindexMultiArcs(arcs) {\n    return arcs.map(reindexArcs);\n  }\n\n  for (key in oldObjects) {\n    scanGeometry(oldObjects[key]);\n  }\n\n  newArcs = new Array(newArcsLength);\n\n  while (++oldIndex < oldArcsLength) {\n    if (newIndexByOldIndex[oldIndex]) {\n      newIndexByOldIndex[oldIndex] = ++newIndex;\n      newArcs[newIndex] = oldArcs[oldIndex];\n    }\n  }\n\n  for (key in oldObjects) {\n    newObjects[key] = reindexGeometry(oldObjects[key]);\n  }\n\n  return {\n    type: \"Topology\",\n    bbox: topology.bbox,\n    transform: topology.transform,\n    objects: newObjects,\n    arcs: newArcs\n  };\n}\n"]},"metadata":{},"sourceType":"module"}