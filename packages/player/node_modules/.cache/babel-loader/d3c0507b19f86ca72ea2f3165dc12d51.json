{"ast":null,"code":"import debug from \"debug\";\nimport { AudioContextEngine } from \"./AudioContextEngine\";\nconst log = debug(\"atpls:sampler\");\nexport function createAudioEffects(audioset, ctx, buffers) {\n  return new AudioEffects(audioset, ctx, buffers);\n}\n\nclass AudioEffects {\n  constructor(audioset, ctx, buffers) {\n    this.audioset = audioset;\n    this.sampler = void 0;\n    log(\"init AudioEffects %s\", audioset.meta.title);\n    this.sampler = new Sampler(buffers, ctx);\n    this.sampler.initTracks(audioset.tracks);\n  }\n\n  attach() {// nothing to do?\n  }\n\n  detach() {\n    this.sampler.disconnect();\n  }\n\n  run(command) {\n    const time = command.time;\n\n    switch (command.command) {\n      case \"startClip\":\n        const clipId = command.clipId;\n        const trackId = this.audioset.index.trackIdOfClip[clipId];\n        log(\"start %s\", clipId);\n        return this.sampler.start(clipId, trackId, time);\n\n      case \"stopClip\":\n        log(\"stop %s\", command.clipId);\n        return this.sampler.stop(command.clipId, time);\n\n      default:\n    }\n  }\n\n}\n\nclass Sampler {\n  constructor(buffers, ctx) {\n    this.buffers = buffers;\n    this.master = void 0;\n    this.tracks = {};\n    this.audioSources = {};\n    this.audio = void 0;\n    this.audio = new AudioContextEngine(ctx);\n    this.master = this.audio.createTrack(\"master\", {\n      volume: 0.8\n    });\n  }\n\n  initTracks(tracks) {\n    tracks.forEach(track => {\n      this.tracks[track.id] = this.audio.createTrack(track.name, {\n        volume: 1\n      }, this.master);\n    });\n  }\n\n  connect() {// nothing to do?\n  }\n\n  disconnect() {\n    Object.keys(this.tracks).forEach(trackId => {\n      this.tracks[trackId].disconnect();\n    });\n  }\n\n  start(clipId, trackId, time) {\n    if (this.audioSources[clipId]) {\n      return;\n    }\n\n    const buffer = this.buffers.getBuffer(clipId);\n    const track = this.tracks[trackId];\n    const source = this.audio.createAudioSource({\n      buffer\n    }, track);\n    this.audioSources[clipId] = source;\n    source.start(time);\n  }\n\n  stop(clipId, time) {\n    const source = this.audioSources[clipId];\n\n    if (source !== undefined) {\n      source.stop(time);\n    }\n\n    this.audioSources[clipId] = undefined;\n  }\n\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/src/player/Audio/AudioEffects.ts"],"names":["debug","AudioContextEngine","log","createAudioEffects","audioset","ctx","buffers","AudioEffects","constructor","sampler","meta","title","Sampler","initTracks","tracks","attach","detach","disconnect","run","command","time","clipId","trackId","index","trackIdOfClip","start","stop","master","audioSources","audio","createTrack","volume","forEach","track","id","name","connect","Object","keys","buffer","getBuffer","source","createAudioSource","undefined"],"mappings":"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","sourcesContent":["import debug from \"debug\";\nimport { IAudioContext } from \"standardized-audio-context\";\nimport { Audioset } from \"../../audioset\";\nimport { ControlCommand, Effects } from \"../Control\";\nimport { AudioEngine, AudioSource, AudioTrack } from \"./Audio\";\nimport { AudioContextEngine } from \"./AudioContextEngine\";\n\nconst log = debug(\"atpls:sampler\");\n\nexport interface SampleBuffers {\n  getBuffer(clipId: string): any;\n}\n\nexport function createAudioEffects(\n  audioset: Audioset,\n  ctx: IAudioContext,\n  buffers: SampleBuffers,\n): AudioEffects {\n  return new AudioEffects(audioset, ctx, buffers);\n}\n\nclass AudioEffects implements Effects {\n  public sampler: Sampler;\n  constructor(\n    private audioset: Audioset,\n    ctx: IAudioContext,\n    buffers: SampleBuffers,\n  ) {\n    log(\"init AudioEffects %s\", audioset.meta.title);\n    this.sampler = new Sampler(buffers, ctx);\n    this.sampler.initTracks(audioset.tracks);\n  }\n\n  public attach() {\n    // nothing to do?\n  }\n\n  public detach() {\n    this.sampler.disconnect();\n  }\n\n  public run(command: ControlCommand) {\n    const time = command.time;\n    switch (command.command) {\n      case \"startClip\":\n        const clipId = command.clipId;\n        const trackId = this.audioset.index.trackIdOfClip[clipId];\n        log(\"start %s\", clipId);\n        return this.sampler.start(clipId, trackId, time);\n      case \"stopClip\":\n        log(\"stop %s\", command.clipId);\n        return this.sampler.stop(command.clipId, time);\n      default:\n    }\n  }\n}\n\ninterface SamplerTrack {\n  id: string;\n  name: string;\n  volume?: number;\n}\nclass Sampler {\n  private master: AudioTrack;\n  private tracks: Record<string, AudioTrack> = {};\n  private audioSources: Record<string, AudioSource | undefined> = {};\n  private audio: AudioContextEngine;\n\n  constructor(private buffers: SampleBuffers, ctx: IAudioContext) {\n    this.audio = new AudioContextEngine(ctx);\n    this.master = this.audio.createTrack(\"master\", { volume: 0.8 });\n  }\n\n  public initTracks(tracks: SamplerTrack[]) {\n    tracks.forEach(track => {\n      this.tracks[track.id] = this.audio.createTrack(\n        track.name,\n        { volume: 1 },\n        this.master,\n      );\n    });\n  }\n\n  public connect() {\n    // nothing to do?\n  }\n\n  public disconnect() {\n    Object.keys(this.tracks).forEach(trackId => {\n      this.tracks[trackId].disconnect();\n    });\n  }\n\n  public start(clipId: string, trackId: string, time: number) {\n    if (this.audioSources[clipId]) {\n      return;\n    }\n\n    const buffer = this.buffers.getBuffer(clipId);\n    const track = this.tracks[trackId];\n    const source = this.audio.createAudioSource({ buffer }, track);\n    this.audioSources[clipId] = source;\n\n    source.start(time);\n  }\n\n  public stop(clipId: string, time: number) {\n    const source = this.audioSources[clipId];\n    if (source !== undefined) {\n      source.stop(time);\n    }\n    this.audioSources[clipId] = undefined;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}