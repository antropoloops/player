{"ast":null,"code":"import hashmap from \"./hash/hashmap\";\nimport equalPoint from \"./hash/point-equal\";\nimport hashPoint from \"./hash/point-hash\"; // Given a cut topology, combines duplicate arcs.\n\nexport default function (topology) {\n  var coordinates = topology.coordinates,\n      lines = topology.lines,\n      line,\n      rings = topology.rings,\n      ring,\n      arcCount = lines.length + rings.length,\n      i,\n      n;\n  delete topology.lines;\n  delete topology.rings; // Count the number of (non-unique) arcs to initialize the hashmap safely.\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i];\n\n    while (line = line.next) ++arcCount;\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i];\n\n    while (ring = ring.next) ++arcCount;\n  }\n\n  var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),\n      arcs = topology.arcs = [];\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i];\n\n    do {\n      dedupLine(line);\n    } while (line = line.next);\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i];\n\n    if (ring.next) {\n      // arc is no longer closed\n      do {\n        dedupLine(ring);\n      } while (ring = ring.next);\n    } else {\n      dedupRing(ring);\n    }\n  }\n\n  function dedupLine(arc) {\n    var startPoint, endPoint, startArcs, startArc, endArcs, endArc, i, n; // Does this arc match an existing arc in order?\n\n    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {\n      for (i = 0, n = startArcs.length; i < n; ++i) {\n        startArc = startArcs[i];\n\n        if (equalLine(startArc, arc)) {\n          arc[0] = startArc[0];\n          arc[1] = startArc[1];\n          return;\n        }\n      }\n    } // Does this arc match an existing arc in reverse order?\n\n\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n\n        if (reverseEqualLine(endArc, arc)) {\n          arc[1] = endArc[0];\n          arc[0] = endArc[1];\n          return;\n        }\n      }\n    }\n\n    if (startArcs) startArcs.push(arc);else arcsByEnd.set(startPoint, [arc]);\n    if (endArcs) endArcs.push(arc);else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function dedupRing(arc) {\n    var endPoint, endArcs, endArc, i, n; // Does this arc match an existing line in order, or reverse order?\n    // Rings are closed, so their start point and end point is the same.\n\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    } // Otherwise, does this arc match an existing ring in order, or reverse order?\n\n\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    if (endArcs) endArcs.push(arc);else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function equalLine(arcA, arcB) {\n    var ia = arcA[0],\n        ib = arcB[0],\n        ja = arcA[1],\n        jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n\n    for (; ia <= ja; ++ia, ++ib) if (!equalPoint(coordinates[ia], coordinates[ib])) return false;\n\n    return true;\n  }\n\n  function reverseEqualLine(arcA, arcB) {\n    var ia = arcA[0],\n        ib = arcB[0],\n        ja = arcA[1],\n        jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n\n    for (; ia <= ja; ++ia, --jb) if (!equalPoint(coordinates[ia], coordinates[jb])) return false;\n\n    return true;\n  }\n\n  function equalRing(arcA, arcB) {\n    var ia = arcA[0],\n        ib = arcB[0],\n        ja = arcA[1],\n        jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = findMinimumOffset(arcB);\n\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;\n    }\n\n    return true;\n  }\n\n  function reverseEqualRing(arcA, arcB) {\n    var ia = arcA[0],\n        ib = arcB[0],\n        ja = arcA[1],\n        jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = n - findMinimumOffset(arcB);\n\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;\n    }\n\n    return true;\n  } // Rings are rotated to a consistent, but arbitrary, start point.\n  // This is necessary to detect when a ring and a rotated copy are dupes.\n\n\n  function findMinimumOffset(arc) {\n    var start = arc[0],\n        end = arc[1],\n        mid = start,\n        minimum = mid,\n        minimumPoint = coordinates[mid];\n\n    while (++mid < end) {\n      var point = coordinates[mid];\n\n      if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {\n        minimum = mid;\n        minimumPoint = point;\n      }\n    }\n\n    return minimum - start;\n  }\n\n  return topology;\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/topojson/node_modules/topojson-server/src/dedup.js"],"names":["hashmap","equalPoint","hashPoint","topology","coordinates","lines","line","rings","ring","arcCount","length","i","n","next","arcsByEnd","arcs","dedupLine","dedupRing","arc","startPoint","endPoint","startArcs","startArc","endArcs","endArc","get","equalLine","reverseEqualLine","push","set","equalRing","reverseEqualRing","findMinimumOffset","arcA","arcB","ia","ib","ja","jb","ka","kb","start","end","mid","minimum","minimumPoint","point"],"mappings":"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","sourcesContent":["import hashmap from \"./hash/hashmap\";\nimport equalPoint from \"./hash/point-equal\";\nimport hashPoint from \"./hash/point-hash\";\n\n// Given a cut topology, combines duplicate arcs.\nexport default function(topology) {\n  var coordinates = topology.coordinates,\n      lines = topology.lines, line,\n      rings = topology.rings, ring,\n      arcCount = lines.length + rings.length,\n      i, n;\n\n  delete topology.lines;\n  delete topology.rings;\n\n  // Count the number of (non-unique) arcs to initialize the hashmap safely.\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i]; while (line = line.next) ++arcCount;\n  }\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i]; while (ring = ring.next) ++arcCount;\n  }\n\n  var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),\n      arcs = topology.arcs = [];\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i];\n    do {\n      dedupLine(line);\n    } while (line = line.next);\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i];\n    if (ring.next) { // arc is no longer closed\n      do {\n        dedupLine(ring);\n      } while (ring = ring.next);\n    } else {\n      dedupRing(ring);\n    }\n  }\n\n  function dedupLine(arc) {\n    var startPoint,\n        endPoint,\n        startArcs, startArc,\n        endArcs, endArc,\n        i, n;\n\n    // Does this arc match an existing arc in order?\n    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {\n      for (i = 0, n = startArcs.length; i < n; ++i) {\n        startArc = startArcs[i];\n        if (equalLine(startArc, arc)) {\n          arc[0] = startArc[0];\n          arc[1] = startArc[1];\n          return;\n        }\n      }\n    }\n\n    // Does this arc match an existing arc in reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (reverseEqualLine(endArc, arc)) {\n          arc[1] = endArc[0];\n          arc[0] = endArc[1];\n          return;\n        }\n      }\n    }\n\n    if (startArcs) startArcs.push(arc); else arcsByEnd.set(startPoint, [arc]);\n    if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function dedupRing(arc) {\n    var endPoint,\n        endArcs,\n        endArc,\n        i, n;\n\n    // Does this arc match an existing line in order, or reverse order?\n    // Rings are closed, so their start point and end point is the same.\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    // Otherwise, does this arc match an existing ring in order, or reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function equalLine(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, ++ib) if (!equalPoint(coordinates[ia], coordinates[ib])) return false;\n    return true;\n  }\n\n  function reverseEqualLine(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, --jb) if (!equalPoint(coordinates[ia], coordinates[jb])) return false;\n    return true;\n  }\n\n  function equalRing(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;\n    }\n    return true;\n  }\n\n  function reverseEqualRing(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = n - findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;\n    }\n    return true;\n  }\n\n  // Rings are rotated to a consistent, but arbitrary, start point.\n  // This is necessary to detect when a ring and a rotated copy are dupes.\n  function findMinimumOffset(arc) {\n    var start = arc[0],\n        end = arc[1],\n        mid = start,\n        minimum = mid,\n        minimumPoint = coordinates[mid];\n    while (++mid < end) {\n      var point = coordinates[mid];\n      if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {\n        minimum = mid;\n        minimumPoint = point;\n      }\n    }\n    return minimum - start;\n  }\n\n  return topology;\n}\n"]},"metadata":{},"sourceType":"module"}