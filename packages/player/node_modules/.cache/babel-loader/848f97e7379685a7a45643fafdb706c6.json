{"ast":null,"code":"export default function (objects, bbox, n) {\n  var x0 = bbox[0],\n      y0 = bbox[1],\n      x1 = bbox[2],\n      y1 = bbox[3],\n      kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,\n      ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;\n\n  function quantizePoint(input) {\n    return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];\n  }\n\n  function quantizePoints(input, m) {\n    var i = -1,\n        j = 0,\n        n = input.length,\n        output = new Array(n),\n        // pessimistic\n    pi,\n        px,\n        py,\n        x,\n        y;\n\n    while (++i < n) {\n      pi = input[i];\n      x = Math.round((pi[0] - x0) * kx);\n      y = Math.round((pi[1] - y0) * ky);\n      if (x !== px || y !== py) output[j++] = [px = x, py = y]; // non-coincident points\n    }\n\n    output.length = j;\n\n    while (j < m) j = output.push([output[0][0], output[0][1]]);\n\n    return output;\n  }\n\n  function quantizeLine(input) {\n    return quantizePoints(input, 2);\n  }\n\n  function quantizeRing(input) {\n    return quantizePoints(input, 4);\n  }\n\n  function quantizePolygon(input) {\n    return input.map(quantizeRing);\n  }\n\n  function quantizeGeometry(o) {\n    if (o != null && quantizeGeometryType.hasOwnProperty(o.type)) quantizeGeometryType[o.type](o);\n  }\n\n  var quantizeGeometryType = {\n    GeometryCollection: function (o) {\n      o.geometries.forEach(quantizeGeometry);\n    },\n    Point: function (o) {\n      o.coordinates = quantizePoint(o.coordinates);\n    },\n    MultiPoint: function (o) {\n      o.coordinates = o.coordinates.map(quantizePoint);\n    },\n    LineString: function (o) {\n      o.arcs = quantizeLine(o.arcs);\n    },\n    MultiLineString: function (o) {\n      o.arcs = o.arcs.map(quantizeLine);\n    },\n    Polygon: function (o) {\n      o.arcs = quantizePolygon(o.arcs);\n    },\n    MultiPolygon: function (o) {\n      o.arcs = o.arcs.map(quantizePolygon);\n    }\n  };\n\n  for (var key in objects) {\n    quantizeGeometry(objects[key]);\n  }\n\n  return {\n    scale: [1 / kx, 1 / ky],\n    translate: [x0, y0]\n  };\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/topojson-server/src/prequantize.js"],"names":["objects","bbox","n","x0","y0","x1","y1","kx","ky","quantizePoint","input","Math","round","quantizePoints","m","i","j","length","output","Array","pi","px","py","x","y","push","quantizeLine","quantizeRing","quantizePolygon","map","quantizeGeometry","o","quantizeGeometryType","hasOwnProperty","type","GeometryCollection","geometries","forEach","Point","coordinates","MultiPoint","LineString","arcs","MultiLineString","Polygon","MultiPolygon","key","scale","translate"],"mappings":"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","sourcesContent":["export default function(objects, bbox, n) {\n  var x0 = bbox[0],\n      y0 = bbox[1],\n      x1 = bbox[2],\n      y1 = bbox[3],\n      kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,\n      ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;\n\n  function quantizePoint(input) {\n    return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];\n  }\n\n  function quantizePoints(input, m) {\n    var i = -1,\n        j = 0,\n        n = input.length,\n        output = new Array(n), // pessimistic\n        pi,\n        px,\n        py,\n        x,\n        y;\n\n    while (++i < n) {\n      pi = input[i];\n      x = Math.round((pi[0] - x0) * kx);\n      y = Math.round((pi[1] - y0) * ky);\n      if (x !== px || y !== py) output[j++] = [px = x, py = y]; // non-coincident points\n    }\n\n    output.length = j;\n    while (j < m) j = output.push([output[0][0], output[0][1]]);\n    return output;\n  }\n\n  function quantizeLine(input) {\n    return quantizePoints(input, 2);\n  }\n\n  function quantizeRing(input) {\n    return quantizePoints(input, 4);\n  }\n\n  function quantizePolygon(input) {\n    return input.map(quantizeRing);\n  }\n\n  function quantizeGeometry(o) {\n    if (o != null && quantizeGeometryType.hasOwnProperty(o.type)) quantizeGeometryType[o.type](o);\n  }\n\n  var quantizeGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(quantizeGeometry); },\n    Point: function(o) { o.coordinates = quantizePoint(o.coordinates); },\n    MultiPoint: function(o) { o.coordinates = o.coordinates.map(quantizePoint); },\n    LineString: function(o) { o.arcs = quantizeLine(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(quantizeLine); },\n    Polygon: function(o) { o.arcs = quantizePolygon(o.arcs); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(quantizePolygon); }\n  };\n\n  for (var key in objects) {\n    quantizeGeometry(objects[key]);\n  }\n\n  return {\n    scale: [1 / kx, 1 / ky],\n    translate: [x0, y0]\n  };\n}\n"]},"metadata":{},"sourceType":"module"}