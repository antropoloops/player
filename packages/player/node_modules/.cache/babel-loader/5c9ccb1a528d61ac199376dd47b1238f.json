{"ast":null,"code":"import hashmap from \"./hash/hashmap\";\nimport equalPoint from \"./hash/point-equal\";\nimport hashPoint from \"./hash/point-hash\"; // Given a cut topology, combines duplicate arcs.\n\nexport default function (topology) {\n  var coordinates = topology.coordinates,\n      lines = topology.lines,\n      line,\n      rings = topology.rings,\n      ring,\n      arcCount = lines.length + rings.length,\n      i,\n      n;\n  delete topology.lines;\n  delete topology.rings; // Count the number of (non-unique) arcs to initialize the hashmap safely.\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i];\n\n    while (line = line.next) {\n      ++arcCount;\n    }\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i];\n\n    while (ring = ring.next) {\n      ++arcCount;\n    }\n  }\n\n  var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),\n      arcs = topology.arcs = [];\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i];\n\n    do {\n      dedupLine(line);\n    } while (line = line.next);\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i];\n\n    if (ring.next) {\n      // arc is no longer closed\n      do {\n        dedupLine(ring);\n      } while (ring = ring.next);\n    } else {\n      dedupRing(ring);\n    }\n  }\n\n  function dedupLine(arc) {\n    var startPoint, endPoint, startArcs, startArc, endArcs, endArc, i, n; // Does this arc match an existing arc in order?\n\n    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {\n      for (i = 0, n = startArcs.length; i < n; ++i) {\n        startArc = startArcs[i];\n\n        if (equalLine(startArc, arc)) {\n          arc[0] = startArc[0];\n          arc[1] = startArc[1];\n          return;\n        }\n      }\n    } // Does this arc match an existing arc in reverse order?\n\n\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n\n        if (reverseEqualLine(endArc, arc)) {\n          arc[1] = endArc[0];\n          arc[0] = endArc[1];\n          return;\n        }\n      }\n    }\n\n    if (startArcs) startArcs.push(arc);else arcsByEnd.set(startPoint, [arc]);\n    if (endArcs) endArcs.push(arc);else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function dedupRing(arc) {\n    var endPoint, endArcs, endArc, i, n; // Does this arc match an existing line in order, or reverse order?\n    // Rings are closed, so their start point and end point is the same.\n\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    } // Otherwise, does this arc match an existing ring in order, or reverse order?\n\n\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    if (endArcs) endArcs.push(arc);else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function equalLine(arcA, arcB) {\n    var ia = arcA[0],\n        ib = arcB[0],\n        ja = arcA[1],\n        jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n\n    for (; ia <= ja; ++ia, ++ib) {\n      if (!equalPoint(coordinates[ia], coordinates[ib])) return false;\n    }\n\n    return true;\n  }\n\n  function reverseEqualLine(arcA, arcB) {\n    var ia = arcA[0],\n        ib = arcB[0],\n        ja = arcA[1],\n        jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n\n    for (; ia <= ja; ++ia, --jb) {\n      if (!equalPoint(coordinates[ia], coordinates[jb])) return false;\n    }\n\n    return true;\n  }\n\n  function equalRing(arcA, arcB) {\n    var ia = arcA[0],\n        ib = arcB[0],\n        ja = arcA[1],\n        jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = findMinimumOffset(arcB);\n\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;\n    }\n\n    return true;\n  }\n\n  function reverseEqualRing(arcA, arcB) {\n    var ia = arcA[0],\n        ib = arcB[0],\n        ja = arcA[1],\n        jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = n - findMinimumOffset(arcB);\n\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;\n    }\n\n    return true;\n  } // Rings are rotated to a consistent, but arbitrary, start point.\n  // This is necessary to detect when a ring and a rotated copy are dupes.\n\n\n  function findMinimumOffset(arc) {\n    var start = arc[0],\n        end = arc[1],\n        mid = start,\n        minimum = mid,\n        minimumPoint = coordinates[mid];\n\n    while (++mid < end) {\n      var point = coordinates[mid];\n\n      if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {\n        minimum = mid;\n        minimumPoint = point;\n      }\n    }\n\n    return minimum - start;\n  }\n\n  return topology;\n}","map":null,"metadata":{},"sourceType":"module"}