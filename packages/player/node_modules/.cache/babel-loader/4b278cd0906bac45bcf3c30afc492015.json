{"ast":null,"code":"import { detachArrayBuffer } from '../helpers/detach-array-buffer';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createDecodeAudioData = (audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, detachedArrayBuffers, getNativeContext, isNativeContext, isNativeOfflineAudioContext, nativeOfflineAudioContextConstructor, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n  return (anyContext, audioData) => {\n    const nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext); // Bug #43: Only Chrome and Opera do throw a DataCloneError.\n\n    if (detachedArrayBuffers.has(audioData)) {\n      const err = createDataCloneError();\n      return Promise.reject(err);\n    } // The audioData parameter maybe of a type which can't be added to a WeakSet.\n\n\n    try {\n      detachedArrayBuffers.add(audioData);\n    } catch (_a) {} // Ignore errors.\n    // Bug #21: Safari does not support promises yet.\n\n\n    if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeContext))) {\n      // Bug #101: Edge does not decode something on a closed OfflineAudioContext.\n      const nativeContextOrBackupNativeContext = nativeContext.state === 'closed' && nativeOfflineAudioContextConstructor !== null && isNativeOfflineAudioContext(nativeContext) ? new nativeOfflineAudioContextConstructor(1, 1, nativeContext.sampleRate) : nativeContext;\n      const promise = nativeContextOrBackupNativeContext.decodeAudioData(audioData).catch(err => {\n        // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.\n        if (err instanceof DOMException && err.name === 'NotSupportedError') {\n          throw new TypeError();\n        }\n\n        throw err;\n      });\n      return promise.then(audioBuffer => {\n        // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n        if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n          wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n        }\n\n        audioBufferStore.add(audioBuffer);\n        return audioBuffer;\n      });\n    } // Bug #21: Safari does not return a Promise yet.\n\n\n    return new Promise((resolve, reject) => {\n      const complete = () => {\n        // Bug #133: Safari does neuter the ArrayBuffer.\n        try {\n          detachArrayBuffer(audioData);\n        } catch (\n        /* Ignore errors. */\n        _a) {\n          /* Ignore errors. */\n        }\n      };\n\n      const fail = err => {\n        reject(err);\n        complete();\n      }; // Bug #26: Safari throws a synchronous error.\n\n\n      try {\n        // Bug #1: Safari requires a successCallback.\n        nativeContext.decodeAudioData(audioData, audioBuffer => {\n          // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n          // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n          if (typeof audioBuffer.copyFromChannel !== 'function') {\n            wrapAudioBufferCopyChannelMethods(audioBuffer);\n            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n          }\n\n          audioBufferStore.add(audioBuffer);\n          complete();\n          resolve(audioBuffer);\n        }, err => {\n          // Bug #4: Safari returns null instead of an error.\n          if (err === null) {\n            fail(createEncodingError());\n          } else {\n            fail(err);\n          }\n        });\n      } catch (err) {\n        fail(err);\n      }\n    });\n  };\n};","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/standardized-audio-context/build/es2018/factories/decode-audio-data.js"],"names":["detachArrayBuffer","wrapAudioBufferGetChannelDataMethod","createDecodeAudioData","audioBufferStore","cacheTestResult","createDataCloneError","createEncodingError","detachedArrayBuffers","getNativeContext","isNativeContext","isNativeOfflineAudioContext","nativeOfflineAudioContextConstructor","testAudioBufferCopyChannelMethodsOutOfBoundsSupport","testPromiseSupport","wrapAudioBufferCopyChannelMethods","wrapAudioBufferCopyChannelMethodsOutOfBounds","anyContext","audioData","nativeContext","has","err","Promise","reject","add","_a","nativeContextOrBackupNativeContext","state","sampleRate","promise","decodeAudioData","catch","DOMException","name","TypeError","then","audioBuffer","resolve","complete","fail","copyFromChannel"],"mappings":"AAAA,SAASA,iBAAT,QAAkC,gCAAlC;AACA,SAASC,mCAAT,QAAoD,sDAApD;AACA,OAAO,MAAMC,qBAAqB,GAAG,CAACC,gBAAD,EAAmBC,eAAnB,EAAoCC,oBAApC,EAA0DC,mBAA1D,EAA+EC,oBAA/E,EAAqGC,gBAArG,EAAuHC,eAAvH,EAAwIC,2BAAxI,EAAqKC,oCAArK,EAA2MC,mDAA3M,EAAgQC,kBAAhQ,EAAoRC,iCAApR,EAAuTC,4CAAvT,KAAwW;AACzY,SAAO,CAACC,UAAD,EAAaC,SAAb,KAA2B;AAC9B,UAAMC,aAAa,GAAGT,eAAe,CAACO,UAAD,CAAf,GAA8BA,UAA9B,GAA2CR,gBAAgB,CAACQ,UAAD,CAAjF,CAD8B,CAE9B;;AACA,QAAIT,oBAAoB,CAACY,GAArB,CAAyBF,SAAzB,CAAJ,EAAyC;AACrC,YAAMG,GAAG,GAAGf,oBAAoB,EAAhC;AACA,aAAOgB,OAAO,CAACC,MAAR,CAAeF,GAAf,CAAP;AACH,KAN6B,CAO9B;;;AACA,QAAI;AACAb,MAAAA,oBAAoB,CAACgB,GAArB,CAAyBN,SAAzB;AACH,KAFD,CAGA,OAAOO,EAAP,EAAW,CAEV,CAFD,CACI;AAEJ;;;AACA,QAAIpB,eAAe,CAACS,kBAAD,EAAqB,MAAMA,kBAAkB,CAACK,aAAD,CAA7C,CAAnB,EAAkF;AAC9E;AACA,YAAMO,kCAAkC,GAAIP,aAAa,CAACQ,KAAd,KAAwB,QAAxB,IACxCf,oCAAoC,KAAK,IADD,IAExCD,2BAA2B,CAACQ,aAAD,CAFY,GAGvC,IAAIP,oCAAJ,CAAyC,CAAzC,EAA4C,CAA5C,EAA+CO,aAAa,CAACS,UAA7D,CAHuC,GAIvCT,aAJJ;AAKA,YAAMU,OAAO,GAAGH,kCAAkC,CAC7CI,eADW,CACKZ,SADL,EAEXa,KAFW,CAEJV,GAAD,IAAS;AAChB;AACA,YAAIA,GAAG,YAAYW,YAAf,IAA+BX,GAAG,CAACY,IAAJ,KAAa,mBAAhD,EAAqE;AACjE,gBAAM,IAAIC,SAAJ,EAAN;AACH;;AACD,cAAMb,GAAN;AACH,OARe,CAAhB;AASA,aAAOQ,OAAO,CACTM,IADE,CACIC,WAAD,IAAiB;AACvB;AACA,YAAI,CAAC/B,eAAe,CAACQ,mDAAD,EAAsD,MAAMA,mDAAmD,CAACuB,WAAD,CAA/G,CAApB,EAAmJ;AAC/IpB,UAAAA,4CAA4C,CAACoB,WAAD,CAA5C;AACH;;AACDhC,QAAAA,gBAAgB,CAACoB,GAAjB,CAAqBY,WAArB;AACA,eAAOA,WAAP;AACH,OARM,CAAP;AASH,KAxC6B,CAyC9B;;;AACA,WAAO,IAAId,OAAJ,CAAY,CAACe,OAAD,EAAUd,MAAV,KAAqB;AACpC,YAAMe,QAAQ,GAAG,MAAM;AACnB;AACA,YAAI;AACArC,UAAAA,iBAAiB,CAACiB,SAAD,CAAjB;AACH,SAFD,CAGA;AAAQ;AAAoBO,QAAAA,EAA5B,EAAgC;AAAE;AAAsB;AAC3D,OAND;;AAOA,YAAMc,IAAI,GAAIlB,GAAD,IAAS;AAClBE,QAAAA,MAAM,CAACF,GAAD,CAAN;AACAiB,QAAAA,QAAQ;AACX,OAHD,CARoC,CAYpC;;;AACA,UAAI;AACA;AACAnB,QAAAA,aAAa,CAACW,eAAd,CAA8BZ,SAA9B,EAA0CkB,WAAD,IAAiB;AACtD;AACA;AACA,cAAI,OAAOA,WAAW,CAACI,eAAnB,KAAuC,UAA3C,EAAuD;AACnDzB,YAAAA,iCAAiC,CAACqB,WAAD,CAAjC;AACAlC,YAAAA,mCAAmC,CAACkC,WAAD,CAAnC;AACH;;AACDhC,UAAAA,gBAAgB,CAACoB,GAAjB,CAAqBY,WAArB;AACAE,UAAAA,QAAQ;AACRD,UAAAA,OAAO,CAACD,WAAD,CAAP;AACH,SAVD,EAUIf,GAAD,IAAS;AACR;AACA,cAAIA,GAAG,KAAK,IAAZ,EAAkB;AACdkB,YAAAA,IAAI,CAAChC,mBAAmB,EAApB,CAAJ;AACH,WAFD,MAGK;AACDgC,YAAAA,IAAI,CAAClB,GAAD,CAAJ;AACH;AACJ,SAlBD;AAmBH,OArBD,CAsBA,OAAOA,GAAP,EAAY;AACRkB,QAAAA,IAAI,CAAClB,GAAD,CAAJ;AACH;AACJ,KAtCM,CAAP;AAuCH,GAjFD;AAkFH,CAnFM","sourcesContent":["import { detachArrayBuffer } from '../helpers/detach-array-buffer';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createDecodeAudioData = (audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, detachedArrayBuffers, getNativeContext, isNativeContext, isNativeOfflineAudioContext, nativeOfflineAudioContextConstructor, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    return (anyContext, audioData) => {\n        const nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext);\n        // Bug #43: Only Chrome and Opera do throw a DataCloneError.\n        if (detachedArrayBuffers.has(audioData)) {\n            const err = createDataCloneError();\n            return Promise.reject(err);\n        }\n        // The audioData parameter maybe of a type which can't be added to a WeakSet.\n        try {\n            detachedArrayBuffers.add(audioData);\n        }\n        catch (_a) {\n            // Ignore errors.\n        }\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeContext))) {\n            // Bug #101: Edge does not decode something on a closed OfflineAudioContext.\n            const nativeContextOrBackupNativeContext = (nativeContext.state === 'closed' &&\n                nativeOfflineAudioContextConstructor !== null &&\n                isNativeOfflineAudioContext(nativeContext)) ?\n                new nativeOfflineAudioContextConstructor(1, 1, nativeContext.sampleRate) :\n                nativeContext;\n            const promise = nativeContextOrBackupNativeContext\n                .decodeAudioData(audioData)\n                .catch((err) => {\n                // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.\n                if (err instanceof DOMException && err.name === 'NotSupportedError') {\n                    throw new TypeError();\n                }\n                throw err;\n            });\n            return promise\n                .then((audioBuffer) => {\n                // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n                if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                }\n                audioBufferStore.add(audioBuffer);\n                return audioBuffer;\n            });\n        }\n        // Bug #21: Safari does not return a Promise yet.\n        return new Promise((resolve, reject) => {\n            const complete = () => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                try {\n                    detachArrayBuffer(audioData);\n                }\n                catch ( /* Ignore errors. */_a) { /* Ignore errors. */ }\n            };\n            const fail = (err) => {\n                reject(err);\n                complete();\n            };\n            // Bug #26: Safari throws a synchronous error.\n            try {\n                // Bug #1: Safari requires a successCallback.\n                nativeContext.decodeAudioData(audioData, (audioBuffer) => {\n                    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n                    // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n                    if (typeof audioBuffer.copyFromChannel !== 'function') {\n                        wrapAudioBufferCopyChannelMethods(audioBuffer);\n                        wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                    }\n                    audioBufferStore.add(audioBuffer);\n                    complete();\n                    resolve(audioBuffer);\n                }, (err) => {\n                    // Bug #4: Safari returns null instead of an error.\n                    if (err === null) {\n                        fail(createEncodingError());\n                    }\n                    else {\n                        fail(err);\n                    }\n                });\n            }\n            catch (err) {\n                fail(err);\n            }\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/decode-audio-data.js.map"]},"metadata":{},"sourceType":"module"}