{"ast":null,"code":"export const wrapAudioBufferSourceNodeStartMethodDurationParameter = (nativeAudioScheduledSourceNode, nativeContext) => {\n  let endTime = Number.POSITIVE_INFINITY;\n  let stopTime = Number.POSITIVE_INFINITY;\n\n  nativeAudioScheduledSourceNode.start = ((start, stop) => {\n    return (when = 0, offset = 0, duration = Number.POSITIVE_INFINITY) => {\n      start.call(nativeAudioScheduledSourceNode, when, offset);\n\n      if (duration >= 0 && duration < Number.POSITIVE_INFINITY) {\n        const actualStartTime = Math.max(when, nativeContext.currentTime); // @todo The playbackRate could of course also have been automated and is not always fixed.\n\n        const durationInBufferTime = duration / nativeAudioScheduledSourceNode.playbackRate.value;\n        endTime = actualStartTime + durationInBufferTime;\n        stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n      }\n    };\n  })(nativeAudioScheduledSourceNode.start, nativeAudioScheduledSourceNode.stop);\n\n  nativeAudioScheduledSourceNode.stop = (stop => {\n    return (when = 0) => {\n      stopTime = Math.max(when, nativeContext.currentTime);\n      stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n    };\n  })(nativeAudioScheduledSourceNode.stop);\n};","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-duration-parameter.js"],"names":["wrapAudioBufferSourceNodeStartMethodDurationParameter","nativeAudioScheduledSourceNode","nativeContext","endTime","Number","POSITIVE_INFINITY","stopTime","start","stop","when","offset","duration","call","actualStartTime","Math","max","currentTime","durationInBufferTime","playbackRate","value","min"],"mappings":"AAAA,OAAO,MAAMA,qDAAqD,GAAG,CAACC,8BAAD,EAAiCC,aAAjC,KAAmD;AACpH,MAAIC,OAAO,GAAGC,MAAM,CAACC,iBAArB;AACA,MAAIC,QAAQ,GAAGF,MAAM,CAACC,iBAAtB;;AACAJ,EAAAA,8BAA8B,CAACM,KAA/B,GAAuC,CAAC,CAACA,KAAD,EAAQC,IAAR,KAAiB;AACrD,WAAO,CAACC,IAAI,GAAG,CAAR,EAAWC,MAAM,GAAG,CAApB,EAAuBC,QAAQ,GAAGP,MAAM,CAACC,iBAAzC,KAA+D;AAClEE,MAAAA,KAAK,CAACK,IAAN,CAAWX,8BAAX,EAA2CQ,IAA3C,EAAiDC,MAAjD;;AACA,UAAIC,QAAQ,IAAI,CAAZ,IAAiBA,QAAQ,GAAGP,MAAM,CAACC,iBAAvC,EAA0D;AACtD,cAAMQ,eAAe,GAAGC,IAAI,CAACC,GAAL,CAASN,IAAT,EAAeP,aAAa,CAACc,WAA7B,CAAxB,CADsD,CAEtD;;AACA,cAAMC,oBAAoB,GAAIN,QAAQ,GAAGV,8BAA8B,CAACiB,YAA/B,CAA4CC,KAArF;AACAhB,QAAAA,OAAO,GAAGU,eAAe,GAAGI,oBAA5B;AACAT,QAAAA,IAAI,CAACI,IAAL,CAAUX,8BAAV,EAA0Ca,IAAI,CAACM,GAAL,CAASjB,OAAT,EAAkBG,QAAlB,CAA1C;AACH;AACJ,KATD;AAUH,GAXsC,EAWpCL,8BAA8B,CAACM,KAXK,EAWEN,8BAA8B,CAACO,IAXjC,CAAvC;;AAYAP,EAAAA,8BAA8B,CAACO,IAA/B,GAAsC,CAAEA,IAAD,IAAU;AAC7C,WAAO,CAACC,IAAI,GAAG,CAAR,KAAc;AACjBH,MAAAA,QAAQ,GAAGQ,IAAI,CAACC,GAAL,CAASN,IAAT,EAAeP,aAAa,CAACc,WAA7B,CAAX;AACAR,MAAAA,IAAI,CAACI,IAAL,CAAUX,8BAAV,EAA0Ca,IAAI,CAACM,GAAL,CAASjB,OAAT,EAAkBG,QAAlB,CAA1C;AACH,KAHD;AAIH,GALqC,EAKnCL,8BAA8B,CAACO,IALI,CAAtC;AAMH,CArBM","sourcesContent":["export const wrapAudioBufferSourceNodeStartMethodDurationParameter = (nativeAudioScheduledSourceNode, nativeContext) => {\n    let endTime = Number.POSITIVE_INFINITY;\n    let stopTime = Number.POSITIVE_INFINITY;\n    nativeAudioScheduledSourceNode.start = ((start, stop) => {\n        return (when = 0, offset = 0, duration = Number.POSITIVE_INFINITY) => {\n            start.call(nativeAudioScheduledSourceNode, when, offset);\n            if (duration >= 0 && duration < Number.POSITIVE_INFINITY) {\n                const actualStartTime = Math.max(when, nativeContext.currentTime);\n                // @todo The playbackRate could of course also have been automated and is not always fixed.\n                const durationInBufferTime = (duration / nativeAudioScheduledSourceNode.playbackRate.value);\n                endTime = actualStartTime + durationInBufferTime;\n                stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n            }\n        };\n    })(nativeAudioScheduledSourceNode.start, nativeAudioScheduledSourceNode.stop);\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            stopTime = Math.max(when, nativeContext.currentTime);\n            stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-duration-parameter.js.map"]},"metadata":{},"sourceType":"module"}