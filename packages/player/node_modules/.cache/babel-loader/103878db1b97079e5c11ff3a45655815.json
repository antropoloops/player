{"ast":null,"code":"import _regeneratorRuntime from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nexport var createRenderInputsOfAudioNode = function createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(audioNode, nativeOfflineAudioContext, nativeAudioNode, trace) {\n      var audioNodeConnections, nextTrace;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              audioNodeConnections = getAudioNodeConnections(audioNode);\n              nextTrace = [].concat(_toConsumableArray(trace), [audioNode]);\n              _context2.next = 4;\n              return Promise.all(audioNodeConnections.activeInputs.map(function (connections, input) {\n                return Array.from(connections).filter(function (_ref2) {\n                  var _ref3 = _slicedToArray(_ref2, 1),\n                      source = _ref3[0];\n\n                  return !nextTrace.includes(source);\n                }).map( /*#__PURE__*/function () {\n                  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref4) {\n                    var _ref6, source, output, audioNodeRenderer, renderedNativeAudioNode;\n\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _ref6 = _slicedToArray(_ref4, 2), source = _ref6[0], output = _ref6[1];\n                            audioNodeRenderer = getAudioNodeRenderer(source);\n                            _context.next = 4;\n                            return audioNodeRenderer.render(source, nativeOfflineAudioContext, nextTrace);\n\n                          case 4:\n                            renderedNativeAudioNode = _context.sent;\n\n                            if (!isPartOfACycle(source) && !(audioNode === audioNode.context.destination && isPartOfACycle(audioNode))) {\n                              renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n                            }\n\n                          case 6:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function (_x5) {\n                    return _ref5.apply(this, arguments);\n                  };\n                }());\n              }).reduce(function (allRenderingPromises, renderingPromises) {\n                return [].concat(_toConsumableArray(allRenderingPromises), _toConsumableArray(renderingPromises));\n              }, []));\n\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x, _x2, _x3, _x4) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/standardized-audio-context/build/es2018/factories/render-inputs-of-audio-node.js"],"names":["createRenderInputsOfAudioNode","getAudioNodeConnections","getAudioNodeRenderer","isPartOfACycle","audioNode","nativeOfflineAudioContext","nativeAudioNode","trace","audioNodeConnections","nextTrace","Promise","all","activeInputs","map","connections","input","Array","from","filter","source","includes","output","audioNodeRenderer","render","renderedNativeAudioNode","context","destination","connect","reduce","allRenderingPromises","renderingPromises"],"mappings":";;;;AAAA,OAAO,IAAMA,6BAA6B,GAAG,SAAhCA,6BAAgC,CAACC,uBAAD,EAA0BC,oBAA1B,EAAgDC,cAAhD,EAAmE;AAC5G;AAAA,wEAAO,kBAAOC,SAAP,EAAkBC,yBAAlB,EAA6CC,eAA7C,EAA8DC,KAA9D;AAAA;AAAA;AAAA;AAAA;AAAA;AACGC,cAAAA,oBADH,GAC0BP,uBAAuB,CAACG,SAAD,CADjD;AAEGK,cAAAA,SAFH,gCAEmBF,KAFnB,IAE0BH,SAF1B;AAAA;AAAA,qBAGGM,OAAO,CACRC,GADC,CACGH,oBAAoB,CAACI,YAArB,CACJC,GADI,CACA,UAACC,WAAD,EAAcC,KAAd;AAAA,uBAAwBC,KAAK,CACjCC,IAD4B,CACvBH,WADuB,EAE5BI,MAF4B,CAErB;AAAA;AAAA,sBAAEC,MAAF;;AAAA,yBAAc,CAACV,SAAS,CAACW,QAAV,CAAmBD,MAAnB,CAAf;AAAA,iBAFqB,EAG5BN,GAH4B;AAAA,uFAGxB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,8DAAQM,MAAR,aAAgBE,MAAhB;AACCC,4BAAAA,iBADD,GACqBpB,oBAAoB,CAACiB,MAAD,CADzC;AAAA;AAAA,mCAEiCG,iBAAiB,CAACC,MAAlB,CAAyBJ,MAAzB,EAAiCd,yBAAjC,EAA4DI,SAA5D,CAFjC;;AAAA;AAECe,4BAAAA,uBAFD;;AAGL,gCAAI,CAACrB,cAAc,CAACgB,MAAD,CAAf,IAA2B,EAAEf,SAAS,KAAKA,SAAS,CAACqB,OAAV,CAAkBC,WAAhC,IAA+CvB,cAAc,CAACC,SAAD,CAA/D,CAA/B,EAA4G;AACxGoB,8BAAAA,uBAAuB,CAACG,OAAxB,CAAgCrB,eAAhC,EAAiDe,MAAjD,EAAyDN,KAAzD;AACH;;AALI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAHwB;;AAAA;AAAA;AAAA;AAAA,oBAAxB;AAAA,eADA,EAWJa,MAXI,CAWG,UAACC,oBAAD,EAAuBC,iBAAvB;AAAA,oDAAiDD,oBAAjD,sBAA0EC,iBAA1E;AAAA,eAXH,EAWiG,EAXjG,CADH,CAHH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAP;;AAAA;AAAA;AAAA;AAAA;AAiBH,CAlBM","sourcesContent":["export const createRenderInputsOfAudioNode = (getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) => {\n    return async (audioNode, nativeOfflineAudioContext, nativeAudioNode, trace) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n        const nextTrace = [...trace, audioNode];\n        await Promise\n            .all(audioNodeConnections.activeInputs\n            .map((connections, input) => Array\n            .from(connections)\n            .filter(([source]) => !nextTrace.includes(source))\n            .map(async ([source, output]) => {\n            const audioNodeRenderer = getAudioNodeRenderer(source);\n            const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext, nextTrace);\n            if (!isPartOfACycle(source) && !(audioNode === audioNode.context.destination && isPartOfACycle(audioNode))) {\n                renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n            }\n        }))\n            .reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/render-inputs-of-audio-node.js.map"]},"metadata":{},"sourceType":"module"}