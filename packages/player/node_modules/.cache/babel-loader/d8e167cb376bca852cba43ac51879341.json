{"ast":null,"code":"import _classCallCheck from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _defineProperty from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nvar DEFAULT_OPTIONS = {\n  channelCount: 2,\n  // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n  channelCountMode: 'explicit',\n  channelInterpretation: 'speakers',\n  numberOfInputs: 1,\n  numberOfOutputs: 1,\n  outputChannelCount: undefined,\n  parameterData: {},\n  processorOptions: {}\n};\n\nvar createChannelCount = function createChannelCount(length) {\n  var channelCount = [];\n\n  for (var i = 0; i < length; i += 1) {\n    channelCount.push(1);\n  }\n\n  return channelCount;\n};\n\nvar sanitizedOptions = function sanitizedOptions(options) {\n  return _objectSpread({}, options, {\n    outputChannelCount: options.outputChannelCount !== undefined ? options.outputChannelCount : options.numberOfInputs === 1 && options.numberOfOutputs === 1 ?\n    /*\n     * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n     * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n     * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n     */\n    [options.channelCount] : createChannelCount(options.numberOfOutputs)\n  });\n};\n\nexport var createAudioWorkletNodeConstructor = function createAudioWorkletNodeConstructor(audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, gainNodeConstructor, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, wrapEventListener) {\n  return (\n    /*#__PURE__*/\n    function (_audioNodeConstructor) {\n      _inherits(AudioWorkletNode, _audioNodeConstructor);\n\n      function AudioWorkletNode(context, name) {\n        var _this;\n\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;\n\n        _classCallCheck(this, AudioWorkletNode);\n\n        var nativeContext = getNativeContext(context);\n        var isOffline = isNativeOfflineAudioContext(nativeContext);\n        var mergedOptions = sanitizedOptions(_objectSpread({}, DEFAULT_OPTIONS, {}, options));\n        var nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n        var processorConstructor = nodeNameToProcessorConstructorMap === undefined ? undefined : nodeNameToProcessorConstructorMap.get(name);\n        var nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n        var audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null;\n        /*\n         * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n         * returns false.\n         */\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(AudioWorkletNode).call(this, context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer));\n        var parameters = [];\n        nativeAudioWorkletNode.parameters.forEach(function (nativeAudioParam, nm) {\n          var audioParam = createAudioParam(_assertThisInitialized(_this), isOffline, nativeAudioParam);\n          parameters.push([nm, audioParam]);\n        });\n        _this._nativeAudioWorkletNode = nativeAudioWorkletNode; // Bug #86 & #87: Every browser but Firefox needs to get an unused output which should not be exposed.\n\n        _this._numberOfOutputs = options.numberOfOutputs === 0 ? 0 : _this._nativeAudioWorkletNode.numberOfOutputs;\n        _this._onprocessorerror = null;\n        _this._parameters = new ReadOnlyMap(parameters);\n        /*\n         * Bug #86 & #87: Every browser but Firefox needs an output to be connected.\n         *\n         * Bug #50: Only Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore this is currently faked by\n         * using another AudioContext. And that is the reason why this will fail in case of a closed AudioContext.\n         */\n\n        if (context.state !== 'closed') {\n          var gainNode = new gainNodeConstructor(context, {\n            gain: 0\n          });\n\n          try {\n            _this.connect(gainNode).connect(context.destination);\n          } catch (err) {\n            if (err.name !== 'IndexSizeError') {\n              throw err; // tslint:disable-line:rxjs-throw-error\n            }\n          }\n        }\n\n        return _this;\n      }\n\n      _createClass(AudioWorkletNode, [{\n        key: \"numberOfOutputs\",\n        get: function get() {\n          return this._numberOfOutputs;\n        }\n      }, {\n        key: \"onprocessorerror\",\n        get: function get() {\n          return this._onprocessorerror;\n        },\n        set: function set(value) {\n          var wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n          this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n          var nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n          this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;\n        }\n      }, {\n        key: \"parameters\",\n        get: function get() {\n          if (this._parameters === null) {\n            // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n            return this._nativeAudioWorkletNode.parameters;\n          }\n\n          return this._parameters;\n        }\n      }, {\n        key: \"port\",\n        get: function get() {\n          return this._nativeAudioWorkletNode.port;\n        }\n      }]);\n\n      return AudioWorkletNode;\n    }(audioNodeConstructor)\n  );\n};","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/standardized-audio-context/build/es2018/factories/audio-worklet-node-constructor.js"],"names":["NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS","ReadOnlyMap","DEFAULT_OPTIONS","channelCount","channelCountMode","channelInterpretation","numberOfInputs","numberOfOutputs","outputChannelCount","undefined","parameterData","processorOptions","createChannelCount","length","i","push","sanitizedOptions","options","createAudioWorkletNodeConstructor","audioNodeConstructor","createAudioParam","createAudioWorkletNodeRenderer","createNativeAudioWorkletNode","gainNodeConstructor","getNativeContext","isNativeOfflineAudioContext","nativeAudioWorkletNodeConstructor","wrapEventListener","context","name","nativeContext","isOffline","mergedOptions","nodeNameToProcessorConstructorMap","get","processorConstructor","nativeAudioWorkletNode","baseLatency","audioWorkletNodeRenderer","parameters","forEach","nativeAudioParam","nm","audioParam","_nativeAudioWorkletNode","_numberOfOutputs","_onprocessorerror","_parameters","state","gainNode","gain","connect","destination","err","value","wrappedListener","onprocessorerror","nativeOnProcessorError","port"],"mappings":"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","sourcesContent":["import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    outputChannelCount: undefined,\n    parameterData: {},\n    processorOptions: {}\n};\nconst createChannelCount = (length) => {\n    const channelCount = [];\n    for (let i = 0; i < length; i += 1) {\n        channelCount.push(1);\n    }\n    return channelCount;\n};\nconst sanitizedOptions = (options) => {\n    return {\n        ...options,\n        outputChannelCount: (options.outputChannelCount !== undefined) ?\n            options.outputChannelCount :\n            (options.numberOfInputs === 1 && options.numberOfOutputs === 1) ?\n                /*\n                 * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n                 * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n                 * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n                 */\n                [options.channelCount] :\n                createChannelCount(options.numberOfOutputs)\n    };\n};\nexport const createAudioWorkletNodeConstructor = (audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, gainNodeConstructor, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, wrapEventListener) => {\n    return class AudioWorkletNode extends audioNodeConstructor {\n        constructor(context, name, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = (nodeNameToProcessorConstructorMap === undefined) ?\n                undefined :\n                nodeNameToProcessorConstructorMap.get(name);\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n            const audioWorkletNodeRenderer = ((isOffline)\n                ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor)\n                : null);\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n            const parameters = [];\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n                parameters.push([nm, audioParam]);\n            });\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            // Bug #86 & #87: Every browser but Firefox needs to get an unused output which should not be exposed.\n            this._numberOfOutputs = (options.numberOfOutputs === 0) ? 0 : this._nativeAudioWorkletNode.numberOfOutputs;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n            /*\n             * Bug #86 & #87: Every browser but Firefox needs an output to be connected.\n             *\n             * Bug #50: Only Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore this is currently faked by\n             * using another AudioContext. And that is the reason why this will fail in case of a closed AudioContext.\n             */\n            if (context.state !== 'closed') {\n                const gainNode = new gainNodeConstructor(context, { gain: 0 });\n                try {\n                    this\n                        .connect(gainNode)\n                        .connect(context.destination);\n                }\n                catch (err) {\n                    if (err.name !== 'IndexSizeError') {\n                        throw err; // tslint:disable-line:rxjs-throw-error\n                    }\n                }\n            }\n        }\n        get numberOfOutputs() {\n            return this._numberOfOutputs;\n        }\n        get onprocessorerror() {\n            return this._onprocessorerror;\n        }\n        set onprocessorerror(value) {\n            const wrappedListener = (typeof value === 'function')\n                ? wrapEventListener(this, value)\n                : null;\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n            this._onprocessorerror = (nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener)\n                ? value\n                : nativeOnProcessorError;\n        }\n        get parameters() {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return this._nativeAudioWorkletNode.parameters;\n            }\n            return this._parameters;\n        }\n        get port() {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-worklet-node-constructor.js.map"]},"metadata":{},"sourceType":"module"}