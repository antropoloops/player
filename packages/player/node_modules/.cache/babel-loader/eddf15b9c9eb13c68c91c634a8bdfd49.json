{"ast":null,"code":"import { geoProjectionMutator as projectionMutator } from \"d3-geo\";\nimport { cos, halfPi, pi, sin, sqrt } from \"./math.js\";\nimport { solve } from \"./newton.js\";\nexport function foucautSinusoidalRaw(alpha) {\n  var beta = 1 - alpha,\n      equatorial = raw(pi, 0)[0] - raw(-pi, 0)[0],\n      polar = raw(0, halfPi)[1] - raw(0, -halfPi)[1],\n      ratio = sqrt(2 * polar / equatorial);\n\n  function raw(lambda, phi) {\n    var cosphi = cos(phi),\n        sinphi = sin(phi);\n    return [cosphi / (beta + alpha * cosphi) * lambda, beta * phi + alpha * sinphi];\n  }\n\n  function forward(lambda, phi) {\n    var p = raw(lambda, phi);\n    return [p[0] * ratio, p[1] / ratio];\n  }\n\n  function forwardMeridian(phi) {\n    return forward(0, phi)[1];\n  }\n\n  forward.invert = function (x, y) {\n    var phi = solve(forwardMeridian, y),\n        lambda = x / ratio * (alpha + beta / cos(phi));\n    return [lambda, phi];\n  };\n\n  return forward;\n}\nexport default function () {\n  var alpha = 0.5,\n      m = projectionMutator(foucautSinusoidalRaw),\n      p = m(alpha);\n\n  p.alpha = function (_) {\n    return arguments.length ? m(alpha = +_) : alpha;\n  };\n\n  return p.scale(168.725);\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/d3-geo-projection/src/foucautSinusoidal.js"],"names":["geoProjectionMutator","projectionMutator","cos","halfPi","pi","sin","sqrt","solve","foucautSinusoidalRaw","alpha","beta","equatorial","raw","polar","ratio","lambda","phi","cosphi","sinphi","forward","p","forwardMeridian","invert","x","y","m","_","arguments","length","scale"],"mappings":"AAAA,SAAQA,oBAAoB,IAAIC,iBAAhC,QAAwD,QAAxD;AACA,SAAQC,GAAR,EAAaC,MAAb,EAAqBC,EAArB,EAAyBC,GAAzB,EAA8BC,IAA9B,QAAyC,WAAzC;AACA,SAAQC,KAAR,QAAoB,aAApB;AAEA,OAAO,SAASC,oBAAT,CAA8BC,KAA9B,EAAqC;AAC1C,MAAIC,IAAI,GAAG,IAAID,KAAf;AAAA,MACIE,UAAU,GAAGC,GAAG,CAACR,EAAD,EAAK,CAAL,CAAH,CAAW,CAAX,IAAgBQ,GAAG,CAAC,CAACR,EAAF,EAAM,CAAN,CAAH,CAAY,CAAZ,CADjC;AAAA,MAEIS,KAAK,GAAGD,GAAG,CAAC,CAAD,EAAIT,MAAJ,CAAH,CAAe,CAAf,IAAoBS,GAAG,CAAC,CAAD,EAAI,CAACT,MAAL,CAAH,CAAgB,CAAhB,CAFhC;AAAA,MAGIW,KAAK,GAAGR,IAAI,CAAC,IAAIO,KAAJ,GAAYF,UAAb,CAHhB;;AAKA,WAASC,GAAT,CAAaG,MAAb,EAAqBC,GAArB,EAA0B;AACxB,QAAIC,MAAM,GAAGf,GAAG,CAACc,GAAD,CAAhB;AAAA,QACIE,MAAM,GAAGb,GAAG,CAACW,GAAD,CADhB;AAEA,WAAO,CACLC,MAAM,IAAIP,IAAI,GAAGD,KAAK,GAAGQ,MAAnB,CAAN,GAAmCF,MAD9B,EAELL,IAAI,GAAGM,GAAP,GAAaP,KAAK,GAAGS,MAFhB,CAAP;AAID;;AAED,WAASC,OAAT,CAAiBJ,MAAjB,EAAyBC,GAAzB,EAA8B;AAC5B,QAAII,CAAC,GAAGR,GAAG,CAACG,MAAD,EAASC,GAAT,CAAX;AACA,WAAO,CAACI,CAAC,CAAC,CAAD,CAAD,GAAON,KAAR,EAAeM,CAAC,CAAC,CAAD,CAAD,GAAON,KAAtB,CAAP;AACD;;AAED,WAASO,eAAT,CAAyBL,GAAzB,EAA8B;AAC5B,WAAOG,OAAO,CAAC,CAAD,EAAIH,GAAJ,CAAP,CAAgB,CAAhB,CAAP;AACD;;AAEDG,EAAAA,OAAO,CAACG,MAAR,GAAiB,UAASC,CAAT,EAAYC,CAAZ,EAAe;AAC9B,QAAIR,GAAG,GAAGT,KAAK,CAACc,eAAD,EAAkBG,CAAlB,CAAf;AAAA,QACIT,MAAM,GAAGQ,CAAC,GAAGT,KAAJ,IAAaL,KAAK,GAAGC,IAAI,GAAGR,GAAG,CAACc,GAAD,CAA/B,CADb;AAEA,WAAO,CAACD,MAAD,EAASC,GAAT,CAAP;AACD,GAJD;;AAMA,SAAOG,OAAP;AACD;AAED,eAAe,YAAW;AACxB,MAAIV,KAAK,GAAG,GAAZ;AAAA,MACIgB,CAAC,GAAGxB,iBAAiB,CAACO,oBAAD,CADzB;AAAA,MAEIY,CAAC,GAAGK,CAAC,CAAChB,KAAD,CAFT;;AAIAW,EAAAA,CAAC,CAACX,KAAF,GAAU,UAASiB,CAAT,EAAY;AACpB,WAAOC,SAAS,CAACC,MAAV,GAAmBH,CAAC,CAAChB,KAAK,GAAG,CAACiB,CAAV,CAApB,GAAmCjB,KAA1C;AACD,GAFD;;AAIA,SAAOW,CAAC,CACHS,KADE,CACI,OADJ,CAAP;AAED","sourcesContent":["import {geoProjectionMutator as projectionMutator} from \"d3-geo\";\nimport {cos, halfPi, pi, sin, sqrt} from \"./math.js\";\nimport {solve} from \"./newton.js\";\n\nexport function foucautSinusoidalRaw(alpha) {\n  var beta = 1 - alpha,\n      equatorial = raw(pi, 0)[0] - raw(-pi, 0)[0],\n      polar = raw(0, halfPi)[1] - raw(0, -halfPi)[1],\n      ratio = sqrt(2 * polar / equatorial);\n\n  function raw(lambda, phi) {\n    var cosphi = cos(phi),\n        sinphi = sin(phi);\n    return [\n      cosphi / (beta + alpha * cosphi) * lambda,\n      beta * phi + alpha * sinphi\n    ];\n  }\n\n  function forward(lambda, phi) {\n    var p = raw(lambda, phi);\n    return [p[0] * ratio, p[1] / ratio];\n  }\n\n  function forwardMeridian(phi) {\n    return forward(0, phi)[1];\n  }\n\n  forward.invert = function(x, y) {\n    var phi = solve(forwardMeridian, y),\n        lambda = x / ratio * (alpha + beta / cos(phi));\n    return [lambda, phi];\n  };\n\n  return forward;\n}\n\nexport default function() {\n  var alpha = 0.5,\n      m = projectionMutator(foucautSinusoidalRaw),\n      p = m(alpha);\n\n  p.alpha = function(_) {\n    return arguments.length ? m(alpha = +_) : alpha;\n  };\n\n  return p\n      .scale(168.725);\n}\n"]},"metadata":{},"sourceType":"module"}