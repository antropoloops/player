{"ast":null,"code":"import _defineProperty from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/dani/Antropoloops/atpls-player/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nvar DEFAULT_OPTIONS = {\n  numberOfChannels: 1\n};\nexport var createAudioBufferConstructor = function createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) {\n  var nativeOfflineAudioContext = null;\n  return (\n    /*#__PURE__*/\n    function () {\n      function AudioBuffer(options) {\n        _classCallCheck(this, AudioBuffer);\n\n        if (nativeOfflineAudioContextConstructor === null) {\n          throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n\n        var _DEFAULT_OPTIONS$opti = _objectSpread({}, DEFAULT_OPTIONS, {}, options),\n            length = _DEFAULT_OPTIONS$opti.length,\n            numberOfChannels = _DEFAULT_OPTIONS$opti.numberOfChannels,\n            sampleRate = _DEFAULT_OPTIONS$opti.sampleRate;\n\n        if (nativeOfflineAudioContext === null) {\n          nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        }\n        /*\n         * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n         * factory function. But since Firefox also supports the constructor everything should be fine.\n         */\n\n\n        var audioBuffer = nativeAudioBufferConstructor !== null && cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport) ? new nativeAudioBufferConstructor({\n          length: length,\n          numberOfChannels: numberOfChannels,\n          sampleRate: sampleRate\n        }) : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate); // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n\n        if (audioBuffer.numberOfChannels === 0) {\n          throw createNotSupportedError();\n        } // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n\n\n        if (typeof audioBuffer.copyFromChannel !== 'function') {\n          wrapAudioBufferCopyChannelMethods(audioBuffer);\n          wrapAudioBufferGetChannelDataMethod(audioBuffer); // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n        } else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, function () {\n          return testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer);\n        })) {\n          wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n        }\n\n        audioBufferStore.add(audioBuffer);\n        /*\n         * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n         * (Offline)AudioContexts.\n         */\n\n        return audioBuffer;\n      }\n\n      _createClass(AudioBuffer, null, [{\n        key: Symbol.hasInstance,\n        value: function value(instance) {\n          return instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype || audioBufferStore.has(instance);\n        }\n      }]);\n\n      return AudioBuffer;\n    }()\n  );\n};","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/standardized-audio-context/build/es2018/factories/audio-buffer-constructor.js"],"names":["testAudioBufferCopyChannelMethodsOutOfBoundsSupport","wrapAudioBufferGetChannelDataMethod","DEFAULT_OPTIONS","numberOfChannels","createAudioBufferConstructor","audioBufferStore","cacheTestResult","createNotSupportedError","nativeAudioBufferConstructor","nativeOfflineAudioContextConstructor","testNativeAudioBufferConstructorSupport","wrapAudioBufferCopyChannelMethods","wrapAudioBufferCopyChannelMethodsOutOfBounds","nativeOfflineAudioContext","options","Error","length","sampleRate","audioBuffer","createBuffer","copyFromChannel","add","Symbol","hasInstance","instance","Object","getPrototypeOf","AudioBuffer","prototype","has"],"mappings":";;;;;;;;AAAA,SAASA,mDAAT,QAAoE,yEAApE;AACA,SAASC,mCAAT,QAAoD,sDAApD;AACA,IAAMC,eAAe,GAAG;AACpBC,EAAAA,gBAAgB,EAAE;AADE,CAAxB;AAGA,OAAO,IAAMC,4BAA4B,GAAG,SAA/BA,4BAA+B,CAACC,gBAAD,EAAmBC,eAAnB,EAAoCC,uBAApC,EAA6DC,4BAA7D,EAA2FC,oCAA3F,EAAiIC,uCAAjI,EAA0KC,iCAA1K,EAA6MC,4CAA7M,EAA8P;AACtS,MAAIC,yBAAyB,GAAG,IAAhC;AACA;AAAA;AAAA;AACI,2BAAYC,OAAZ,EAAqB;AAAA;;AACjB,YAAIL,oCAAoC,KAAK,IAA7C,EAAmD;AAC/C,gBAAM,IAAIM,KAAJ,CAAU,qDAAV,CAAN;AACH;;AAHgB,sDAIqCb,eAJrC,MAIyDY,OAJzD;AAAA,YAITE,MAJS,yBAITA,MAJS;AAAA,YAIDb,gBAJC,yBAIDA,gBAJC;AAAA,YAIiBc,UAJjB,yBAIiBA,UAJjB;;AAKjB,YAAIJ,yBAAyB,KAAK,IAAlC,EAAwC;AACpCA,UAAAA,yBAAyB,GAAG,IAAIJ,oCAAJ,CAAyC,CAAzC,EAA4C,CAA5C,EAA+C,KAA/C,CAA5B;AACH;AACD;;;;;;AAIA,YAAMS,WAAW,GAAIV,4BAA4B,KAAK,IAAjC,IACjBF,eAAe,CAACI,uCAAD,EAA0CA,uCAA1C,CADC,GAEhB,IAAIF,4BAAJ,CAAiC;AAAEQ,UAAAA,MAAM,EAANA,MAAF;AAAUb,UAAAA,gBAAgB,EAAhBA,gBAAV;AAA4Bc,UAAAA,UAAU,EAAVA;AAA5B,SAAjC,CAFgB,GAGhBJ,yBAAyB,CAACM,YAA1B,CAAuChB,gBAAvC,EAAyDa,MAAzD,EAAiEC,UAAjE,CAHJ,CAZiB,CAgBjB;;AACA,YAAIC,WAAW,CAACf,gBAAZ,KAAiC,CAArC,EAAwC;AACpC,gBAAMI,uBAAuB,EAA7B;AACH,SAnBgB,CAoBjB;AACA;;;AACA,YAAI,OAAOW,WAAW,CAACE,eAAnB,KAAuC,UAA3C,EAAuD;AACnDT,UAAAA,iCAAiC,CAACO,WAAD,CAAjC;AACAjB,UAAAA,mCAAmC,CAACiB,WAAD,CAAnC,CAFmD,CAGnD;AACH,SAJD,MAKK,IAAI,CAACZ,eAAe,CAACN,mDAAD,EAAsD;AAAA,iBAAMA,mDAAmD,CAACkB,WAAD,CAAzD;AAAA,SAAtD,CAApB,EAAmJ;AACpJN,UAAAA,4CAA4C,CAACM,WAAD,CAA5C;AACH;;AACDb,QAAAA,gBAAgB,CAACgB,GAAjB,CAAqBH,WAArB;AACA;;;;;AAIA,eAAOA,WAAP;AACH;;AArCL;AAAA,aAsCYI,MAAM,CAACC,WAtCnB;AAAA,8BAsCgCC,QAtChC,EAsC0C;AAClC,iBAAQA,QAAQ,KAAK,IAAb,IAAqB,OAAOA,QAAP,KAAoB,QAAzC,IAAqDC,MAAM,CAACC,cAAP,CAAsBF,QAAtB,MAAoCG,WAAW,CAACC,SAAtG,IACCvB,gBAAgB,CAACwB,GAAjB,CAAqBL,QAArB,CADR;AAEH;AAzCL;;AAAA;AAAA;AAAA;AA2CH,CA7CM","sourcesContent":["import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createAudioBufferConstructor = (audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    let nativeOfflineAudioContext = null;\n    return class AudioBuffer {\n        constructor(options) {\n            if (nativeOfflineAudioContextConstructor === null) {\n                throw new Error('Missing the native OfflineAudioContext constructor.');\n            }\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            if (nativeOfflineAudioContext === null) {\n                nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n            }\n            /*\n             * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n             * factory function. But since Firefox also supports the constructor everything should be fine.\n             */\n            const audioBuffer = (nativeAudioBufferConstructor !== null &&\n                cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport)) ?\n                new nativeAudioBufferConstructor({ length, numberOfChannels, sampleRate }) :\n                nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n            // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n            if (audioBuffer.numberOfChannels === 0) {\n                throw createNotSupportedError();\n            }\n            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n            // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n            if (typeof audioBuffer.copyFromChannel !== 'function') {\n                wrapAudioBufferCopyChannelMethods(audioBuffer);\n                wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n            }\n            else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            }\n            audioBufferStore.add(audioBuffer);\n            /*\n             * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n             * (Offline)AudioContexts.\n             */\n            return audioBuffer;\n        }\n        static [Symbol.hasInstance](instance) {\n            return (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype)\n                || (audioBufferStore.has(instance));\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-buffer-constructor.js.map"]},"metadata":{},"sourceType":"module"}