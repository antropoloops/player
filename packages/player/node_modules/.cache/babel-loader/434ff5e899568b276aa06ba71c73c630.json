{"ast":null,"code":"import { geoProjection as projection } from \"d3-geo\";\nimport { abs, cos, halfPi, pi, sign, sin, sqrt } from \"./math.js\";\nimport { solve } from \"./newton.js\"; // Based on Torben Jansen's implementation\n// https://beta.observablehq.com/@toja/nicolosi-globular-projection\n// https://beta.observablehq.com/@toja/nicolosi-globular-inverse\n\nexport function nicolosiRaw(lambda, phi) {\n  var sinPhi = sin(phi),\n      q = cos(phi),\n      s = sign(lambda);\n  if (lambda === 0 || abs(phi) === halfPi) return [0, phi];else if (phi === 0) return [lambda, 0];else if (abs(lambda) === halfPi) return [lambda * q, halfPi * sinPhi];\n  var b = pi / (2 * lambda) - 2 * lambda / pi,\n      c = 2 * phi / pi,\n      d = (1 - c * c) / (sinPhi - c);\n  var b2 = b * b,\n      d2 = d * d,\n      b2d2 = 1 + b2 / d2,\n      d2b2 = 1 + d2 / b2;\n  var M = (b * sinPhi / d - b / 2) / b2d2,\n      N = (d2 * sinPhi / b2 + d / 2) / d2b2,\n      m = M * M + q * q / b2d2,\n      n = N * N - (d2 * sinPhi * sinPhi / b2 + d * sinPhi - 1) / d2b2;\n  return [halfPi * (M + sqrt(m) * s), halfPi * (N + sqrt(n < 0 ? 0 : n) * sign(-phi * b) * s)];\n}\n\nnicolosiRaw.invert = function (x, y) {\n  x /= halfPi;\n  y /= halfPi;\n  var x2 = x * x,\n      y2 = y * y,\n      x2y2 = x2 + y2,\n      pi2 = pi * pi;\n  return [x ? (x2y2 - 1 + sqrt((1 - x2y2) * (1 - x2y2) + 4 * x2)) / (2 * x) * halfPi : 0, solve(function (phi) {\n    return x2y2 * (pi * sin(phi) - 2 * phi) * pi + 4 * phi * phi * (y - sin(phi)) + 2 * pi * phi - pi2 * y;\n  }, 0)];\n};\n\nexport default function () {\n  return projection(nicolosiRaw).scale(127.267);\n}","map":null,"metadata":{},"sourceType":"module"}