{"ast":null,"code":"import debug from \"debug\";\nimport { getAudioContext } from \"./AudioContext\";\nconst log = debug(\"atpls:time\");\nexport class TimeManager {\n  constructor({\n    bpm,\n    quantize\n  }) {\n    this.bpm = void 0;\n    this.quantize = void 0;\n    this.count = 0;\n    this.startedAt = 0;\n    this.context = void 0;\n    this.bpm = bpm;\n    this.quantize = quantize || 1;\n    getAudioContext().then(ctx => this.context = ctx);\n  }\n\n  startTime(time) {\n    if (!this.context) {\n      return time;\n    }\n\n    time = this.nextTime(time);\n    this.count += 1;\n\n    if (this.count === 1) {\n      this.startedAt = time;\n    }\n\n    return time;\n  }\n\n  stopTime(time) {\n    if (!this.context) {\n      return time;\n    }\n\n    time = this.nextTime(time);\n    this.count -= 1;\n\n    if (this.count === 0) {\n      this.startedAt = 0;\n    }\n\n    return time;\n  }\n\n  nextTime(time) {\n    console.log(\"NEXT!\", time, this);\n\n    if (!this.context) {\n      return time;\n    }\n\n    const now = this.context.currentTime;\n\n    if (this.startedAt === 0) {\n      return now;\n    }\n\n    return quantizeTime(this.bpm, now, this.startedAt, this.quantize);\n  }\n\n}\nconst BEATS = 1;\n/**\n * Calculate the time remaining until the next beat\n *\n * @param {*} bpm\n * @param {*} now\n * @param {*} startedAt\n * @param {*} beats\n */\n\nexport function quantizeTime(bpm, now, startedAt, beats = BEATS) {\n  const factor = bpm / (60 * beats);\n  const absolute = now - startedAt;\n\n  if (absolute === 0) {\n    return 0;\n  }\n\n  const inBeats = absolute * factor;\n  const mod = inBeats % 1;\n  const offsetTime = (1 - mod) / factor;\n  return offsetTime;\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/src/player/TimeManager.ts"],"names":["debug","getAudioContext","log","TimeManager","constructor","bpm","quantize","count","startedAt","context","then","ctx","startTime","time","nextTime","stopTime","console","now","currentTime","quantizeTime","BEATS","beats","factor","absolute","inBeats","mod","offsetTime"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,eAAT,QAAgC,gBAAhC;AAEA,MAAMC,GAAG,GAAGF,KAAK,CAAC,YAAD,CAAjB;AAOA,OAAO,MAAMG,WAAN,CAAkB;AAOvBC,EAAAA,WAAW,CAAC;AAAEC,IAAAA,GAAF;AAAOC,IAAAA;AAAP,GAAD,EAA4B;AAAA,SANhCD,GAMgC;AAAA,SALhCC,QAKgC;AAAA,SAJ/BC,KAI+B,GAJf,CAIe;AAAA,SAH/BC,SAG+B,GAHX,CAGW;AAAA,SAF/BC,OAE+B;AACrC,SAAKJ,GAAL,GAAWA,GAAX;AACA,SAAKC,QAAL,GAAgBA,QAAQ,IAAI,CAA5B;AACAL,IAAAA,eAAe,GAAGS,IAAlB,CAAuBC,GAAG,IAAK,KAAKF,OAAL,GAAeE,GAA9C;AACD;;AAEMC,EAAAA,SAAP,CAAiBC,IAAjB,EAA+B;AAC7B,QAAI,CAAC,KAAKJ,OAAV,EAAmB;AACjB,aAAOI,IAAP;AACD;;AAEDA,IAAAA,IAAI,GAAG,KAAKC,QAAL,CAAcD,IAAd,CAAP;AACA,SAAKN,KAAL,IAAc,CAAd;;AAEA,QAAI,KAAKA,KAAL,KAAe,CAAnB,EAAsB;AACpB,WAAKC,SAAL,GAAiBK,IAAjB;AACD;;AACD,WAAOA,IAAP;AACD;;AAEME,EAAAA,QAAP,CAAgBF,IAAhB,EAA8B;AAC5B,QAAI,CAAC,KAAKJ,OAAV,EAAmB;AACjB,aAAOI,IAAP;AACD;;AAEDA,IAAAA,IAAI,GAAG,KAAKC,QAAL,CAAcD,IAAd,CAAP;AACA,SAAKN,KAAL,IAAc,CAAd;;AAEA,QAAI,KAAKA,KAAL,KAAe,CAAnB,EAAsB;AACpB,WAAKC,SAAL,GAAiB,CAAjB;AACD;;AACD,WAAOK,IAAP;AACD;;AAEOC,EAAAA,QAAR,CAAiBD,IAAjB,EAA+B;AAC7BG,IAAAA,OAAO,CAACd,GAAR,CAAY,OAAZ,EAAqBW,IAArB,EAA2B,IAA3B;;AACA,QAAI,CAAC,KAAKJ,OAAV,EAAmB;AACjB,aAAOI,IAAP;AACD;;AAED,UAAMI,GAAG,GAAG,KAAKR,OAAL,CAAaS,WAAzB;;AACA,QAAI,KAAKV,SAAL,KAAmB,CAAvB,EAA0B;AACxB,aAAOS,GAAP;AACD;;AAED,WAAOE,YAAY,CAAC,KAAKd,GAAN,EAAWY,GAAX,EAAgB,KAAKT,SAArB,EAAgC,KAAKF,QAArC,CAAnB;AACD;;AArDsB;AAuDzB,MAAMc,KAAK,GAAG,CAAd;AAEA;;;;;;;;;AAQA,OAAO,SAASD,YAAT,CACLd,GADK,EAELY,GAFK,EAGLT,SAHK,EAILa,KAAK,GAAGD,KAJH,EAKG;AACR,QAAME,MAAM,GAAGjB,GAAG,IAAI,KAAKgB,KAAT,CAAlB;AACA,QAAME,QAAQ,GAAGN,GAAG,GAAGT,SAAvB;;AACA,MAAIe,QAAQ,KAAK,CAAjB,EAAoB;AAClB,WAAO,CAAP;AACD;;AACD,QAAMC,OAAO,GAAGD,QAAQ,GAAGD,MAA3B;AACA,QAAMG,GAAG,GAAGD,OAAO,GAAG,CAAtB;AACA,QAAME,UAAU,GAAG,CAAC,IAAID,GAAL,IAAYH,MAA/B;AACA,SAAOI,UAAP;AACD","sourcesContent":["import debug from \"debug\";\nimport { getAudioContext } from \"./AudioContext\";\n\nconst log = debug(\"atpls:time\");\n\ninterface Config {\n  bpm: number;\n  quantize: number;\n}\n\nexport class TimeManager {\n  public bpm: number;\n  public quantize: number;\n  private count: number = 0;\n  private startedAt: number = 0;\n  private context?: AudioContext;\n\n  constructor({ bpm, quantize }: Config) {\n    this.bpm = bpm;\n    this.quantize = quantize || 1;\n    getAudioContext().then(ctx => (this.context = ctx));\n  }\n\n  public startTime(time: number) {\n    if (!this.context) {\n      return time;\n    }\n\n    time = this.nextTime(time);\n    this.count += 1;\n\n    if (this.count === 1) {\n      this.startedAt = time;\n    }\n    return time;\n  }\n\n  public stopTime(time: number) {\n    if (!this.context) {\n      return time;\n    }\n\n    time = this.nextTime(time);\n    this.count -= 1;\n\n    if (this.count === 0) {\n      this.startedAt = 0;\n    }\n    return time;\n  }\n\n  private nextTime(time: number) {\n    console.log(\"NEXT!\", time, this);\n    if (!this.context) {\n      return time;\n    }\n\n    const now = this.context.currentTime;\n    if (this.startedAt === 0) {\n      return now;\n    }\n\n    return quantizeTime(this.bpm, now, this.startedAt, this.quantize);\n  }\n}\nconst BEATS = 1;\n\n/**\n * Calculate the time remaining until the next beat\n *\n * @param {*} bpm\n * @param {*} now\n * @param {*} startedAt\n * @param {*} beats\n */\nexport function quantizeTime(\n  bpm: number,\n  now: number,\n  startedAt: number,\n  beats = BEATS,\n): number {\n  const factor = bpm / (60 * beats);\n  const absolute = now - startedAt;\n  if (absolute === 0) {\n    return 0;\n  }\n  const inBeats = absolute * factor;\n  const mod = inBeats % 1;\n  const offsetTime = (1 - mod) / factor;\n  return offsetTime;\n}\n"]},"metadata":{},"sourceType":"module"}