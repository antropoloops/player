{"ast":null,"code":"import { getAudioContext } from \"./AudioContext\";\nexport class TimeManager {\n  constructor({\n    bpm,\n    quantize\n  }) {\n    this.bpm = void 0;\n    this.quantize = void 0;\n    this.count = 0;\n    this.startedAt = 0;\n    this.context = void 0;\n    this.bpm = bpm;\n    this.quantize = quantize;\n    getAudioContext().then(ctx => this.context = ctx);\n  }\n\n  startTime(time) {\n    if (!this.context) {\n      return time;\n    }\n\n    time = this.nextTime(time);\n    this.count += 1;\n\n    if (this.count === 1) {\n      this.startedAt = time;\n    }\n\n    return time;\n  }\n\n  stopTime(time) {\n    if (!this.context) {\n      return time;\n    }\n\n    time = this.nextTime(time);\n    this.count -= 1;\n\n    if (this.count === 0) {\n      this.startedAt = 0;\n    }\n\n    return time;\n  }\n\n  nextTime(time) {\n    if (!this.context) {\n      return time;\n    }\n\n    const now = this.context.currentTime;\n\n    if (this.startedAt === 0) {\n      return now;\n    }\n\n    time = quantizeTime(this.bpm, now, this.startedAt, this.quantize);\n    return time;\n  }\n\n}\nconst BEATS = 1;\n/**\n * Calculate the time remaining until the next beat\n *\n * @param {*} bpm\n * @param {*} now\n * @param {*} startedAt\n * @param {*} beats\n */\n\nexport function quantizeTime(bpm, now, startedAt, beats = BEATS) {\n  const factor = bpm / (60 * beats);\n  const absolute = now - startedAt;\n\n  if (absolute === 0) {\n    return 0;\n  }\n\n  const inBeats = absolute * factor;\n  const mod = inBeats % 1;\n  const offsetTime = (1 - mod) / factor;\n  return offsetTime;\n}","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/src/player/TimeManager.ts"],"names":["getAudioContext","TimeManager","constructor","bpm","quantize","count","startedAt","context","then","ctx","startTime","time","nextTime","stopTime","now","currentTime","quantizeTime","BEATS","beats","factor","absolute","inBeats","mod","offsetTime"],"mappings":"AAAA,SAASA,eAAT,QAAgC,gBAAhC;AAOA,OAAO,MAAMC,WAAN,CAAkB;AAOvBC,EAAAA,WAAW,CAAC;AAAEC,IAAAA,GAAF;AAAOC,IAAAA;AAAP,GAAD,EAA4B;AAAA,SANhCD,GAMgC;AAAA,SALhCC,QAKgC;AAAA,SAJ/BC,KAI+B,GAJf,CAIe;AAAA,SAH/BC,SAG+B,GAHX,CAGW;AAAA,SAF/BC,OAE+B;AACrC,SAAKJ,GAAL,GAAWA,GAAX;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACAJ,IAAAA,eAAe,GAAGQ,IAAlB,CAAuBC,GAAG,IAAK,KAAKF,OAAL,GAAeE,GAA9C;AACD;;AAEMC,EAAAA,SAAP,CAAiBC,IAAjB,EAA+B;AAC7B,QAAI,CAAC,KAAKJ,OAAV,EAAmB;AACjB,aAAOI,IAAP;AACD;;AAEDA,IAAAA,IAAI,GAAG,KAAKC,QAAL,CAAcD,IAAd,CAAP;AACA,SAAKN,KAAL,IAAc,CAAd;;AAEA,QAAI,KAAKA,KAAL,KAAe,CAAnB,EAAsB;AACpB,WAAKC,SAAL,GAAiBK,IAAjB;AACD;;AACD,WAAOA,IAAP;AACD;;AAEME,EAAAA,QAAP,CAAgBF,IAAhB,EAA8B;AAC5B,QAAI,CAAC,KAAKJ,OAAV,EAAmB;AACjB,aAAOI,IAAP;AACD;;AAEDA,IAAAA,IAAI,GAAG,KAAKC,QAAL,CAAcD,IAAd,CAAP;AACA,SAAKN,KAAL,IAAc,CAAd;;AAEA,QAAI,KAAKA,KAAL,KAAe,CAAnB,EAAsB;AACpB,WAAKC,SAAL,GAAiB,CAAjB;AACD;;AACD,WAAOK,IAAP;AACD;;AAEOC,EAAAA,QAAR,CAAiBD,IAAjB,EAA+B;AAC7B,QAAI,CAAC,KAAKJ,OAAV,EAAmB;AACjB,aAAOI,IAAP;AACD;;AAED,UAAMG,GAAG,GAAG,KAAKP,OAAL,CAAaQ,WAAzB;;AACA,QAAI,KAAKT,SAAL,KAAmB,CAAvB,EAA0B;AACxB,aAAOQ,GAAP;AACD;;AACDH,IAAAA,IAAI,GAAGK,YAAY,CAAC,KAAKb,GAAN,EAAWW,GAAX,EAAgB,KAAKR,SAArB,EAAgC,KAAKF,QAArC,CAAnB;AACA,WAAOO,IAAP;AACD;;AApDsB;AAsDzB,MAAMM,KAAK,GAAG,CAAd;AAEA;;;;;;;;;AAQA,OAAO,SAASD,YAAT,CACLb,GADK,EAELW,GAFK,EAGLR,SAHK,EAILY,KAAK,GAAGD,KAJH,EAKG;AACR,QAAME,MAAM,GAAGhB,GAAG,IAAI,KAAKe,KAAT,CAAlB;AACA,QAAME,QAAQ,GAAGN,GAAG,GAAGR,SAAvB;;AACA,MAAIc,QAAQ,KAAK,CAAjB,EAAoB;AAClB,WAAO,CAAP;AACD;;AACD,QAAMC,OAAO,GAAGD,QAAQ,GAAGD,MAA3B;AACA,QAAMG,GAAG,GAAGD,OAAO,GAAG,CAAtB;AACA,QAAME,UAAU,GAAG,CAAC,IAAID,GAAL,IAAYH,MAA/B;AACA,SAAOI,UAAP;AACD","sourcesContent":["import { getAudioContext } from \"./AudioContext\";\n\ninterface Config {\n  bpm: number;\n  quantize: number;\n}\n\nexport class TimeManager {\n  public bpm: number;\n  public quantize: number;\n  private count: number = 0;\n  private startedAt: number = 0;\n  private context?: AudioContext;\n\n  constructor({ bpm, quantize }: Config) {\n    this.bpm = bpm;\n    this.quantize = quantize;\n    getAudioContext().then(ctx => (this.context = ctx));\n  }\n\n  public startTime(time: number) {\n    if (!this.context) {\n      return time;\n    }\n\n    time = this.nextTime(time);\n    this.count += 1;\n\n    if (this.count === 1) {\n      this.startedAt = time;\n    }\n    return time;\n  }\n\n  public stopTime(time: number) {\n    if (!this.context) {\n      return time;\n    }\n\n    time = this.nextTime(time);\n    this.count -= 1;\n\n    if (this.count === 0) {\n      this.startedAt = 0;\n    }\n    return time;\n  }\n\n  private nextTime(time: number) {\n    if (!this.context) {\n      return time;\n    }\n\n    const now = this.context.currentTime;\n    if (this.startedAt === 0) {\n      return now;\n    }\n    time = quantizeTime(this.bpm, now, this.startedAt, this.quantize);\n    return time;\n  }\n}\nconst BEATS = 1;\n\n/**\n * Calculate the time remaining until the next beat\n *\n * @param {*} bpm\n * @param {*} now\n * @param {*} startedAt\n * @param {*} beats\n */\nexport function quantizeTime(\n  bpm: number,\n  now: number,\n  startedAt: number,\n  beats = BEATS,\n): number {\n  const factor = bpm / (60 * beats);\n  const absolute = now - startedAt;\n  if (absolute === 0) {\n    return 0;\n  }\n  const inBeats = absolute * factor;\n  const mod = inBeats % 1;\n  const offsetTime = (1 - mod) / factor;\n  return offsetTime;\n}\n"]},"metadata":{},"sourceType":"module"}