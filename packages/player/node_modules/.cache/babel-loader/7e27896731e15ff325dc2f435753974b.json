{"ast":null,"code":"import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport const createNativeAudioWorkletNodeFakerFactory = (auxiliaryGainNodeStore, connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, monitorConnections) => {\n  return (nativeContext, baseLatency, processorConstructor, options) => {\n    if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n      throw createNotSupportedError();\n    }\n\n    if (options.outputChannelCount !== undefined) {\n      // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n      if (options.outputChannelCount.some(channelCount => channelCount < 1)) {\n        throw createNotSupportedError();\n      }\n\n      if (options.outputChannelCount.length !== options.numberOfOutputs) {\n        throw createIndexSizeError();\n      }\n    } // Bug #61: This is not part of the standard but required for the faker to work.\n\n\n    if (options.channelCountMode !== 'explicit') {\n      throw createNotSupportedError();\n    }\n\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length; // Bug #61: This is not part of the standard but required for the faker to work.\n\n    if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n      throw createNotSupportedError();\n    }\n\n    const messageChannel = new MessageChannel();\n    const gainNodes = [];\n    const inputChannelSplitterNodes = [];\n\n    for (let i = 0; i < options.numberOfInputs; i += 1) {\n      gainNodes.push(createNativeGainNode(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: options.channelCountMode,\n        channelInterpretation: options.channelInterpretation,\n        gain: 1\n      }));\n      inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'discrete',\n        numberOfOutputs: options.channelCount\n      }));\n    }\n\n    const constantSourceNodes = [];\n\n    if (processorConstructor.parameterDescriptors !== undefined) {\n      for (const _ref of processorConstructor.parameterDescriptors) {\n        const defaultValue = _ref.defaultValue;\n        const maxValue = _ref.maxValue;\n        const minValue = _ref.minValue;\n        const name = _ref.name;\n        const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          offset: options.parameterData[name] !== undefined ? options.parameterData[name] : defaultValue === undefined ? 0 : defaultValue\n        });\n        Object.defineProperties(constantSourceNode.offset, {\n          defaultValue: {\n            get: () => defaultValue === undefined ? 0 : defaultValue\n          },\n          maxValue: {\n            get: () => maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue\n          },\n          minValue: {\n            get: () => minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue\n          }\n        });\n        constantSourceNodes.push(constantSourceNode);\n      }\n    }\n\n    const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'speakers',\n      numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n    });\n    const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n    const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n    Math.max(1, numberOfOutputChannels));\n    const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n      channelCount: Math.max(1, numberOfOutputChannels),\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      numberOfOutputs: Math.max(1, numberOfOutputChannels)\n    });\n    const outputChannelMergerNodes = [];\n\n    for (let i = 0; i < options.numberOfOutputs; i += 1) {\n      outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n        channelCount: 1,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'speakers',\n        numberOfInputs: options.outputChannelCount[i]\n      }));\n    }\n\n    for (let i = 0; i < options.numberOfInputs; i += 1) {\n      gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n      for (let j = 0; j < options.channelCount; j += 1) {\n        inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n      }\n    }\n\n    const parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.map(({\n      name\n    }, index) => {\n      const constantSourceNode = constantSourceNodes[index];\n      constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n      constantSourceNode.start(0);\n      return [name, constantSourceNode.offset];\n    }));\n    inputChannelMergerNode.connect(scriptProcessorNode);\n    let channelInterpretation = options.channelInterpretation;\n    let onprocessorerror = null; // Bug #87: Expose at least one output to make this node connectable.\n\n    const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n    const nativeAudioWorkletNodeFaker = {\n      get bufferSize() {\n        return bufferSize;\n      },\n\n      get channelCount() {\n        return options.channelCount;\n      },\n\n      set channelCount(_) {\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        throw createInvalidStateError();\n      },\n\n      get channelCountMode() {\n        return options.channelCountMode;\n      },\n\n      set channelCountMode(_) {\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        throw createInvalidStateError();\n      },\n\n      get channelInterpretation() {\n        return channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        for (const gainNode of gainNodes) {\n          gainNode.channelInterpretation = value;\n        }\n\n        channelInterpretation = value;\n      },\n\n      get context() {\n        return scriptProcessorNode.context;\n      },\n\n      get inputs() {\n        return gainNodes;\n      },\n\n      get numberOfInputs() {\n        return options.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return options.numberOfOutputs;\n      },\n\n      get onprocessorerror() {\n        return onprocessorerror;\n      },\n\n      set onprocessorerror(value) {\n        if (typeof onprocessorerror === 'function') {\n          nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n        }\n\n        onprocessorerror = typeof value === 'function' ? value : null;\n\n        if (typeof onprocessorerror === 'function') {\n          nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n        }\n      },\n\n      get parameters() {\n        return parameterMap;\n      },\n\n      get port() {\n        return messageChannel.port2;\n      },\n\n      addEventListener(...args) {\n        return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n      },\n\n      connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n      disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n\n      dispatchEvent(...args) {\n        return scriptProcessorNode.dispatchEvent(args[0]);\n      },\n\n      removeEventListener(...args) {\n        return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n      }\n\n    };\n    const patchedEventListeners = new Map(); // tslint:disable-line:max-line-length\n\n    messageChannel.port1.addEventListener = (addEventListener => {\n      return (...args) => {\n        if (args[0] === 'message') {\n          const unpatchedEventListener = typeof args[1] === 'function' ? args[1] : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function' ? args[1].handleEvent : null;\n\n          if (unpatchedEventListener !== null) {\n            const patchedEventListener = patchedEventListeners.get(args[1]);\n\n            if (patchedEventListener !== undefined) {\n              args[1] = patchedEventListener;\n            } else {\n              args[1] = event => {\n                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));\n              };\n\n              patchedEventListeners.set(unpatchedEventListener, args[1]);\n            }\n          }\n        }\n\n        return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    })(messageChannel.port1.addEventListener);\n\n    messageChannel.port1.removeEventListener = (removeEventListener => {\n      return (...args) => {\n        if (args[0] === 'message') {\n          const patchedEventListener = patchedEventListeners.get(args[1]);\n\n          if (patchedEventListener !== undefined) {\n            patchedEventListeners.delete(args[1]);\n            args[1] = patchedEventListener;\n          }\n        }\n\n        return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    })(messageChannel.port1.removeEventListener);\n\n    let onmessage = null;\n    Object.defineProperty(messageChannel.port1, 'onmessage', {\n      get: () => onmessage,\n      set: value => {\n        if (typeof onmessage === 'function') {\n          messageChannel.port1.removeEventListener('message', onmessage);\n        }\n\n        onmessage = typeof value === 'function' ? value : null;\n\n        if (typeof onmessage === 'function') {\n          messageChannel.port1.addEventListener('message', onmessage);\n          messageChannel.port1.start();\n        }\n      }\n    });\n    processorConstructor.prototype.port = messageChannel.port1;\n    let audioWorkletProcessor = null;\n    const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n    audioWorkletProcessorPromise.then(dWrkltPrcssr => audioWorkletProcessor = dWrkltPrcssr);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n    const parameters = processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.reduce((prmtrs, {\n      name\n    }) => ({ ...prmtrs,\n      [name]: new Float32Array(128)\n    }), {});\n    let isActive = true;\n\n    const disconnectOutputsGraph = () => {\n      if (options.numberOfOutputs > 0) {\n        scriptProcessorNode.disconnect(outputChannelSplitterNode);\n      }\n\n      for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n        const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n        for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n          outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n        }\n\n        outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n      }\n    };\n\n    scriptProcessorNode.onaudioprocess = ({\n      inputBuffer,\n      outputBuffer\n    }) => {\n      if (audioWorkletProcessor !== null) {\n        for (let i = 0; i < bufferSize; i += 128) {\n          for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.channelCount; k += 1) {\n              copyFromChannel(inputBuffer, inputs[j], k, k, i);\n            }\n          }\n\n          if (processorConstructor.parameterDescriptors !== undefined) {\n            processorConstructor.parameterDescriptors.forEach(({\n              name\n            }, index) => {\n              copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n          }\n\n          for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n              // The byteLength will be 0 when the ArrayBuffer was transferred.\n              if (outputs[j][k].byteLength === 0) {\n                outputs[j][k] = new Float32Array(128);\n              }\n            }\n          }\n\n          try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n              const auxiliaryGainNodes = auxiliaryGainNodeStore.get(nativeAudioWorkletNodeFaker);\n\n              if (auxiliaryGainNodes === undefined || auxiliaryGainNodes.get(index) === undefined) {\n                return [new Float32Array(0)];\n              }\n\n              return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + i / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            isActive = activeSourceFlag;\n\n            for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n              for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n              }\n\n              outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n            }\n          } catch (error) {\n            isActive = false;\n            nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', {\n              error\n            }));\n          }\n\n          if (!isActive) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n              gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n\n              for (let k = 0; k < options.channelCount; k += 1) {\n                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n              }\n            }\n\n            if (processorConstructor.parameterDescriptors !== undefined) {\n              const length = processorConstructor.parameterDescriptors.length;\n\n              for (let j = 0; j < length; j += 1) {\n                const constantSourceNode = constantSourceNodes[j];\n                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                constantSourceNode.stop();\n              }\n            }\n\n            inputChannelMergerNode.disconnect(scriptProcessorNode);\n            scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n\n            if (isConnected) {\n              disconnectOutputsGraph();\n            }\n\n            break;\n          }\n        }\n      }\n    };\n\n    let isConnected = false;\n\n    const whenConnected = () => {\n      if (isActive) {\n        if (options.numberOfOutputs > 0) {\n          scriptProcessorNode.connect(outputChannelSplitterNode);\n        }\n\n        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n          const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n          for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n          }\n\n          outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n        }\n      }\n\n      isConnected = true;\n    };\n\n    const whenDisconnected = () => {\n      if (isActive) {\n        disconnectOutputsGraph();\n      }\n\n      isConnected = false;\n    };\n\n    return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"sources":["/Users/dani/Antropoloops/atpls-player/node_modules/standardized-audio-context/build/es2018/factories/native-audio-worklet-node-faker-factory.js"],"names":["MOST_NEGATIVE_SINGLE_FLOAT","MOST_POSITIVE_SINGLE_FLOAT","computeBufferSize","copyFromChannel","copyToChannel","createAudioWorkletProcessor","createNestedArrays","ReadOnlyMap","createNativeAudioWorkletNodeFakerFactory","auxiliaryGainNodeStore","connectMultipleOutputs","createIndexSizeError","createInvalidStateError","createNativeChannelMergerNode","createNativeChannelSplitterNode","createNativeConstantSourceNode","createNativeGainNode","createNativeScriptProcessorNode","createNotSupportedError","disconnectMultipleOutputs","exposeCurrentFrameAndCurrentTime","monitorConnections","nativeContext","baseLatency","processorConstructor","options","numberOfInputs","numberOfOutputs","outputChannelCount","undefined","some","channelCount","length","channelCountMode","numberOfInputChannels","numberOfOutputChannels","reduce","sum","value","numberOfParameters","parameterDescriptors","messageChannel","MessageChannel","gainNodes","inputChannelSplitterNodes","i","push","channelInterpretation","gain","constantSourceNodes","defaultValue","maxValue","minValue","name","constantSourceNode","offset","parameterData","Object","defineProperties","get","inputChannelMergerNode","Math","max","bufferSize","sampleRate","scriptProcessorNode","outputChannelSplitterNode","outputChannelMergerNodes","connect","j","parameterMap","map","index","start","onprocessorerror","outputAudioNodes","nativeAudioWorkletNodeFaker","_","gainNode","context","inputs","removeEventListener","addEventListener","parameters","port","port2","args","bind","disconnect","dispatchEvent","patchedEventListeners","Map","port1","unpatchedEventListener","handleEvent","patchedEventListener","event","currentTime","set","call","delete","onmessage","defineProperty","prototype","audioWorkletProcessor","audioWorkletProcessorPromise","then","dWrkltPrcssr","outputs","prmtrs","Float32Array","isActive","disconnectOutputsGraph","outputChannelSplitterNodeOutput","outputChannelMergerNode","onaudioprocess","inputBuffer","outputBuffer","k","forEach","byteLength","potentiallyEmptyInputs","input","auxiliaryGainNodes","activeSourceFlag","process","error","ErrorEvent","stop","isConnected","whenConnected","whenDisconnected"],"mappings":"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","sourcesContent":["import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport const createNativeAudioWorkletNodeFakerFactory = (auxiliaryGainNodeStore, connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, monitorConnections) => {\n    return (nativeContext, baseLatency, processorConstructor, options) => {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n            throw createNotSupportedError();\n        }\n        if (options.outputChannelCount !== undefined) {\n            // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n            if (options.outputChannelCount.some((channelCount) => (channelCount < 1))) {\n                throw createNotSupportedError();\n            }\n            if (options.outputChannelCount.length !== options.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n        }\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n            throw createNotSupportedError();\n        }\n        const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const numberOfParameters = (processorConstructor.parameterDescriptors === undefined)\n            ? 0\n            : processorConstructor.parameterDescriptors.length;\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n            throw createNotSupportedError();\n        }\n        const messageChannel = new MessageChannel();\n        const gainNodes = [];\n        const inputChannelSplitterNodes = [];\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes.push(createNativeGainNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n            }));\n            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n            }));\n        }\n        const constantSourceNodes = [];\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: (options.parameterData[name] !== undefined)\n                        ? options.parameterData[name]\n                        : (defaultValue === undefined)\n                            ? 0\n                            : defaultValue\n                });\n                Object.defineProperties(constantSourceNode.offset, {\n                    defaultValue: {\n                        get: () => (defaultValue === undefined) ? 0 : defaultValue\n                    },\n                    maxValue: {\n                        get: () => (maxValue === undefined) ? MOST_POSITIVE_SINGLE_FLOAT : maxValue\n                    },\n                    minValue: {\n                        get: () => (minValue === undefined) ? MOST_NEGATIVE_SINGLE_FLOAT : minValue\n                    }\n                });\n                constantSourceNodes.push(constantSourceNode);\n            }\n        }\n        const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, \n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        Math.max(1, numberOfOutputChannels));\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n        for (let i = 0; i < options.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: options.outputChannelCount[i]\n            }));\n        }\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n            for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, (i * options.channelCount) + j);\n            }\n        }\n        const parameterMap = new ReadOnlyMap((processorConstructor.parameterDescriptors === undefined)\n            ? []\n            : processorConstructor.parameterDescriptors\n                .map(({ name }, index) => {\n                const constantSourceNode = constantSourceNodes[index];\n                constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                constantSourceNode.start(0);\n                return [name, constantSourceNode.offset];\n            }));\n        inputChannelMergerNode.connect(scriptProcessorNode);\n        let channelInterpretation = options.channelInterpretation;\n        let onprocessorerror = null;\n        // Bug #87: Expose at least one output to make this node connectable.\n        const outputAudioNodes = (options.numberOfOutputs === 0) ? [scriptProcessorNode] : outputChannelMergerNodes;\n        const nativeAudioWorkletNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return options.channelCount;\n            },\n            set channelCount(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelCountMode() {\n                return options.channelCountMode;\n            },\n            set channelCountMode(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelInterpretation() {\n                return channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                for (const gainNode of gainNodes) {\n                    gainNode.channelInterpretation = value;\n                }\n                channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return gainNodes;\n            },\n            get numberOfInputs() {\n                return options.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return options.numberOfOutputs;\n            },\n            get onprocessorerror() {\n                return onprocessorerror;\n            },\n            set onprocessorerror(value) {\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n                }\n                onprocessorerror = (typeof value === 'function') ? value : null;\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n                }\n            },\n            get parameters() {\n                return parameterMap;\n            },\n            get port() {\n                return messageChannel.port2;\n            },\n            addEventListener(...args) {\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n            disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        const patchedEventListeners = new Map(); // tslint:disable-line:max-line-length\n        messageChannel.port1.addEventListener = ((addEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const unpatchedEventListener = (typeof args[1] === 'function')\n                        ? args[1]\n                        : (typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function')\n                            ? args[1].handleEvent\n                            : null;\n                    if (unpatchedEventListener !== null) {\n                        const patchedEventListener = patchedEventListeners.get(args[1]);\n                        if (patchedEventListener !== undefined) {\n                            args[1] = patchedEventListener;\n                        }\n                        else {\n                            args[1] = (event) => {\n                                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));\n                            };\n                            patchedEventListeners.set(unpatchedEventListener, args[1]);\n                        }\n                    }\n                }\n                return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.addEventListener);\n        messageChannel.port1.removeEventListener = ((removeEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const patchedEventListener = patchedEventListeners.get(args[1]);\n                    if (patchedEventListener !== undefined) {\n                        patchedEventListeners.delete(args[1]);\n                        args[1] = patchedEventListener;\n                    }\n                }\n                return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.removeEventListener);\n        let onmessage = null;\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n            get: () => onmessage,\n            set: (value) => {\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.removeEventListener('message', onmessage);\n                }\n                onmessage = (typeof value === 'function') ? value : null;\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.addEventListener('message', onmessage);\n                    messageChannel.port1.start();\n                }\n            }\n        });\n        processorConstructor.prototype.port = messageChannel.port1;\n        let audioWorkletProcessor = null;\n        const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n        audioWorkletProcessorPromise\n            .then((dWrkltPrcssr) => audioWorkletProcessor = dWrkltPrcssr);\n        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n        const parameters = (processorConstructor.parameterDescriptors === undefined) ?\n            [] :\n            processorConstructor.parameterDescriptors\n                .reduce((prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n        let isActive = true;\n        const disconnectOutputsGraph = () => {\n            if (options.numberOfOutputs > 0) {\n                scriptProcessorNode.disconnect(outputChannelSplitterNode);\n            }\n            for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                const outputChannelMergerNode = outputChannelMergerNodes[i];\n                for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                    outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                }\n                outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n            }\n        };\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }) => {\n            if (audioWorkletProcessor !== null) {\n                for (let i = 0; i < bufferSize; i += 128) {\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(inputBuffer, inputs[j], k, k, i);\n                        }\n                    }\n                    if (processorConstructor.parameterDescriptors !== undefined) {\n                        processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                            copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                    }\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                            // The byteLength will be 0 when the ArrayBuffer was transferred.\n                            if (outputs[j][k].byteLength === 0) {\n                                outputs[j][k] = new Float32Array(128);\n                            }\n                        }\n                    }\n                    try {\n                        const potentiallyEmptyInputs = inputs\n                            .map((input, index) => {\n                            const auxiliaryGainNodes = auxiliaryGainNodeStore.get(nativeAudioWorkletNodeFaker);\n                            if (auxiliaryGainNodes === undefined || auxiliaryGainNodes.get(index) === undefined) {\n                                return [new Float32Array(0)];\n                            }\n                            return input;\n                        });\n                        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + (i / nativeContext.sampleRate), nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n                        isActive = activeSourceFlag;\n                        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                            }\n                            outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n                        }\n                    }\n                    catch (error) {\n                        isActive = false;\n                        nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', { error }));\n                    }\n                    if (!isActive) {\n                        for (let j = 0; j < options.numberOfInputs; j += 1) {\n                            gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n                            for (let k = 0; k < options.channelCount; k += 1) {\n                                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, (j * options.channelCount) + k);\n                            }\n                        }\n                        if (processorConstructor.parameterDescriptors !== undefined) {\n                            const length = processorConstructor.parameterDescriptors.length;\n                            for (let j = 0; j < length; j += 1) {\n                                const constantSourceNode = constantSourceNodes[j];\n                                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                                constantSourceNode.stop();\n                            }\n                        }\n                        inputChannelMergerNode.disconnect(scriptProcessorNode);\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        if (isConnected) {\n                            disconnectOutputsGraph();\n                        }\n                        break;\n                    }\n                }\n            }\n        };\n        let isConnected = false;\n        const whenConnected = () => {\n            if (isActive) {\n                if (options.numberOfOutputs > 0) {\n                    scriptProcessorNode.connect(outputChannelSplitterNode);\n                }\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n                }\n            }\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            if (isActive) {\n                disconnectOutputsGraph();\n            }\n            isConnected = false;\n        };\n        return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-worklet-node-faker-factory.js.map"]},"metadata":{},"sourceType":"module"}